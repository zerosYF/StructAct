{
  "config": {
    "mcts_iters": 10,
    "depth_threshold": 5,
    "width_threshold": 3
  },
  "best_node": {
    "action_sequence": [
      "FailureDrivenAction",
      "FailureDrivenAction",
      "FailureDrivenAction",
      "FailureDrivenAction"
    ],
    "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Precompute all arithmetic and factual statements first**:\n   - Evaluate arithmetic expressions with correct precedence: multiplication/division before addition/subtraction. Double-check negative numbers and division (e.g., `-8/10 = -0.8`).\n   - Evaluate factual statements using the definitive fact list below. Replace with True or False immediately.\n   - **Fact list** (use only these):\n        - Canada: Ottawa\n        - Malaysia: Kuala Lumpur\n        - Iran: Tehran\n        - Colombia: Bogotá\n        - Turkey: Ankara\n        - Armenia: Yerevan\n        - Cameroon: Yaoundé\n        - Nepal: Kathmandu\n        - Norway: Oslo\n        - Azerbaijan: Baku\n        - Germany: Berlin\n        - Afghanistan: Kabul\n        - UAE: Abu Dhabi\n        - Iraq: Baghdad\n        - Denmark: Copenhagen\n        - Jordan: Amman\n        - Gambia: Banjul\n\n2. **Simplify logical expressions systematically**:\n   - Start from the innermost parentheses. Use a counter to verify pairings—every opening parenthesis must have a matching closing parenthesis.\n   - Apply logical operators strictly in this order: \n        - `not` (highest precedence). Simplify multiple `not`s immediately: even number of `not`s cancel out; odd number reduce to one `not` (e.g., `not not X = X`, `not not not X = not X`).\n        - `and` \n        - `or` (lowest precedence)\n   - All operators are left-associative. For ambiguous expressions, explicitly group from left: e.g., `A and B or C` is `(A and B) or C`.\n   - Apply short-circuiting aggressively: \n        - If you see `False and ...`, immediately return False (ignore the rest).\n        - If you see `True or ...`, immediately return True (ignore the rest).\n\n3. **Evaluation steps for each expression**:\n   - Step 1: Replace all arithmetic comparisons and factual statements with True/False.\n   - Step 2: Simplify innermost parentheses first, replacing them with their boolean values.\n   - Step 3: Apply `not` operators: simplify multiple `not`s as above.\n   - Step 4: Apply `and`/`or` with short-circuiting.\n   - Step 5: If more than one expression seems True, re-check from Step 1—focus on arithmetic signs, fact errors, and parenthesis grouping.\n\n4. **Output format**:\n   - For each expression, state the result after simplification: \n        Example: \"A: False\" \n   - After all expressions, conclude with: \"Therefore, expression [X] is True.\"\n\n### Few-shot examples demonstrating common failures:\n[Example 1: Expression A from previous failure]\nIncorrect: Evaluated `True and False` as True due to misgrouping.\nCorrect: Always group left-associatively: `(True and False) = False`.\n\n[Example 2: Expression E from previous failure]\nIncorrect: Computed `-5*10 = 50` (sign error).\nCorrect: `-5*10 = -50`. Then `-50 > 9` is False.\n\n[Example 3: Expression B from previous failure]\nIncorrect: Used \"Putrajaya\" for Malaysia's capital.\nCorrect: Use fact list—Kuala Lumpur is correct.\n\n[Example 4: Expression D from previous failure]\nIncorrect: Missed short-circuiting: evaluated entire `False and ...` expression unnecessarily.\nCorrect: Short-circuit—once you see `False and ...`, return False immediately.\n\n[Example 5: Negation chain]\nIncorrect: `not not not not False` evaluated as False.\nCorrect: `not not not not False` = `not not (not not False)` = `not not True` = True.\n\n### Critical reminders:\n- Never trust your memory for facts—use only the provided fact list.\n- Negative numbers: `-5 - 3 = -8` (not -2).\n- Division: `-8/10 = -0.8` (negative divided by positive is negative).\n- Range calculation: `max(a,b,c,d) - min(a,b,c,d)` is always non-negative.\n- If parentheses are ambiguous, assume left-to-right grouping for `and`/`or`.\n- For extremely nested expressions, consider breaking them down into smaller sub-expressions and labeling them for clarity.\n\nNow evaluate the following expressions. Show your results for each expression (A-E), and conclude with the correct answer.",
    "depth": 4,
    "Q": 0.55,
    "N": 0
  },
  "search_tree": {
    "id": 0,
    "depth": 0,
    "action_sequence": [],
    "prompt": "You are an assistant that determines which boolean expression evaluates to True. ",
    "Q": 7.55,
    "N": 18,
    "uct_value": 0.0,
    "reward": 0.35,
    "children": [
      {
        "id": 1,
        "depth": 1,
        "action_sequence": [
          "FailureDrivenAction"
        ],
        "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Handle natural language statements**: All phrases like \"The capital of X is Y\" must be evaluated as True if factually correct, False otherwise. Use standard world knowledge.\n2. **Interpret comparisons**: \"is less than or equal to\" means ≤, \"is greater than\" means >, etc.\n3. **Evaluate arithmetic**: Compute all mathematical expressions carefully, respecting operator precedence.\n4. **Simplify step-by-step**:\n   - Start from the innermost parentheses\n   - Replace all facts and arithmetic with True/False\n   - Apply logical operators from inner to outer\n   - Remember: `not` > `and` > `or` in precedence\n5. **Short-circuit wisely**: If you encounter `False and ...` or `True or ...`, evaluate accordingly without unnecessary computation.\n6. **Verify your work**: If multiple expressions seem True, re-check for errors in grouping or arithmetic.\n\n### Common pitfalls to avoid:\n- Misgrouping due to complex nesting: Count parentheses carefully\n- Arithmetic sign errors: Double-check negative numbers\n- Factual errors: Recall capitals correctly (e.g., Nigeria's capital is Abuja, not Lagos)\n- Don't forget: `not not X` simplifies to X\n- \"max(a,b,c,d) - min(a,b,c,d)\" computes the range\n\n### Examples for reference:\n[Example 1: Expression A]\nIncorrect evaluation: Failed to properly group `and (False)` at the end\nCorrect approach: The entire expression before `and (False)` was True, making `True and False` = False, then `not(False)` = True\n\n[Example 2: Expression E]\nIncorrect evaluation: Misparsed the final `and` operation\nCorrect approach: Compute arithmetic first: -5*10 = -50 > 9? False. Then properly apply all logical operators\n\n[Example 3: Expression C]\nIncorrect evaluation: Missed that \"The capital of Canada is Toronto\" is False\nCorrect approach: All factual statements must be verified against world knowledge\n\nNow evaluate the following expressions. Show your reasoning step-by-step for each expression, and conclude with which one (A-E) is True.\n\n[The five expressions to be evaluated]",
        "Q": 2.8458333333333337,
        "N": 6,
        "uct_value": 0.4834169293836273,
        "reward": 0.4,
        "children": [
          {
            "id": 2,
            "depth": 2,
            "action_sequence": [
              "FailureDrivenAction",
              "FailureDrivenAction"
            ],
            "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Handle natural language statements**: Evaluate phrases like \"The capital of X is Y\" as True only if factually correct based on standard international knowledge (e.g., Nigeria's capital is Abuja; Malaysia's capital is Kuala Lumpur; Iran's capital is Tehran; Colombia's capital is Bogotá).\n2. **Interpret comparisons**: \"is less than or equal to\" means ≤, \"is greater than\" means >, etc.\n3. **Evaluate arithmetic**: Compute mathematical expressions with correct precedence (multiplication/division before addition/subtraction). Double-check negative numbers and division.\n4. **Simplify step-by-step**:\n   - Start from the innermost parentheses. Count parentheses carefully—use a mental stack to match opening and closing parentheses.\n   - Replace facts and arithmetic with True/False.\n   - Apply logical operators: `not` has highest precedence, then `and`, then `or`. `and` and `or` are left-associative.\n   - Simplify sequences of `not`: `not not X` = X, `not not not X` = `not X`, etc.\n5. **Short-circuit strictly**: If you encounter `False and ...`, immediately return False. If you encounter `True or ...`, immediately return True.\n6. **Output format**:\n   - For each expression, evaluate in numbered steps. In each step, process the innermost part, replace it with its value, and simplify.\n   - After all expressions, if more than one seems True, re-check each step for errors in arithmetic, facts, or grouping.\n7. **Final answer**: Conclude with \"Therefore, expression [X] is True.\"\n\n### Common pitfalls to avoid:\n- Miscounting parentheses: Always verify groupings.\n- Arithmetic sign errors: Pay attention to negative numbers (e.g., `-8/10 = -0.8`).\n- Factual errors: Use reliable knowledge for capitals.\n- Forgetting short-circuiting: Avoid unnecessary computations.\n- Misinterpreting operator precedence: `not` > `and` > `or`.\n\n### Few-shot examples for reference:\n[Example 1: Expression A from previous failure]\nIncorrect: Failed to group `and (False)` correctly, leading to incorrect evaluation.\nCorrect approach: Evaluate inner parentheses first, then apply `and`—`True and False` is False.\n\n[Example 2: Expression E from previous failure]\nIncorrect: Misparsed the final `and` operation due to complex nesting.\nCorrect approach: Compute arithmetic first: `-5*10 = -50 > 9` is False. Then apply logical operators step by step.\n\n[Example 3: Expression B from previous failure]\nIncorrect: Incorrectly evaluated due to ambiguity about Malaysia's capital (used Putrajaya instead of Kuala Lumpur).\nCorrect approach: Use standard knowledge—Kuala Lumpur is the capital of Malaysia.\n\nNow evaluate the following expressions. Show your reasoning step-by-step for each expression, and conclude with which one (A-E) is True.",
            "Q": 2.433333333333333,
            "N": 5,
            "uct_value": 0.499179742138137,
            "reward": 0.4,
            "children": [
              {
                "id": 3,
                "depth": 3,
                "action_sequence": [
                  "FailureDrivenAction",
                  "FailureDrivenAction",
                  "FailureDrivenAction"
                ],
                "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Precompute all arithmetic and factual statements first**:\n   - Evaluate arithmetic expressions with correct precedence: multiplication/division before addition/subtraction. Double-check negative numbers and division (e.g., `-8/10 = -0.8`).\n   - Evaluate factual statements using the definitive fact list below. Replace with True or False immediately.\n   - **Fact list**:\n        - Canada: Ottawa (not Toronto)\n        - Malaysia: Kuala Lumpur (not Putrajaya)\n        - Iran: Tehran (not Isfahan)\n        - Colombia: Bogotá (not Medellín)\n        - Turkey: Ankara\n        - Armenia: Yerevan (not Gyumri)\n        - Cameroon: Yaoundé (not Douala)\n        - Nepal: Kathmandu (not Pokhara)\n        - Norway: Oslo\n        - Azerbaijan: Baku\n        - Germany: Berlin\n        - Afghanistan: Kabul (not Kandahar)\n        - UAE: Abu Dhabi\n        - Iraq: Baghdad\n        - Denmark: Copenhagen (not Aarhus)\n        - Jordan: Amman (not Beirut)\n        - Gambia: Banjul (not Libreville)\n\n2. **Simplify logical expressions systematically**:\n   - Start from the innermost parentheses. Use a counter to verify pairings—every opening parenthesis must have a matching closing parenthesis.\n   - Apply logical operators strictly in this order: \n        - `not` (highest precedence)\n        - `and` \n        - `or` (lowest precedence)\n   - All operators are left-associative. For ambiguous expressions, explicitly group from left: e.g., `A and B or C` is `(A and B) or C`.\n   - Apply short-circuiting aggressively: \n        - If you see `False and ...`, immediately return False (ignore the rest).\n        - If you see `True or ...`, immediately return True (ignore the rest).\n\n3. **Evaluation steps for each expression**:\n   - Step 1: Replace all arithmetic comparisons and factual statements with True/False.\n   - Step 2: Simplify innermost parentheses first, replacing them with their boolean values.\n   - Step 3: Apply `not` operators: simplify multiple `not`s (e.g., `not not X = X`, `not not not X = not X`).\n   - Step 4: Apply `and`/`or` with short-circuiting.\n   - Step 5: If more than one expression seems True, re-check from Step 1—focus on arithmetic signs, fact errors, and parenthesis grouping.\n\n4. **Output format**:\n   - For each expression, state the result after simplification: \n        Example: \"A: False\" \n   - After all expressions, conclude with: \"Therefore, expression [X] is True.\"\n\n### Few-shot examples demonstrating common failures:\n[Example 1: Expression A from previous failure]\nIncorrect: Evaluated `True and False` as True due to misgrouping.\nCorrect: Always group left-associatively: `(True and False) = False`.\n\n[Example 2: Expression E from previous failure]\nIncorrect: Computed `-5*10 = 50` (sign error).\nCorrect: `-5*10 = -50`. Then `-50 > 9` is False.\n\n[Example 3: Expression B from previous failure]\nIncorrect: Used \"Putrajaya\" for Malaysia's capital.\nCorrect: Use fact list—Kuala Lumpur is correct.\n\n[Example 4: Expression D from previous failure]\nIncorrect: Missed short-circuiting: evaluated entire `False and ...` expression unnecessarily.\nCorrect: Short-circuit—once you see `False and ...`, return False immediately.\n\n### Critical reminders:\n- Never trust your memory for facts—use the provided fact list.\n- Negative numbers: `-5 - 3 = -8` (not -2).\n- Division: `-8/10 = -0.8` (negative divided by positive is negative).\n- Range calculation: `max(a,b,c,d) - min(a,b,c,d)` is always non-negative.\n- If parentheses are ambiguous, assume left-to-right grouping for `and`/`or`.\n\nNow evaluate the following expressions. Show your results for each expression (A-E), and conclude with the correct answer.",
                "Q": 1.1833333333333333,
                "N": 2,
                "uct_value": 0.5948382540980296,
                "reward": 0.5,
                "children": [
                  {
                    "id": 4,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Precompute all arithmetic and factual statements first**:\n   - Evaluate arithmetic expressions with correct precedence: multiplication/division before addition/subtraction. Double-check negative numbers and division (e.g., `-8/10 = -0.8`).\n   - Evaluate factual statements using the definitive fact list below. Replace with True or False immediately.\n   - **Fact list**:\n        - Canada: Ottawa\n        - Malaysia: Kuala Lumpur\n        - Iran: Tehran\n        - Colombia: Bogotá\n        - Turkey: Ankara\n        - Armenia: Yerevan\n        - Cameroon: Yaoundé\n        - Nepal: Kathmandu\n        - Norway: Oslo\n        - Azerbaijan: Baku\n        - Germany: Berlin\n        - Afghanistan: Kabul\n        - UAE: Abu Dhabi\n        - Iraq: Baghdad\n        - Denmark: Copenhagen\n        - Jordan: Amman\n        - Gambia: Banjul\n        - Any capital not listed is False.\n\n2. **Simplify logical expressions systematically**:\n   - Start from the innermost parentheses. Use a counter to verify pairings—every opening parenthesis must have a matching closing parenthesis.\n   - Apply logical operators strictly in this order: \n        - `not` (highest precedence)\n        - `and` \n        - `or` (lowest precedence)\n   - All operators are left-associative. For ambiguous expressions, explicitly group from left: e.g., `A and B or C` is `(A and B) or C`.\n   - Apply short-circuiting aggressively: \n        - If you see `False and ...`, immediately return False (ignore the rest).\n        - If you see `True or ...`, immediately return True (ignore the rest).\n\n3. **Evaluation steps for each expression**:\n   - Step 1: Replace all arithmetic comparisons and factual statements with True/False.\n   - Step 2: Simplify innermost parentheses first, replacing them with their boolean values.\n   - Step 3: Apply `not` operators: simplify multiple `not`s (e.g., `not not X = X`, `not not not X = not X`).\n   - Step 4: Apply `and`/`or` with short-circuiting.\n   - Step 5: If more than one expression seems True, re-check from Step 1—focus on arithmetic signs, fact errors, and parenthesis grouping.\n\n4. **Output format**:\n   - For each expression, state the result after simplification: \n        Example: \"A: False\" \n   - After all expressions, conclude with: \"Therefore, expression [X] is True.\"\n\n### Few-shot examples demonstrating common failures:\n[Example 1: Expression A from previous failure]\nIncorrect: Evaluated `True and False` as True due to misgrouping.\nCorrect: Always group left-associatively: `(True and False) = False`.\n\n[Example 2: Expression E from previous failure]\nIncorrect: Computed `-5*10 = 50` (sign error).\nCorrect: `-5*10 = -50`. Then `-50 > 9` is False.\n\n[Example 3: Expression B from previous failure]\nIncorrect: Used \"Putrajaya\" for Malaysia's capital.\nCorrect: Use fact list—Kuala Lumpur is correct.\n\n[Example 4: Expression D from previous failure]\nIncorrect: Missed short-circuiting: evaluated entire `False and ...` expression unnecessarily.\nCorrect: Short-circuit—once you see `False and ...`, return False immediately.\n\n[Example 5: Unlisted fact handling]\nIncorrect: Assumed \"The capital of Belarus is Minsk\" was True.\nCorrect: Any capital not in the fact list is False.\n\n[Example 6: Complex nesting]\nIncorrect: Miscounted `not` operators in `not not not True`.\nCorrect: Simplify step-by-step: `not not not True = not not False = not True = False`.\n\n### Critical reminders:\n- Never trust your memory for facts—use the provided fact list.\n- Negative numbers: `-5 - 3 = -8` (not -2).\n- Division: `-8/10 = -0.8` (negative divided by positive is negative).\n- Range calculation: `max(a,b,c,d) - min(a,b,c,d)` is always non-negative.\n- If parentheses are ambiguous, assume left-to-right grouping for `and`/`or`.\n- If no expression seems True, re-check all arithmetic and facts.\n- If multiple expressions seem True, re-check grouping and short-circuiting.\n\nNow evaluate the following expressions. Show your results for each expression (A-E), and conclude with the correct answer.",
                    "Q": 0.4,
                    "N": 1,
                    "uct_value": 0.002081386527894244,
                    "reward": 0.2,
                    "children": []
                  },
                  {
                    "id": 5,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Precompute all arithmetic and factual statements first**:\n   - Evaluate arithmetic expressions with correct precedence: multiplication/division before addition/subtraction. Double-check negative numbers and division (e.g., `-8/10 = -0.8`).\n   - Evaluate factual statements using the definitive fact list below. Replace with True or False immediately.\n   - **Fact list**:\n        - Canada: Ottawa (not Toronto)\n        - Malaysia: Kuala Lumpur (not Putrajaya)\n        - Iran: Tehran (not Isfahan)\n        - Colombia: Bogotá (not Medellín)\n        - Turkey: Ankara\n        - Armenia: Yerevan (not Gyumri)\n        - Cameroon: Yaoundé (not Douala)\n        - Nepal: Kathmandu (not Pokhara)\n        - Norway: Oslo\n        - Azerbaijan: Baku\n        - Germany: Berlin\n        - Afghanistan: Kabul (not Kandahar)\n        - UAE: Abu Dhabi\n        - Iraq: Baghdad\n        - Denmark: Copenhagen (not Aarhus)\n        - Jordan: Amman (not Beirut)\n        - Gambia: Banjul (not Libreville)\n\n2. **Simplify logical expressions systematically**:\n   - Start from the innermost parentheses. Use a counter to verify pairings—every opening parenthesis must have a matching closing parenthesis.\n   - Apply logical operators strictly in this order: \n        - `not` (highest precedence)\n        - `and` \n        - `or` (lowest precedence)\n   - All operators are left-associative. For ambiguous expressions, explicitly group from left: e.g., `A and B or C` is `(A and B) or C`.\n   - Apply short-circuiting aggressively: \n        - If you see `False and ...`, immediately return False (ignore the rest).\n        - If you see `True or ...`, immediately return True (ignore the rest).\n\n3. **Evaluation steps for each expression**:\n   - **Step 1: List all arithmetic and factual statements** - Compute all arithmetic and replace all facts with True/False. Show all substitutions.\n   - **Step 2: Simplify innermost parentheses** - Process the deepest nested subexpression first. Replace it with its boolean value.\n   - **Step 3: Apply `not` operators** - Simplify multiple `not`s (e.g., `not not X = X`, `not not not X = not X`).\n   - **Step 4: Apply `and`/`or` with short-circuiting** - Check for short-circuiting opportunities at every step.\n   - **Step 5: If more than one expression seems True, re-check** - Focus on arithmetic signs, fact errors, and parenthesis grouping.\n\n4. **Output format**:\n   - For each expression, state the result after simplification in this format:\n        A:\n            Step 1: [Arithmetic and fact substitutions]\n            Step 2: [Innermost parentheses simplified]\n            Step 3: [Not operators applied]\n            Step 4: [And/Or with short-circuiting]\n            Result: True/False\n   - After all expressions, conclude with: \"Therefore, expression [X] is True.\"\n\n### Few-shot examples demonstrating common failures:\n[Example 1: Expression A from previous failure]\nIncorrect: Evaluated `True and False` as True due to misgrouping.\nCorrect: Always group left-associatively: `(True and False) = False`.\n\n[Example 2: Expression E from previous failure]\nIncorrect: Computed `-5*10 = 50` (sign error).\nCorrect: `-5*10 = -50`. Then `-50 > 9` is False.\n\n[Example 3: Expression B from previous failure]\nIncorrect: Used \"Putrajaya\" for Malaysia's capital.\nCorrect: Use fact list—Kuala Lumpur is correct.\n\n[Example 4: Expression D from previous failure]\nIncorrect: Missed short-circuiting: evaluated entire `False and ...` expression unnecessarily.\nCorrect: Short-circuit—once you see `False and ...`, return False immediately.\n\n### Critical reminders:\n- Never trust your memory for facts—use the provided fact list.\n- Negative numbers: `-5 - 3 = -8` (not -2).\n- Division: `-8/10 = -0.8` (negative divided by positive is negative).\n- Range calculation: `max(a,b,c,d) - min(a,b,c,d)` is always non-negative.\n- If parentheses are ambiguous, assume left-to-right grouping for `and`/`or`.\n- If multiple expressions seem True, re-check each step carefully—focus on arithmetic signs and fact errors.\n\nNow evaluate the following expressions. Show your results for each expression (A-E) in the required format, and conclude with the correct answer.",
                    "Q": 0.5,
                    "N": 0,
                    "uct_value": 0.002081386527894244,
                    "reward": 0.5,
                    "children": []
                  },
                  {
                    "id": 6,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Precompute all arithmetic and factual statements first**:\n   - Evaluate arithmetic expressions with correct precedence: multiplication/division before addition/subtraction. Double-check negative numbers and division (e.g., `-8/10 = -0.8`).\n   - Evaluate factual statements using the definitive fact list below. Replace with True or False immediately.\n   - **Fact list** (use only these):\n        - Canada: Ottawa\n        - Malaysia: Kuala Lumpur\n        - Iran: Tehran\n        - Colombia: Bogotá\n        - Turkey: Ankara\n        - Armenia: Yerevan\n        - Cameroon: Yaoundé\n        - Nepal: Kathmandu\n        - Norway: Oslo\n        - Azerbaijan: Baku\n        - Germany: Berlin\n        - Afghanistan: Kabul\n        - UAE: Abu Dhabi\n        - Iraq: Baghdad\n        - Denmark: Copenhagen\n        - Jordan: Amman\n        - Gambia: Banjul\n\n2. **Simplify logical expressions systematically**:\n   - Start from the innermost parentheses. Use a counter to verify pairings—every opening parenthesis must have a matching closing parenthesis.\n   - Apply logical operators strictly in this order: \n        - `not` (highest precedence). Simplify multiple `not`s immediately: even number of `not`s cancel out; odd number reduce to one `not` (e.g., `not not X = X`, `not not not X = not X`).\n        - `and` \n        - `or` (lowest precedence)\n   - All operators are left-associative. For ambiguous expressions, explicitly group from left: e.g., `A and B or C` is `(A and B) or C`.\n   - Apply short-circuiting aggressively: \n        - If you see `False and ...`, immediately return False (ignore the rest).\n        - If you see `True or ...`, immediately return True (ignore the rest).\n\n3. **Evaluation steps for each expression**:\n   - Step 1: Replace all arithmetic comparisons and factual statements with True/False.\n   - Step 2: Simplify innermost parentheses first, replacing them with their boolean values.\n   - Step 3: Apply `not` operators: simplify multiple `not`s as above.\n   - Step 4: Apply `and`/`or` with short-circuiting.\n   - Step 5: If more than one expression seems True, re-check from Step 1—focus on arithmetic signs, fact errors, and parenthesis grouping.\n\n4. **Output format**:\n   - For each expression, state the result after simplification: \n        Example: \"A: False\" \n   - After all expressions, conclude with: \"Therefore, expression [X] is True.\"\n\n### Few-shot examples demonstrating common failures:\n[Example 1: Expression A from previous failure]\nIncorrect: Evaluated `True and False` as True due to misgrouping.\nCorrect: Always group left-associatively: `(True and False) = False`.\n\n[Example 2: Expression E from previous failure]\nIncorrect: Computed `-5*10 = 50` (sign error).\nCorrect: `-5*10 = -50`. Then `-50 > 9` is False.\n\n[Example 3: Expression B from previous failure]\nIncorrect: Used \"Putrajaya\" for Malaysia's capital.\nCorrect: Use fact list—Kuala Lumpur is correct.\n\n[Example 4: Expression D from previous failure]\nIncorrect: Missed short-circuiting: evaluated entire `False and ...` expression unnecessarily.\nCorrect: Short-circuit—once you see `False and ...`, return False immediately.\n\n[Example 5: Negation chain]\nIncorrect: `not not not not False` evaluated as False.\nCorrect: `not not not not False` = `not not (not not False)` = `not not True` = True.\n\n### Critical reminders:\n- Never trust your memory for facts—use only the provided fact list.\n- Negative numbers: `-5 - 3 = -8` (not -2).\n- Division: `-8/10 = -0.8` (negative divided by positive is negative).\n- Range calculation: `max(a,b,c,d) - min(a,b,c,d)` is always non-negative.\n- If parentheses are ambiguous, assume left-to-right grouping for `and`/`or`.\n- For extremely nested expressions, consider breaking them down into smaller sub-expressions and labeling them for clarity.\n\nNow evaluate the following expressions. Show your results for each expression (A-E), and conclude with the correct answer.",
                    "Q": 0.55,
                    "N": 0,
                    "uct_value": 0.002081386527894244,
                    "reward": 0.55,
                    "children": [
                      {
                        "id": 7,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Precompute all arithmetic and factual statements first**:\n   - Evaluate arithmetic expressions with correct precedence: multiplication/division before addition/subtraction. Double-check negative numbers and division (e.g., `-8/10 = -0.8`).\n   - Evaluate factual statements using the definitive fact list below. Replace with True or False immediately.\n   - **Fact list** (use only these):\n        - Canada: Ottawa\n        - Malaysia: Kuala Lumpur\n        - Iran: Tehran\n        - Colombia: Bogotá\n        - Turkey: Ankara\n        - Armenia: Yerevan\n        - Cameroon: Yaoundé\n        - Nepal: Kathmandu\n        - Norway: Oslo\n        - Azerbaijan: Baku\n        - Germany: Berlin\n        - Afghanistan: Kabul\n        - UAE: Abu Dhabi\n        - Iraq: Baghdad\n        - Denmark: Copenhagen\n        - Jordan: Amman\n        - Gambia: Banjul\n\n2. **Simplify logical expressions systematically**:\n   - Start from the innermost parentheses. Use a counter to verify pairings—every opening parenthesis must have a matching closing parenthesis.\n   - Apply logical operators strictly in this order: \n        - `not` (highest precedence). Simplify multiple `not`s immediately: even number of `not`s cancel out; odd number reduce to one `not` (e.g., `not not X = X`, `not not not X = not X`).\n        - `and` \n        - `or` (lowest precedence)\n   - All operators are left-associative. For ambiguous expressions, explicitly group from left: e.g., `A and B or C` is `(A and B) or C`.\n   - Apply short-circuiting aggressively: \n        - If you see `False and ...`, immediately return False (ignore the rest).\n        - If you see `True or ...`, immediately return True (ignore the rest).\n\n3. **Evaluation steps for each expression**:\n   - Step 1: Replace all arithmetic comparisons and factual statements with True/False.\n   - Step 2: Simplify innermost parentheses first, replacing them with their boolean values.\n   - Step 3: Apply `not` operators: simplify multiple `not`s as above.\n   - Step 4: Apply `and`/`or` with short-circuiting.\n   - Step 5: If more than one expression seems True, re-check from Step 1—focus on arithmetic signs, fact errors, and parenthesis grouping.\n\n4. **Output format**:\n   - For each expression, state the result after simplification: \n        Example: \"A: False\" \n   - After all expressions, conclude with: \"Therefore, expression [X] is True.\"\n\n### Few-shot examples demonstrating common failures:\n[Example 1: Expression A from previous failure]\nIncorrect: Evaluated `True and False` as True due to misgrouping.\nCorrect: Always group left-associatively: `(True and False) = False`.\n\n[Example 2: Expression E from previous failure]\nIncorrect: Computed `-5*10 = 50` (sign error).\nCorrect: `-5*10 = -50`. Then `-50 > 9` is False.\n\n[Example 3: Expression B from previous failure]\nIncorrect: Used \"Putrajaya\" for Malaysia's capital.\nCorrect: Use fact list—Kuala Lumpur is correct.\n\n[Example 4: Expression D from previous failure]\nIncorrect: Missed short-circuiting: evaluated entire `False and ...` expression unnecessarily.\nCorrect: Short-circuit—once you see `False and ...`, return False immediately.\n\n[Example 5: Negation chain]\nIncorrect: `not not not not False` evaluated as False.\nCorrect: `not not not not False` = `not not (not not False)` = `not not True` = True.\n\n### Critical reminders:\n- Never trust your memory for facts—use only the provided fact list.\n- Negative numbers: `-5 - 3 = -8` (not -2).\n- Division: `-8/10 = -0.8` (negative divided by positive is negative).\n- Range calculation: `max(a,b,c,d) - min(a,b,c,d)` is always non-negative.\n- If parentheses are ambiguous, assume left-to-right grouping for `and`/`or`.\n- For extremely nested expressions, consider breaking them down into smaller sub-expressions and labeling them for clarity.\n\nNow evaluate the following expressions. Show your results for each expression (A-E), and conclude with the correct answer.",
                        "Q": 0.35,
                        "N": 0,
                        "uct_value": 0.0,
                        "reward": 0.35,
                        "children": []
                      },
                      {
                        "id": 8,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Precompute all arithmetic and factual statements first**:\n   - Evaluate arithmetic expressions with correct precedence: multiplication/division before addition/subtraction. Double-check negative numbers and division (e.g., `-8/10 = -0.8`).\n   - Evaluate factual statements using the definitive fact list below. Replace with True or False immediately.\n   - **Fact list** (use only these):\n        - Canada: Ottawa\n        - Malaysia: Kuala Lumpur\n        - Iran: Tehran\n        - Colombia: Bogotá\n        - Turkey: Ankara\n        - Armenia: Yerevan\n        - Cameroon: Yaoundé\n        - Nepal: Kathmandu\n        - Norway: Oslo\n        - Azerbaijan: Baku\n        - Germany: Berlin\n        - Afghanistan: Kabul\n        - UAE: Abu Dhabi\n        - Iraq: Baghdad\n        - Denmark: Copenhagen\n        - Jordan: Amman\n        - Gambia: Banjul\n\n2. **Simplify logical expressions systematically**:\n   - Start from the innermost parentheses. Use a counter to verify pairings—every opening parenthesis must have a matching closing parenthesis.\n   - Apply logical operators strictly in this order: \n        - `not` (highest precedence). Simplify multiple `not`s immediately: even number of `not`s cancel out; odd number reduce to one `not` (e.g., `not not X = X`, `not not not X = not X`).\n        - `and` \n        - `or` (lowest precedence)\n   - All operators are left-associative. For ambiguous expressions, explicitly group from left: e.g., `A and B or C` is `(A and B) or C`.\n   - Apply short-circuiting aggressively: \n        - If you see `False and ...`, immediately return False (ignore the rest).\n        - If you see `True or ...`, immediately return True (ignore the rest).\n\n3. **Evaluation steps for each expression**:\n   - Step 1: Replace all arithmetic comparisons and factual statements with True/False.\n   - Step 2: Simplify innermost parentheses first, replacing them with their boolean values.\n   - Step 3: Apply `not` operators: simplify multiple `not`s as above.\n   - Step 4: Apply `and`/`or` with short-circuiting.\n   - Step 5: If more than one expression seems True, re-check from Step 1—focus on arithmetic signs, fact errors, and parenthesis grouping.\n\n4. **Output format**:\n   - For each expression, state the result after simplification: \n        Example: \"A: False\" \n   - After all expressions, conclude with: \"Therefore, expression [X] is True.\"\n\n### Few-shot examples demonstrating common failures:\n[Example 1: Expression A from previous failure]\nIncorrect: Evaluated `True and False` as True due to misgrouping.\nCorrect: Always group left-associatively: `(True and False) = False`.\n\n[Example 2: Expression E from previous failure]\nIncorrect: Computed `-5*10 = 50` (sign error).\nCorrect: `-5*10 = -50`. Then `-50 > 9` is False.\n\n[Example 3: Expression B from previous failure]\nIncorrect: Used \"Putrajaya\" for Malaysia's capital.\nCorrect: Use fact list—Kuala Lumpur is correct.\n\n[Example 4: Expression D from previous failure]\nIncorrect: Missed short-circuiting: evaluated entire `False and ...` expression unnecessarily.\nCorrect: Short-circuit—once you see `False and ...`, return False immediately.\n\n[Example 5: Negation chain]\nIncorrect: `not not not not False` evaluated as False.\nCorrect: `not not not not False` = `not not (not not False)` = `not not True` = True.\n\n### Critical reminders:\n- Never trust your memory for facts—use only the provided fact list.\n- Negative numbers: `-5 - 3 = -8` (not -2).\n- Division: `-8/10 = -0.8` (negative divided by positive is negative).\n- Range calculation: `max(a,b,c,d) - min(a,b,c,d)` is always non-negative.\n- If parentheses are ambiguous, assume left-to-right grouping for `and`/`or`.\n- For extremely nested expressions, consider breaking them down into smaller sub-expressions and labeling them for clarity.\n\nNow evaluate the following expressions. Show your results for each expression (A-E), and conclude with the correct answer.",
                        "Q": 0.3,
                        "N": 0,
                        "uct_value": 0.0,
                        "reward": 0.3,
                        "children": []
                      },
                      {
                        "id": 9,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Precompute all arithmetic and factual statements first**:\n   - Evaluate arithmetic expressions with correct precedence: multiplication/division before addition/subtraction. Double-check negative numbers and division (e.g., `-8/10 = -0.8`).\n   - Evaluate factual statements using the definitive fact list below. Replace with True or False immediately.\n   - **Fact list** (use only these; exact spelling and accents matter):\n        - Canada: Ottawa\n        - Malaysia: Kuala Lumpur\n        - Iran: Tehran\n        - Colombia: Bogotá\n        - Turkey: Ankara\n        - Armenia: Yerevan\n        - Cameroon: Yaoundé\n        - Nepal: Kathmandu\n        - Norway: Oslo\n        - Azerbaijan: Baku\n        - Germany: Berlin\n        - Afghanistan: Kabul\n        - UAE: Abu Dhabi\n        - Iraq: Baghdad\n        - Denmark: Copenhagen\n        - Jordan: Amman\n        - Gambia: Banjul\n   - Any country not in this list is False. Any capital not matching exactly (including accents) is False.\n\n2. **Simplify logical expressions systematically**:\n   - Start from the innermost parentheses. Use a counter to verify pairings—every opening parenthesis must have a matching closing parenthesis.\n   - Apply logical operators strictly in this order: \n        - `not` (highest precedence). Simplify multiple `not`s immediately: even number of `not`s cancel out; odd number reduce to one `not` (e.g., `not not X = X`, `not not not X = not X`).\n        - `and` \n        - `or` (lowest precedence)\n   - All operators are left-associative. For ambiguous expressions, explicitly group from left: e.g., `A and B or C` is `(A and B) or C`.\n   - Apply short-circuiting aggressively: \n        - If you see `False and ...`, immediately return False (ignore the rest).\n        - If you see `True or ...`, immediately return True (ignore the rest).\n\n3. **Evaluation steps for each expression**:\n   - Step 1: Replace all arithmetic comparisons and factual statements with True/False.\n   - Step 2: Simplify innermost parentheses first, replacing them with their boolean values.\n   - Step 3: Apply `not` operators: simplify multiple `not`s as above.\n   - Step 4: Apply `and`/`or` with short-circuiting.\n   - Step 5: If more than one expression seems True, re-check from Step 1—focus on arithmetic signs, fact errors, and parenthesis grouping.\n\n4. **Output format**:\n   - For each expression, state the result after simplification: \n        Example: \"A: False\" \n   - After all expressions, conclude with: \"Therefore, expression [X] is True.\"\n\n### Few-shot examples demonstrating common failures:\n[Example 1: Expression A from previous failure]\nIncorrect: Evaluated `True and False` as True due to misgrouping.\nCorrect: Always group left-associatively: `(True and False) = False`.\n\n[Example 2: Expression E from previous failure]\nIncorrect: Computed `-5*10 = 50` (sign error).\nCorrect: `-5*10 = -50`. Then `-50 > 9` is False.\n\n[Example 3: Expression B from previous failure]\nIncorrect: Used \"Putrajaya\" for Malaysia's capital.\nCorrect: Use fact list—Kuala Lumpur is correct.\n\n[Example 4: Expression D from previous failure]\nIncorrect: Missed short-circuiting: evaluated entire `False and ...` expression unnecessarily.\nCorrect: Short-circuit—once you see `False and ...`, return False immediately.\n\n[Example 5: Negation chain]\nIncorrect: `not not not not False` evaluated as False.\nCorrect: `not not not not False` = `not not (not not False)` = `not not True` = True.\n\n[Example 6: Unlisted country]\nIncorrect: \"The capital of Nigeria is Abuja\" evaluated as True.\nCorrect: Nigeria not in fact list → False.\n\n[Example 7: Spelling variation]\nIncorrect: \"The capital of Colombia is Bogota\" evaluated as True.\nCorrect: \"Bogota\" ≠ \"Bogotá\" → False.\n\n### Critical reminders:\n- Never trust your memory for facts—use only the provided fact list.\n- Negative numbers: `-5 - 3 = -8` (not -2).\n- Division: `-8/10 = -0.8` (negative divided by positive is negative).\n- Range calculation: `max(a,b,c,d) - min(a,b,c,d)` is always non-negative.\n- If parentheses are ambiguous, assume left-to-right grouping for `and`/`or`.\n- For extremely nested expressions, break them into smaller sub-expressions and label them (e.g., S1, S2) for clarity.\n- After evaluating all expressions, if more than one seems True, re-check each step for errors in arithmetic, facts, or grouping.\n\nNow evaluate the following expressions. Show your results for each expression (A-E), and conclude with the correct answer.",
                        "Q": 0.45,
                        "N": 0,
                        "uct_value": 0.0,
                        "reward": 0.45,
                        "children": []
                      }
                    ]
                  }
                ]
              },
              {
                "id": 4,
                "depth": 3,
                "action_sequence": [
                  "FailureDrivenAction",
                  "FailureDrivenAction",
                  "FailureDrivenAction"
                ],
                "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Handle natural language statements**: Evaluate phrases like \"The capital of X is Y\" as True only if factually correct based on standard international knowledge (e.g., Nigeria's capital is Abuja; Malaysia's capital is Kuala Lumpur; Iran's capital is Tehran; Colombia's capital is Bogotá). If uncertain, use commonly accepted facts.\n2. **Interpret comparisons**: \"is less than or equal to\" means ≤, \"is greater than\" means >, etc.\n3. **Evaluate arithmetic**: Compute mathematical expressions with correct precedence (multiplication/division before addition/subtraction). Use exact fractions to avoid rounding errors.\n4. **Simplify step-by-step**:\n   - Start from the innermost parentheses. For expressions with deep nesting (>3 layers), use a systematic approach: number each parenthesis pair or use a stack mentally.\n   - Break complex expressions into smaller sub-expressions (label them P, Q, R, etc.) and evaluate each separately.\n   - Replace facts and arithmetic with True/False.\n   - Apply logical operators: `not` has highest precedence, then `and`, then `or`. `and` and `or` are left-associative.\n   - Simplify sequences of `not`: `not not X` = X, `not not not X` = `not X`, etc.\n5. **Short-circuit carefully**: Only short-circuit (`False and ...` → False, `True or ...` → True) after fully evaluating all nested parentheses in the current group.\n6. **Output format**:\n   - For each expression, evaluate in numbered steps. In each step, clearly state which sub-expression you're evaluating and its result.\n   - Use indentation to show nesting levels when helpful.\n   - After all expressions, if more than one seems True, systematically re-check each step for errors in arithmetic, facts, or grouping.\n7. **Final answer**: Conclude with \"Therefore, expression [X] is True.\"\n\n### Common pitfalls to avoid:\n- Miscounting parentheses: Always verify groupings, especially in expressions with 10+ layers of nesting.\n- Arithmetic sign errors: Pay special attention to negative numbers and division (e.g., `-8/10 = -0.8`).\n- Factual errors: Use consistent knowledge throughout all expressions.\n- Premature short-circuiting: Avoid short-circuiting before resolving all nested parentheses.\n- Misinterpreting operator precedence: `not` > `and` > `or`.\n\n### Few-shot examples for reference:\n[Example 1: Expression A from previous failure]\nIncorrect: Failed to account for the outermost `not` operator, leading to incorrect final evaluation.\nCorrect approach: Remember that the entire expression begins with `not(...)`. Even if the inner expression evaluates to True, the final result is False.\n\n[Example 2: Expression B from previous failure]\nIncorrect: Miscounted parentheses in deeply nested expression, causing incorrect grouping.\nCorrect approach: Use a systematic method to match parentheses - count opening and closing parentheses carefully, and consider writing down the expression with indices.\n\n[Example 3: Expression C from previous failure]\nIncorrect: Evaluated arithmetic incorrectly due to decimal rounding instead of using exact fractions.\nCorrect approach: Use exact fractions for division: `-7/3` remains `-7/3` rather than `-2.333`.\n\n[Example 4: Expression D from previous failure]\nIncorrect: Overlooked a factual error about a capital city due to complex nesting.\nCorrect approach: Even in deeply nested expressions, verify each factual statement independently before incorporating it into logical operations.\n\nNow evaluate the following expressions. Show your reasoning step-by-step for each expression, and conclude with which one (A-E) is True.",
                "Q": 0.7666666666666666,
                "N": 1,
                "uct_value": 0.7698382556838212,
                "reward": 0.3,
                "children": [
                  {
                    "id": 5,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Handle natural language statements**: Evaluate phrases like \"The capital of X is Y\" as True only if factually correct based on standard international knowledge. Use these unambiguous facts:\n   - Turkey's capital is Ankara (not Istanbul)\n   - Malaysia's capital is Kuala Lumpur (not Putrajaya)\n   - Germany's capital is Berlin\n   - India's capital is New Delhi\n   - UAE's capital is Abu Dhabi (not Dubai)\n   - Iraq's capital is Baghdad (not Beirut)\n   If uncertain, use this list for consistency.\n\n2. **Interpret comparisons**: \"is less than or equal to\" means ≤, \"is greater than\" means >, etc.\n\n3. **Evaluate arithmetic**:\n   - Use exact fractions only (no decimals). For example: -9/10 remains -9/10, not -0.9\n   - Precedence: multiplication/division before addition/subtraction\n   - Compute max(a,b,c,d) - min(a,b,c,d) as the range\n\n4. **Simplify step-by-step**:\n   - For expressions with >5 layers of nesting, you MUST use systematic parenthesis matching:\n     * Assign numbers to each parenthesis pair (e.g., mark opening/closing positions)\n     * Use a mental stack to track nesting levels\n   - Start from the innermost parentheses and work outward\n   - Break complex expressions into labeled sub-expressions (A1, A2, B1, B2, etc.)\n   - Replace facts and arithmetic with True/False\n   - Apply logical operators with precedence: `not` > `and` > `or`\n   - Simplify `not` sequences: `not not X` = X, `not not not X` = `not X`, etc.\n\n5. **Short-circuit carefully**:\n   - Only short-circuit (`False and ...` → False, `True or ...` → True) after fully evaluating ALL nested parentheses in the current sub-expression\n   - Do not short-circuit while inner parentheses remain unevaluated\n\n6. **Output format**:\n   - For each expression, evaluate in numbered steps\n   - Clearly label which sub-expression you're evaluating at each step\n   - Show intermediate results and substitutions\n   - Use indentation to show nesting levels\n   - After all expressions, if multiple seem True, prioritize re-checking:\n     * Expressions with deepest nesting (>8 layers)\n     * Expressions with complex arithmetic involving fractions\n     * Expressions where factual statements appear\n\n7. **Final verification**: Before concluding, verify that only one expression is True. If multiple appear True, systematically re-check each step for:\n   - Parenthesis mismatches\n   - Arithmetic errors (especially with fractions and negatives)\n   - Factual inconsistencies\n   - Premature short-circuiting\n\n### Critical Failure Examples to Avoid:\n[Example 1: Expression B from previous failure]\nIncorrect: Miscounted parentheses in 12-layer nested expression, causing incorrect grouping.\nCorrect approach: Use index-based parenthesis matching - write the expression with numbered pairs and evaluate from innermost to outermost.\n\n[Example 2: Expression C from previous failure]\nIncorrect: Used decimal approximation (2.9) instead of exact fraction (29/10), though it didn't affect outcome.\nCorrect approach: Always use exact fractions: 2 - (-9/10) = 2 + 9/10 = 29/10.\n\n[Example 3: Expression D from previous failure]\nIncorrect: Inconsistent factual evaluation - used \"Putrajaya is Malaysia's capital\" as False but later assumed it might be True.\nCorrect approach: Use the provided fact list consistently throughout all expressions.\n\n[Example 4: Expression E from previous failure]\nIncorrect: Premature short-circuiting in `False and ...` sub-expression before evaluating inner parentheses.\nCorrect approach: Even with `False and ...`, complete all inner parenthesis evaluation first.\n\n[Example 5: Expression A from previous failure]\nIncorrect: Misinterpreted operator precedence in complex `not` sequences.\nCorrect approach: Remember `not` has highest precedence: `not not not X` = `not (not (not X))`.\n\nNow evaluate the following expressions. Show your reasoning step-by-step for each expression, and conclude with which one (A-E) is True.",
                    "Q": 0.4,
                    "N": 0,
                    "uct_value": 0.0,
                    "reward": 0.4,
                    "children": [
                      {
                        "id": 6,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Handle natural language statements**: Evaluate phrases like \"The capital of X is Y\" as True only if factually correct based on this exact list:\n   - Turkey's capital is Ankara (not Istanbul)\n   - Malaysia's capital is Kuala Lumpur (not Putrajaya)\n   - Germany's capital is Berlin\n   - India's capital is New Delhi\n   - UAE's capital is Abu Dhabi (not Dubai)\n   - Iraq's capital is Baghdad (not Beirut)\n   - Colombia's capital is Bogotá (not Medellín)\n   - Denmark's capital is Copenhagen\n   - Gambia's capital is Banjul (not Libreville)\n   - Norway's capital is Oslo (not Bergen)\n   - Nigeria's capital is Abuja (not Lagos)\n   - Jordan's capital is Amman (not Beirut)\n   - Canada's capital is Ottawa (not Toronto)\n   - Cameroon's capital is Yaoundé (not Douala)\n   If a statement is not listed here, assume it is False.\n\n2. **Interpret comparisons**: \"is less than or equal to\" means ≤, \"is greater than\" means >, etc.\n\n3. **Evaluate arithmetic**:\n   - Use exact fractions only (no decimals). For example: -9/10 remains -9/10, not -0.9\n   - Precedence: multiplication/division before addition/subtraction\n   - Compute max(a,b,c,d) - min(a,b,c,d) as the range\n   - Show conversion steps: e.g., -5 - (-7/2) = -10/2 + 7/2 = -3/2\n\n4. **Simplify step-by-step**:\n   - For expressions with >3 layers of nesting, you MUST use systematic parenthesis matching:\n     * Assign numbers to each parenthesis pair (e.g., mark opening/closing positions: (1 ... )1)\n     * Create a table mapping each pair to its sub-expression\n     * Evaluate from the innermost numbered pair outward\n   - Break complex expressions into labeled sub-expressions (A1, A2, B1, B2, etc.)\n   - Replace facts and arithmetic with True/False\n   - Apply logical operators with precedence: `not` > `and` > `or`\n   - Simplify `not` sequences from right to left: `not not not X` = `not (not (not X))`\n\n5. **Short-circuit carefully**:\n   - Only short-circuit (`False and ...` → False, `True or ...` → True) after fully evaluating ALL nested parentheses in the current sub-expression\n   - Do not short-circuit while inner parentheses remain unevaluated\n\n6. **Output format**:\n   - For each expression, evaluate in numbered steps\n   - Clearly label which sub-expression you're evaluating at each step\n   - Show intermediate results and substitutions\n   - Use indentation to show nesting levels\n   - After all expressions, if multiple seem True, prioritize re-checking:\n     * Expressions with deepest nesting (>8 layers)\n     * Expressions with complex arithmetic involving fractions\n     * Expressions where factual statements appear\n\n7. **Final verification**: Before concluding, verify that only one expression is True. If multiple appear True, systematically re-check each step for:\n   - Parenthesis mismatches (use your numbering system)\n   - Arithmetic errors (especially with fractions and negatives)\n   - Factual inconsistencies with the provided list\n   - Premature short-circuiting\n\n### Critical Failure Examples to Avoid:\n[Example 1: Expression B from previous failure]\nIncorrect: Miscounted parentheses in 12-layer nested expression, causing incorrect grouping.\nCorrect approach: Use index-based parenthesis matching - write the expression with numbered pairs and evaluate from innermost to outermost.\n\n[Example 2: Expression C from previous failure]\nIncorrect: Used decimal approximation (2.9) instead of exact fraction (29/10), though it didn't affect outcome.\nCorrect approach: Always use exact fractions: 2 - (-9/10) = 2 + 9/10 = 20/10 + 9/10 = 29/10.\n\n[Example 3: Expression D from previous failure]\nIncorrect: Inconsistent factual evaluation - used \"Putrajaya is Malaysia's capital\" as False but later assumed it might be True.\nCorrect approach: Use the provided fact list consistently throughout all expressions.\n\n[Example 4: Expression E from previous failure]\nIncorrect: Premature short-circuiting in `False and ...` sub-expression before evaluating inner parentheses.\nCorrect approach: Even with `False and ...`, complete all inner parenthesis evaluation first.\n\n[Example 5: Expression A from previous failure]\nIncorrect: Misinterpreted operator precedence in complex `not` sequences.\nCorrect approach: Remember `not` has highest precedence and evaluates right to left: `not not not X` = `not (not (not X))`.\n\nNow evaluate the following expressions. Show your reasoning step-by-step for each expression, and conclude with which one (A-E) is True.",
                        "Q": 0.5,
                        "N": 0,
                        "uct_value": 0.0,
                        "reward": 0.5,
                        "children": []
                      },
                      {
                        "id": 7,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Factual consistency**: Evaluate all natural language statements using this definitive fact list:\n   - Turkey's capital is Ankara (not Istanbul)\n   - Malaysia's capital is Kuala Lumpur (not Putrajaya)\n   - Germany's capital is Berlin\n   - India's capital is New Delhi\n   - UAE's capital is Abu Dhabi (not Dubai)\n   - Iraq's capital is Baghdad (not Beirut)\n   - Denmark's capital is Copenhagen (not Aarhus)\n   - Afghanistan's capital is Kabul (not Kandahar)\n   - Canada's capital is Ottawa\n   - Colombia's capital is Bogotá (not Medellin)\n   - Gambia's capital is Banjul (not Libreville)\n   Refer to this list for every factual statement - do not rely on external knowledge.\n\n2. **Arithmetic precision**:\n   - Use exact fractions only (no decimals)\n   - Precedence: multiplication/division before addition/subtraction\n   - Compute max(a,b,c,d) - min(a,b,c,d) as the range\n   - Show all arithmetic steps with exact fractions\n\n3. **Parenthesis handling**:\n   - For expressions with >3 layers of nesting, use systematic parenthesis matching:\n     * Assign numbers to each parenthesis pair (e.g., mark opening/closing positions)\n     * Use a mental stack to track nesting levels\n   - Start from the innermost parentheses and work outward\n   - Break complex expressions into labeled sub-expressions (A1, A2, etc.)\n\n4. **Logical evaluation**:\n   - Precedence: `not` > `and` > `or`\n   - Simplify `not` sequences step-by-step:\n     * `not not X` = X\n     * `not not not X` = `not X`\n     * `not not not not X` = X\n   - Only short-circuit (`False and ...` → False, `True or ...` → True) after fully evaluating ALL nested parentheses in the current sub-expression\n\n5. **Step-by-step process**:\n   - For each expression, evaluate in numbered steps\n   - Clearly label which sub-expression you're evaluating at each step\n   - Show intermediate results and substitutions\n   - Use indentation to show nesting levels\n   - Verify each step before proceeding\n\n6. **Conflict resolution**:\n   - If multiple expressions appear True, re-check in this order:\n     * Expressions with deepest nesting (>8 layers)\n     * Expressions with complex arithmetic involving fractions\n     * Expressions with factual statements\n   - Systematically re-check each step for:\n     * Parenthesis mismatches\n     * Arithmetic errors (especially with fractions and negatives)\n     * Factual inconsistencies\n     * Premature short-circuiting\n\n### Critical Failure Examples to Avoid:\n[Example 1: Expression B from previous failure]\nIncorrect: Miscounted parentheses in 12-layer nested expression, causing incorrect grouping.\nCorrect approach: Use index-based parenthesis matching - write the expression with numbered pairs and evaluate from innermost to outermost.\n\n[Example 2: Expression C from previous failure]\nIncorrect: Used decimal approximation (2.9) instead of exact fraction (29/10), though it didn't affect outcome.\nCorrect approach: Always use exact fractions: 2 - (-9/10) = 2 + 9/10 = 29/10.\n\n[Example 3: Expression D from previous failure]\nIncorrect: Inconsistent factual evaluation - used \"Putrajaya is Malaysia's capital\" as False but later assumed it might be True.\nCorrect approach: Use the provided fact list consistently throughout all expressions.\n\n[Example 4: Expression E from previous failure]\nIncorrect: Premature short-circuiting in `False and ...` sub-expression before evaluating inner parentheses.\nCorrect approach: Even with `False and ...`, complete all inner parenthesis evaluation first.\n\n[Example 5: Expression A from previous failure]\nIncorrect: Misinterpreted operator precedence in complex `not` sequences.\nCorrect approach: Remember `not` has highest precedence: `not not not X` = `not (not (not X))`.\n\n[Example 6: Recent evaluation failure]\nIncorrect: Multiple expressions (B and D) appeared True due to incomplete verification.\nCorrect approach: When multiple expressions seem True, re-check arithmetic and factual statements first, then parenthesis grouping.\n\n### Output Requirements:\n- For each expression, use heading: \"## Expression X\"\n- Show step-by-step evaluation with numbered steps\n- Use sub-bullets for nested evaluations\n- Conclude each expression with \"✅ True\" or \"❌ False\"\n- Final answer: \"Therefore, expression [X] is True.\"\n\nNow evaluate the following expressions. Show your reasoning step-by-step for each expression, and conclude with which one (A-E) is True.",
                        "Q": 0.4,
                        "N": 0,
                        "uct_value": 0.0,
                        "reward": 0.4,
                        "children": []
                      },
                      {
                        "id": 8,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Factual Consistency**: Use these unambiguous facts for all natural language statements:\n   - Turkey's capital is Ankara (not Istanbul)\n   - Malaysia's capital is Kuala Lumpur (not Putrajaya)\n   - Germany's capital is Berlin\n   - India's capital is New Delhi\n   - UAE's capital is Abu Dhabi (not Dubai)\n   - Iraq's capital is Baghdad (not Beirut)\n   - Denmark's capital is Copenhagen\n   - Iran's capital is Tehran\n   - Belarus's capital is Minsk (not Grodno)\n   - Nepal's capital is Kathmandu (not Pokhara)\n   - Norway's capital is Oslo (not Bergen)\n   - Jordan's capital is Amman (not Beirut)\n   - Afghanistan's capital is Kabul (not Kandahar)\n   - Canada's capital is Ottawa (not Toronto)\n   - Colombia's capital is Bogotá (not Medellin)\n   - Gambia's capital is Banjul (not Libreville)\n   Any other \"capital of X is Y\" statement is False.\n\n2. **Arithmetic Precision**:\n   - Use exact fractions only (no decimals)\n   - Precedence: multiplication/division before addition/subtraction\n   - Compute max(a,b,c,d) - min(a,b,c,d) as the range\n   - Show fraction steps: e.g., 5 - (-2/-9) = 5 - 2/9 = 45/9 - 2/9 = 43/9\n\n3. **Parenthesis Management**:\n   - Before evaluation, mentally assign indices to all parentheses: (0 (1 ... )1 ... )0\n   - Always evaluate from the innermost indexed pair outward\n   - For expressions with >5 nesting layers, write the expression with indices\n\n4. **Step-by-Step Evaluation**:\n   - Break complex expressions into labeled sub-expressions (A1, A2, B1, B2, etc.)\n   - Start from the innermost parentheses and work outward\n   - Replace facts and arithmetic with True/False\n   - Apply logical operators with strict precedence: `not` > `and` > `or`\n   - Simplify `not` sequences step-by-step: `not not X` = X, `not not not X` = `not X`, etc.\n\n5. **Short-Circuiting Protocol**:\n   - Only short-circuit (`False and ...` → False, `True or ...` → True) after ALL nested parentheses in the current sub-expression are fully evaluated\n   - Do not short-circuit while inner parentheses remain unevaluated\n\n6. **Output Format**:\n   - For each expression, evaluate in numbered steps with clear sub-expression labels\n   - Show intermediate results and substitutions\n   - Use indentation to show nesting levels\n   - After all expressions, create a summary table:\n     | Expression | Result |\n     |------------|--------|\n     | A          | True/False |\n     | ...        | ...    |\n\n7. **Verification Protocol**: If multiple expressions seem True, re-check in this order:\n   - Expressions with deepest nesting (>8 layers)\n   - Expressions with complex arithmetic involving fractions\n   - Expressions where factual statements appear\n   Re-evaluate the innermost parentheses first and verify arithmetic with exact fractions\n\n### Critical Failure Examples to Avoid:\n[Example 1: Expression B from previous failure]\nIncorrect: Miscounted parentheses in 12-layer nested expression, causing incorrect grouping.\nCorrect approach: Use index-based parenthesis matching - write the expression with numbered pairs and evaluate from innermost to outermost.\n\n[Example 2: Expression C from previous failure]\nIncorrect: Used decimal approximation (2.9) instead of exact fraction (29/10), though it didn't affect outcome.\nCorrect approach: Always use exact fractions: 2 - (-9/10) = 2 + 9/10 = 29/10.\n\n[Example 3: Expression D from previous failure]\nIncorrect: Inconsistent factual evaluation - used \"Putrajaya is Malaysia's capital\" as False but later assumed it might be True.\nCorrect approach: Use the provided fact list consistently throughout all expressions.\n\n[Example 4: Expression E from previous failure]\nIncorrect: Premature short-circuiting in `False and ...` sub-expression before evaluating inner parentheses.\nCorrect approach: Even with `False and ...`, complete all inner parenthesis evaluation first.\n\n[Example 5: Expression A from previous failure]\nIncorrect: Misinterpreted operator precedence in complex `not` sequences.\nCorrect approach: Remember `not` has highest precedence: `not not not X` = `not (not (not X))`.\n\nNow evaluate the following expressions. Show your reasoning step-by-step for each expression, and conclude with which one (A-E) is True.",
                        "Q": 0.35,
                        "N": 0,
                        "uct_value": 0.0,
                        "reward": 0.35,
                        "children": []
                      }
                    ]
                  },
                  {
                    "id": 6,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Handle natural language statements**: Evaluate phrases like \"The capital of X is Y\" as True only if factually correct based on standard international knowledge (e.g., Nigeria's capital is Abuja; Malaysia's capital is Kuala Lumpur; Iran's capital is Tehran; Colombia's capital is Bogotá; Turkey's capital is Ankara; Denmark's capital is Copenhagen; Afghanistan's capital is Kabul; Norway's capital is Oslo; Canada's capital is Ottawa). If uncertain, use commonly accepted facts. Before evaluating, extract all factual statements and verify each one consistently.\n\n2. **Interpret comparisons**: \"is less than or equal to\" means ≤, \"is greater than\" means >, etc.\n\n3. **Evaluate arithmetic**: Compute mathematical expressions with correct precedence (multiplication/division before addition/subtraction). Use exact fractions to avoid rounding errors (e.g., keep 10/9 as 10/9, not 1.111). Double-check negative numbers and division.\n\n4. **Simplify step-by-step**:\n   - Start from the innermost parentheses. For expressions with deep nesting (>3 layers), use a systematic approach: number each parenthesis pair or use a stack mentally.\n   - Break complex expressions into smaller sub-expressions (label them P, Q, R, etc.) and evaluate each separately.\n   - Replace facts and arithmetic with True/False.\n   - Apply logical operators: `not` has highest precedence, then `and`, then `or`. `and` and `or` are left-associative.\n   - For chains of `not` operators: count the number of `not`s. If even, `not not ... X = X`; if odd, `not not ... X = not X`.\n\n5. **Short-circuit carefully**: Only short-circuit (`False and ...` → False, `True or ...` → True) after fully evaluating all nested parentheses in the current group. Avoid premature short-circuiting.\n\n6. **Output format**:\n   - For each expression, evaluate in numbered steps. In each step, clearly state which sub-expression you're evaluating and its result.\n   - Use indentation to show nesting levels when helpful.\n   - After all expressions, if more than one seems True, systematically re-check each step for errors in arithmetic, facts, or grouping.\n\n7. **Final answer**: Conclude with \"Therefore, expression [X] is True.\"\n\n### Common pitfalls to avoid:\n- Miscounting parentheses: Always verify groupings, especially in expressions with 10+ layers of nesting. Use parenthesis matching with indices if needed.\n- Arithmetic sign errors: Pay special attention to negative numbers and division (e.g., `-8/10 = -0.8`).\n- Factual errors: Use consistent knowledge throughout all expressions.\n- Premature short-circuiting: Avoid short-circuiting before resolving all nested parentheses.\n- Misinterpreting operator precedence: `not` > `and` > `or`.\n- Miscounting `not` chains: Carefully count the number of consecutive `not` operators.\n\n### Few-shot examples for reference:\n[Example 1: Expression A from previous failure]\nIncorrect: Failed to account for the outermost `not` operator, leading to incorrect final evaluation.\nCorrect approach: Remember that the entire expression begins with `not(...)`. Even if the inner expression evaluates to True, the final result is False.\n\n[Example 2: Expression B from previous failure]\nIncorrect: Miscounted parentheses in deeply nested expression, causing incorrect grouping.\nCorrect approach: Use a systematic method to match parentheses - count opening and closing parentheses carefully, and consider writing down the expression with indices.\n\n[Example 3: Expression C from previous failure]\nIncorrect: Evaluated arithmetic incorrectly due to decimal rounding instead of using exact fractions.\nCorrect approach: Use exact fractions for division: `-7/3` remains `-7/3` rather than `-2.333`.\n\n[Example 4: Expression D from previous failure]\nIncorrect: Overlooked a factual error about a capital city due to complex nesting.\nCorrect approach: Even in deeply nested expressions, verify each factual statement independently before incorporating it into logical operations.\n\n[Example 5: Expression E from previous failure]\nIncorrect: Miscounted the number of `not` operators in a long chain, leading to incorrect simplification.\nCorrect approach: For chains of `not` operators, count carefully: `not not not not X` = X (even number), `not not not X` = not X (odd number).\n\nNow evaluate the following expressions. Show your reasoning step-by-step for each expression, and conclude with which one (A-E) is True.",
                    "Q": 0.3,
                    "N": 0,
                    "uct_value": 0.0,
                    "reward": 0.3,
                    "children": []
                  },
                  {
                    "id": 7,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Factual Knowledge Base**: Use these capital cities:\n   - Nigeria: Abuja\n   - Malaysia: Kuala Lumpur\n   - Iran: Tehran\n   - Colombia: Bogotá\n   - Turkey: Ankara\n   - Denmark: Copenhagen\n   - Afghanistan: Kabul\n   - Germany: Berlin\n   - Norway: Oslo\n   - India: New Delhi\n   - Canada: Ottawa\n   - Belarus: Minsk\n   - Azerbaijan: Baku\n   - Jordan: Amman\n   - Cameroon: Yaoundé\n   - Iraq: Baghdad\n   - Gambia: Banjul\n   - All other capitals: Use standard international knowledge.\n\n2. **Arithmetic Evaluation**:\n   - Use exact fractions (e.g., -7/3, not -2.333)\n   - Precedence: Multiplication/division before addition/subtraction\n   - Compute max/min immediately: Replace `max(a,b,c,d) - min(a,b,c,d)` with its numerical value\n\n3. **Systematic Evaluation Method**:\n   - For each expression, create a evaluation table with columns: [Level, Label, Sub-Expression, Value]\n   - Start from innermost parentheses (Level 1)\n   - Assign labels (P1, P2, ...) to all sub-expressions\n   - For nesting >3 layers, use stack tracing: Push '(' and assign new level, pop ')' and reduce level\n   - Never short-circuit until current parenthesis group is fully evaluated\n\n4. **Logical Operator Precedence**:\n   - Highest: `not` (right-associative)\n   - Then: `and` (left-associative)\n   - Then: `or` (left-associative)\n   - Simplify `not` sequences: \n     - `not not X` = X\n     - `not not not X` = `not X`\n     - etc.\n\n5. **Step-by-Step Process**:\n   - Evaluate all factual statements first (replace with True/False)\n   - Evaluate all arithmetic expressions (replace with numerical values)\n   - Evaluate comparisons (replace with True/False)\n   - Apply logical operators in precedence order\n   - Maintain the evaluation table throughout\n\n6. **Verification**:\n   - If multiple expressions appear True, re-check all steps\n   - Pay special attention to:\n     - Parenthesis matching (count opening/closing)\n     - Negative number arithmetic\n     - Factual consistency\n     - Operator precedence\n\n### Common Pitfalls and Solutions:\n[Example 1: Parenthesis Mismatch]\nIncorrect: In Expression A, miscounted parentheses in `not not not (not (not ...))`\nSolution: Use stack approach - for each opening '(', push and increment level; for closing ')', pop and decrement\n\n[Example 2: Decimal Approximation]\nIncorrect: Used -2.333 instead of -7/3 in arithmetic comparison\nSolution: Always use exact fractions - e.g., -7/3 remains -7/3\n\n[Example 3: Premature Short-Circuiting]\nIncorrect: Evaluated `False and (complex expression)` as False without evaluating nested parentheses\nSolution: Complete all nested evaluations within current parentheses before applying short-circuiting\n\n[Example 4: Operator Precedence Error]\nIncorrect: Evaluated `not A and B or C` as `not (A and B) or C`\nSolution: Apply operators in correct order: `((not A) and B) or C`\n\n[Example 5: Factual Inconsistency]\nIncorrect: Called Istanbul capital of Turkey in one expression but Ankara in another\nSolution: Use consistent factual knowledge throughout all expressions\n\n### Output Format:\nFor each expression:\n1. Create evaluation table showing all steps\n2. List final truth value\n3. If uncertain, re-check with detailed tracing\n\nAfter all expressions:\n- Compare results\n- If exactly one True, output \"Therefore, expression [X] is True.\"\n- If multiple True, systematically re-check each expression\n- If none True, re-check all evaluations\n\nNow evaluate the following expressions using this systematic approach. Show complete evaluation tables for each expression.",
                    "Q": 0.3,
                    "N": 0,
                    "uct_value": 0.0,
                    "reward": 0.3,
                    "children": []
                  }
                ]
              },
              {
                "id": 5,
                "depth": 3,
                "action_sequence": [
                  "FailureDrivenAction",
                  "FailureDrivenAction",
                  "FailureDrivenAction"
                ],
                "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Factual knowledge reference**: Use these standard capital cities:\n   - Cameroon: Yaoundé (not Douala)\n   - Denmark: Copenhagen (not Aarhus)\n   - Norway: Oslo\n   - Jordan: Amman\n   - Nigeria: Abuja\n   - Germany: Berlin\n   - Belarus: Minsk\n   - UAE: Abu Dhabi (not Dubai)\n   - Armenia: Yerevan (not Gyumri)\n   - Gambia: Banjul (not Libreville)\n   All other capital statements must be verified against reliable geographical knowledge.\n\n2. **Arithmetic evaluation**:\n   - Perform operations with correct precedence: multiplication/division before addition/subtraction\n   - Handle negative numbers carefully: e.g., -2/-7 = 2/7 ≈ 0.2857\n   - Use exact fractions when possible to avoid floating-point errors\n   - Comparisons: \"is less than or equal to\" means ≤, \"is greater than\" means >\n\n3. **Parentheses handling**:\n   - Use a numbered bracket system: label innermost parentheses as [L1], then [L2], etc.\n   - Always process the deepest nesting level first\n   - Maintain a mental stack to match opening and closing parentheses\n\n4. **Logical operator precedence**:\n   - Highest: `not` (right-associative)\n   - Then: `and` (left-associative)\n   - Then: `or` (left-associative)\n   - Simplify `not` sequences: \n     - `not not X` = X\n     - `not not not X` = `not X`\n     - etc.\n\n5. **Strict short-circuiting**:\n   - If you encounter `False and ...`, immediately evaluate to False\n   - If you encounter `True or ...`, immediately evaluate to True\n   - Do not compute unnecessary subexpressions\n\n6. **Step-by-step evaluation**:\n   - For each expression, begin by identifying all parentheses levels\n   - Evaluate innermost components first (facts, arithmetic, comparisons)\n   - Replace evaluated parts with their Boolean values\n   - Apply logical operators in correct order\n   - Show each simplification step clearly\n\n7. **Verification**:\n   - After all expressions, if more than one seems True, re-check each step\n   - Pay special attention to:\n     - Parentheses grouping\n     - Negative number arithmetic\n     - Capital city facts\n     - Operator precedence\n\n### Few-shot examples with common failures:\n\n[Example 1: Expression A from previous failure]\nIncorrect: Evaluated `True and False` as True due to misgrouping\nCorrect: `(True and False)` must evaluate to False regardless of surrounding context\n\n[Example 2: Expression E from previous failure]\nIncorrect: Misparsed final `and` operation due to complex nesting\nCorrect: Compute arithmetic first: `-5*10 = -50 > 9` is False, then apply logical operators step by step\n\n[Example 3: Expression B from previous failure]\nIncorrect: Used Putrajaya instead of Kuala Lumpur for Malaysia's capital\nCorrect: Use standard knowledge—Kuala Lumpur is the capital of Malaysia\n\n[Example 4: Expression D from recent failure]\nIncorrect: Miscounted parentheses in deep nesting of `not` operators\nCorrect: `not not not False` = `not not True` = `not False` = True\n\n### Output format:\n- For each expression:\n  - Show parentheses levels with labels [L1], [L2], etc.\n  - Display each simplification step with current expression\n  - Indicate short-circuiting when applicable\n- After all expressions, provide final conclusion: \"Therefore, expression [X] is True.\"\n\n### Common pitfalls to avoid:\n- Miscounting parentheses in expressions with 5+ nesting levels\n- Arithmetic sign errors with negative numbers\n- Factual errors about capital cities\n- Forgetting to short-circuit when possible\n- Misapplying operator precedence (`not` > `and` > `or`)\n- Not simplifying sequences of `not` operators\n\nNow evaluate the following expressions. Show your reasoning step-by-step for each expression, and conclude with which one (A-E) is True.\n\n[The five expressions to be evaluated]",
                "Q": 1.2833333333333334,
                "N": 2,
                "uct_value": 0.836504922350488,
                "reward": 0.4,
                "children": [
                  {
                    "id": 6,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Factual knowledge reference**: Use these standard capital cities:\n   - Cameroon: Yaoundé (not Douala)\n   - Denmark: Copenhagen (not Aarhus)\n   - Norway: Oslo\n   - Jordan: Amman\n   - Nigeria: Abuja\n   - Germany: Berlin\n   - Belarus: Minsk\n   - UAE: Abu Dhabi (not Dubai)\n   - Armenia: Yerevan (not Gyumri)\n   - Gambia: Banjul (not Libreville)\n   All other capital statements must be verified against reliable geographical knowledge (e.g., Nepal: Kathmandu; Afghanistan: Kabul; Iran: Tehran; Colombia: Bogotá; Canada: Ottawa).\n\n2. **Arithmetic evaluation**:\n   - Perform operations with correct precedence: multiplication/division before addition/subtraction\n   - Handle negative numbers carefully: e.g., -2/-7 = 2/7 ≈ 0.2857\n   - Use exact fractions when possible to avoid floating-point errors\n   - Comparisons: \"is less than or equal to\" means ≤, \"is greater than\" means >\n\n3. **Parentheses handling**:\n   - Use a numbered bracket system: label innermost parentheses as [L1], then [L2], etc.\n   - Always process the deepest nesting level first\n   - Maintain a mental stack to match opening and closing parentheses\n   - For expressions with 5+ nesting levels, double-check grouping before proceeding\n\n4. **Logical operator precedence**:\n   - Highest: `not` (right-associative)\n   - Then: `and` (left-associative)\n   - Then: `or` (left-associative)\n   - Simplify `not` sequences: \n     - Even number of `not`s: `not not X` = X\n     - Odd number of `not`s: `not not not X` = `not X`\n\n5. **Strict short-circuiting**:\n   - If you encounter `False and ...`, immediately evaluate to False\n   - If you encounter `True or ...`, immediately evaluate to True\n   - Do not compute unnecessary subexpressions\n\n6. **Step-by-step evaluation**:\n   - For each expression, begin by identifying all parentheses levels\n   - Evaluate innermost components first (facts, arithmetic, comparisons)\n   - Replace evaluated parts with their Boolean values\n   - Apply logical operators in correct order\n   - Show each simplification step clearly but concisely\n\n7. **Verification**:\n   - After all expressions, if more than one seems True, re-check each step\n   - Pay special attention to:\n     - Parentheses grouping in expressions with deep nesting\n     - Negative number arithmetic and division\n     - Capital city facts\n     - Operator precedence\n     - Short-circuiting opportunities\n\n### Few-shot examples with common failures:\n\n[Example 1: Expression A from previous failure]\nIncorrect: Evaluated `True and False` as True due to misgrouping\nCorrect: `(True and False)` must evaluate to False regardless of surrounding context\n\n[Example 2: Expression E from previous failure]\nIncorrect: Misparsed final `and` operation due to complex nesting\nCorrect: Compute arithmetic first: `-5*10 = -50 > 9` is False, then apply logical operators step by step\n\n[Example 3: Expression B from previous failure]\nIncorrect: Used Putrajaya instead of Kuala Lumpur for Malaysia's capital\nCorrect: Use standard knowledge—Kuala Lumpur is the capital of Malaysia\n\n[Example 4: Expression D from recent failure]\nIncorrect: Miscounted parentheses in deep nesting of `not` operators\nCorrect: `not not not False` = `not not True` = `not False` = True\n\n[Example 5: Expression A from arithmetic error]\nIncorrect: Evaluated `6 - (-7/-4)` as `6 - (-1.75)` instead of `6 - 1.75`\nCorrect: `-7/-4 = 1.75`, so `6 - 1.75 = 4.25`\n\n### Output format:\n- For each expression:\n  - Show parentheses levels with labels [L1], [L2], etc.\n  - Display each simplification step with current expression\n  - Indicate short-circuiting when applicable\n- After all expressions, provide final conclusion: \"Therefore, expression [X] is True.\"\n\n### Critical reminders:\n- Count parentheses carefully—use a stack approach for deep nesting\n- Verify capital cities against the provided list\n- Double-check arithmetic with negative numbers\n- Apply short-circuiting immediately when possible\n- Simplify `not` chains before other operations\n- If multiple expressions appear True, re-check the most complex ones first\n\nNow evaluate the following expressions. Show your reasoning step-by-step for each expression, and conclude with which one (A-E) is True.\n\n[The five expressions to be evaluated]",
                    "Q": 0.8500000000000001,
                    "N": 1,
                    "uct_value": 0.002081386527894244,
                    "reward": 0.4,
                    "children": [
                      {
                        "id": 7,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Factual knowledge reference**: Use these standard capital cities:\n   - Cameroon: Yaoundé (not Douala)\n   - Denmark: Copenhagen (not Aarhus)\n   - Norway: Oslo\n   - Jordan: Amman\n   - Nigeria: Abuja\n   - Germany: Berlin\n   - Belarus: Minsk\n   - UAE: Abu Dhabi (not Dubai)\n   - Armenia: Yerevan (not Gyumri)\n   - Gambia: Banjul (not Libreville)\n   - Turkey: Ankara (not Istanbul)\n   - Canada: Ottawa (not Toronto)\n   - Afghanistan: Kabul (not Kandahar)\n   - Colombia: Bogotá (not Medellín)\n   - Iraq: Baghdad (not Beirut)\n   All other capital statements must be verified against reliable geographical knowledge.\n\n2. **Arithmetic evaluation**:\n   - Perform operations with correct precedence: multiplication/division before addition/subtraction\n   - Handle negative numbers carefully: e.g., -2/-7 = 2/7 ≈ 0.2857\n   - Use exact fractions when possible to avoid floating-point errors\n   - Comparisons: \"is less than or equal to\" means ≤, \"is greater than\" means >\n\n3. **Parentheses handling**:\n   - Use a numbered bracket system: label innermost parentheses as [L1], then [L2], etc.\n   - Always process the deepest nesting level first\n   - Maintain a mental stack to match opening and closing parentheses\n   - For expressions with 5+ nesting levels, double-check grouping before proceeding\n\n4. **Logical operator precedence**:\n   - Highest: `not` (right-associative)\n   - Then: `and` (left-associative)\n   - Then: `or` (left-associative)\n   - Simplify `not` sequences before other operations:\n     - Even number of `not`s: `not not X` = X\n     - Odd number of `not`s: `not not not X` = `not X`\n\n5. **Strict short-circuiting**:\n   - If you encounter `False and ...`, immediately evaluate to False without computing the rest\n   - If you encounter `True or ...`, immediately evaluate to True without computing the rest\n   - Apply short-circuiting even in deeply nested subexpressions\n\n6. **Step-by-step evaluation**:\n   - For each expression, begin by identifying all parentheses levels with [L1], [L2], etc.\n   - Extract and verify all capital city statements first\n   - Evaluate innermost components first (facts, arithmetic, comparisons)\n   - Replace evaluated parts with their Boolean values\n   - Apply logical operators in correct order\n   - Show each simplification step clearly but concisely\n\n7. **Verification**:\n   - After all expressions, if more than one seems True, re-check in reverse order (E to A)\n   - Pay special attention to:\n     - Parentheses grouping in expressions with deep nesting\n     - Negative number arithmetic and division\n     - Capital city facts\n     - Operator precedence\n     - Short-circuiting opportunities\n\n### Critical reminders:\n- Count parentheses carefully—use explicit stack notation for deep nesting\n- Verify ALL capital cities against the provided list before evaluation\n- Double-check arithmetic with negative numbers\n- Apply short-circuiting immediately when possible\n- Simplify `not` chains before other operations\n- If multiple expressions appear True, re-check the most complex ones first\n\n### Few-shot examples with common failures:\n\n[Example 1: Deep nesting error]\nExpression: not not (not (not not (not not not ((True and False) or False)))\nIncorrect: Evaluated as True due to miscounted parentheses\nCorrect: Process [L1]: (True and False) = False → [L2]: (False or False) = False → [L3]: not not not False = not not True = not False = True → Continue step-by-step\n\n[Example 2: Short-circuiting missed]\nExpression: (False and (complex expression)) or True\nIncorrect: Computed complex expression unnecessarily\nCorrect: Short-circuit: False and ... = False → False or True = True\n\n[Example 3: Capital city error]\nExpression: (The capital of Canada is Toronto.) and (True)\nIncorrect: Evaluated as True\nCorrect: Toronto is not capital → False → False and True = False\n\n[Example 4: Not chain simplification]\nExpression: not not not not True and False\nIncorrect: Evaluated as not not not not True = True, then True and False = False\nCorrect: Simplify not chain first: not not not not True = True → True and False = False\n\n[Example 5: Arithmetic sign error]\nExpression: -3 - (-5/3) ≤ -5\nIncorrect: Evaluated as -3 - (-1.67) = -1.33 ≤ -5 → False\nCorrect: -5/3 ≈ -1.67 → -3 - (-1.67) = -3 + 1.67 = -1.33 ≤ -5 → False\n\n### Output format:\n- For each expression:\n  - List all capital city statements with True/False verification\n  - Show parentheses levels with labels [L1], [L2], etc.\n  - Display each simplification step with current expression\n  - Indicate short-circuiting when applicable\n- After all expressions, provide final conclusion: \"Therefore, expression [X] is True.\"\n\nNow evaluate the following expressions. Show your reasoning step-by-step for each expression, and conclude with which one (A-E) is True.\n\n[The five expressions to be evaluated]",
                        "Q": 0.9,
                        "N": 1,
                        "uct_value": 0.0,
                        "reward": 0.45,
                        "children": []
                      },
                      {
                        "id": 8,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Factual knowledge reference**: Use these standard capital cities:\n   - Cameroon: Yaoundé (not Douala)\n   - Denmark: Copenhagen (not Aarhus)\n   - Norway: Oslo (not Bergen)\n   - Jordan: Amman\n   - Nigeria: Abuja (not Lagos)\n   - Germany: Berlin\n   - Belarus: Minsk (not Grodno)\n   - UAE: Abu Dhabi (not Dubai)\n   - Armenia: Yerevan (not Gyumri)\n   - Gambia: Banjul (not Libreville)\n   - India: New Delhi (not Mumbai)\n   - Turkey: Ankara\n   - Afghanistan: Kabul\n   - Canada: Ottawa\n   - Malaysia: Kuala Lumpur\n   - Iraq: Baghdad\n   - Nepal: Kathmandu (not Pokhara)\n   - Azerbaijan: Baku\n   All other capital statements must be verified against reliable geographical knowledge.\n\n2. **Arithmetic evaluation**:\n   - Perform operations with correct precedence: multiplication/division before addition/subtraction\n   - Handle negative numbers carefully: e.g., -2/-7 = 2/7 ≈ 0.2857\n   - Use exact fractions when possible to avoid floating-point errors\n   - Comparisons: \"is less than or equal to\" means ≤, \"is greater than\" means >\n   - For max/min operations: max(a,b,c,d) returns the largest value, min(a,b,c,d) returns the smallest\n\n3. **Parentheses handling**:\n   - Use a numbered bracket system: label innermost parentheses as [L1], then [L2], etc.\n   - Always process the deepest nesting level first\n   - Maintain a mental stack to match opening and closing parentheses\n   - For expressions with 5+ nesting levels, double-check grouping before proceeding\n\n4. **Logical operator precedence**:\n   - Highest: `not` (right-associative)\n   - Then: `and` (left-associative)\n   - Then: `or` (left-associative)\n   - Simplify `not` sequences using: \n     - Even number of `not`s: `not not X` = X\n     - Odd number of `not`s: `not not not X` = `not X`\n\n5. **Strict short-circuiting**:\n   - If you encounter `False and ...`, immediately evaluate to False and note \"Short-circuited\"\n   - If you encounter `True or ...`, immediately evaluate to True and note \"Short-circuited\"\n   - Do not compute unnecessary subexpressions\n\n6. **Step-by-step evaluation**:\n   - For each expression, begin by identifying all parentheses levels with explicit labels [L1], [L2], etc.\n   - Evaluate innermost components first (facts, arithmetic, comparisons)\n   - Replace evaluated parts with their Boolean values\n   - Apply logical operators in correct order\n   - Show each simplification step clearly but concisely\n   - For expressions with deep nesting, focus on critical steps rather than every minor operation\n\n7. **Verification protocol**:\n   - After evaluating all expressions, if more than one appears True:\n     - Re-check the most complex expressions first (deepest nesting, most operations)\n     - Prioritize verification of capital city facts and negative number arithmetic\n     - Double-check parentheses grouping in expressions with 5+ nesting levels\n   - If you find a True expression early, still evaluate all others but double-check the True one thoroughly\n\n### Critical failure examples to avoid:\n\n[Example 1: Expression A from previous failure]\nIncorrect: Evaluated `True and False` as True due to misgrouping\nCorrect: `(True and False)` must evaluate to False regardless of surrounding context\n\n[Example 2: Expression E from previous failure]\nIncorrect: Misparsed final `and` operation due to complex nesting\nCorrect: Compute arithmetic first: `-5*10 = -50 > 9` is False, then apply logical operators step by step\n\n[Example 3: Expression B from previous failure]\nIncorrect: Used incorrect capital for Malaysia (Putrajaya instead of Kuala Lumpur)\nCorrect: Use standard knowledge—Kuala Lumpur is the capital of Malaysia\n\n[Example 4: Expression D from recent failure]\nIncorrect: Miscounted parentheses in deep nesting of `not` operators\nCorrect: `not not not False` = `not not True` = `not False` = True\n\n[Example 5: Expression evaluation error]\nIncorrect: Multiple expressions appeared True due to propagation of early errors\nCorrect: When multiple seem True, re-check from the beginning with focus on arithmetic and facts\n\n### Output format:\n- For each expression:\n  - Show parentheses levels with explicit labels [L1], [L2], etc.\n  - Display each simplification step with current expression state\n  - Indicate short-circuiting when applicable with \"Short-circuited to False/True\"\n- After all expressions, provide final conclusion: \"Therefore, expression [X] is True.\"\n\n### Critical reminders:\n- Count parentheses carefully—use the labeling system consistently\n- Verify capital cities against the provided list\n- Double-check arithmetic with negative numbers and division\n- Apply short-circuiting immediately when possible\n- Simplify `not` chains before other operations\n- If multiple expressions appear True, re-check the most complex ones first\n- Remember: Only one expression can be True—if you find multiple, you made an error\n\nNow evaluate the following expressions. Show your reasoning step-by-step for each expression, and conclude with which one (A-E) is True.\n\n[The five expressions to be evaluated]",
                        "Q": 0.35,
                        "N": 0,
                        "uct_value": 0.0,
                        "reward": 0.35,
                        "children": []
                      },
                      {
                        "id": 9,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Factual knowledge reference**: Use these standard capital cities:\n   - Cameroon: Yaoundé (not Douala)\n   - Denmark: Copenhagen (not Aarhus)\n   - Norway: Oslo\n   - Jordan: Amman\n   - Nigeria: Abuja\n   - Germany: Berlin\n   - Belarus: Minsk\n   - UAE: Abu Dhabi (not Dubai)\n   - Armenia: Yerevan (not Gyumri)\n   - Gambia: Banjul (not Libreville)\n   - India: New Delhi (not Mumbai)\n   - Malaysia: Kuala Lumpur (not Putrajaya)\n   - Afghanistan: Kabul (not Kandahar)\n   - Iran: Tehran (not Isfahan)\n   - Colombia: Bogotá (not Medellin)\n   - Canada: Ottawa\n   - Azerbaijan: Baku (not Ganja)\n   - Turkey: Ankara (not Istanbul)\n   - Iraq: Baghdad (not Beirut)\n   - Norway: Oslo (not Bergen)\n   All other capital statements must be verified against reliable geographical knowledge.\n\n2. **Arithmetic evaluation**:\n   - Perform operations with correct precedence: multiplication/division before addition/subtraction\n   - Handle negative numbers carefully: \n     - Double negative equals positive: -(-x) = x\n     - Division of negatives: -x/-y = x/y\n     - Use exact fractions when possible to avoid floating-point errors\n   - Comparisons: \"is less than or equal to\" means ≤, \"is greater than\" means >\n\n3. **Parentheses handling**:\n   - Reformate the expression with indentation for clarity before evaluation\n   - Use a numbered bracket system: label innermost parentheses as [L1], then [L2], etc.\n   - Maintain a table to track parentheses levels and their current values\n   - Always process the deepest nesting level first\n   - Double-check parentheses matching using a stack approach\n\n4. **Logical operator precedence**:\n   - Highest: `not` (right-associative)\n   - Then: `and` (left-associative)\n   - Then: `or` (left-associative)\n   - Simplify `not` sequences step by step:\n     - `not not X` = X\n     - `not not not X` = `not X`\n     - Always reduce one `not` at a time\n\n5. **Strict short-circuiting**:\n   - If you encounter `False and ...`, immediately evaluate to False without further computation\n   - If you encounter `True or ...`, immediately evaluate to True without further computation\n   - For capital facts: short-circuit immediately on false facts in `and` clauses, true facts in `or` clauses\n\n6. **Step-by-step evaluation**:\n   - For each expression, begin by reformatting it with clear indentation\n   - Identify all parentheses levels with labels [L1], [L2], etc.\n   - Evaluate innermost components first (facts, arithmetic, comparisons)\n   - Replace evaluated parts with their Boolean values\n   - Apply logical operators in correct order\n   - Show each simplification step clearly with current expression state\n\n7. **Verification**:\n   - After all expressions, provide a truth value summary: A: False, B: False, C: True, etc.\n   - If more than one seems True, re-check in this order:\n     - Expressions with capital city facts first\n     - Most complex nesting first\n     - Arithmetic with negative numbers\n   - Pay special attention to:\n     - Parentheses grouping in expressions with 5+ nesting levels\n     - Negative number arithmetic and division\n     - Capital city facts against the provided list\n     - Operator precedence\n     - Short-circuiting opportunities\n\n### Critical reminders:\n- Count parentheses carefully—use a stack approach for deep nesting\n- Verify capital cities against the provided list\n- Double-check arithmetic with negative numbers\n- Apply short-circuiting immediately when possible\n- Simplify `not` chains before other operations\n- If multiple expressions appear True, re-check the most complex ones first\n\n### Few-shot examples with common failures:\n\n[Example 1: Expression A from previous failure]\nIncorrect: Evaluated `True and False` as True due to misgrouping\nCorrect: `(True and False)` must evaluate to False regardless of surrounding context\n\n[Example 2: Expression E from previous failure]\nIncorrect: Misparsed final `and` operation due to complex nesting\nCorrect: Compute arithmetic first: `-5*10 = -50 > 9` is False, then apply logical operators step by step\n\n[Example 3: Expression B from previous failure]\nIncorrect: Used Putrajaya instead of Kuala Lumpur for Malaysia's capital\nCorrect: Use standard knowledge—Kuala Lumpur is the capital of Malaysia\n\n[Example 4: Expression D from recent failure]\nIncorrect: Miscounted parentheses in deep nesting of `not` operators\nCorrect: `not not not False` = `not not True` = `not False` = True\n\n[Example 5: Expression A from arithmetic error]\nIncorrect: Evaluated `6 - (-7/-4)` as `6 - (-1.75)` instead of `6 - 1.75`\nCorrect: `-7/-4 = 1.75`, so `6 - 1.75 = 4.25`\n\n[Example 6: Expression C from short-circuiting failure]\nIncorrect: Failed to short-circuit on `False and (complex expression)` \nCorrect: Immediately return False when encountering `False and ...`\n\n[Example 7: Expression E from capital fact error]\nIncorrect: Accepted \"The capital of Turkey is Istanbul\" as True\nCorrect: Ankara is the capital of Turkey, so this is False\n\n### Output format:\n- For each expression:\n  - First, reformat the expression with clear indentation\n  - Show parentheses levels with labels [L1], [L2], etc.\n  - Display each simplification step with current expression\n  - Indicate short-circuiting when applicable\n- After all expressions, provide truth value summary: \"A: False, B: False, C: True, D: False, E: False\"\n- Final conclusion: \"Therefore, expression [X] is True.\"\n\n### Common pitfalls to avoid:\n- Miscounting parentheses in expressions with deep nesting\n- Arithmetic sign errors with negative numbers\n- Factual errors about capital cities\n- Forgetting to short-circuit when possible\n- Misapplying operator precedence (`not` > `and` > `or`)\n- Not simplifying sequences of `not` operators\n- Continuing computation after short-circuiting opportunity\n\nNow evaluate the following expressions. Show your reasoning step-by-step for each expression, and conclude with which one (A-E) is True.\n\n[The five expressions to be evaluated]",
                        "Q": 0.35,
                        "N": 0,
                        "uct_value": 0.0,
                        "reward": 0.35,
                        "children": []
                      }
                    ]
                  },
                  {
                    "id": 7,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Factual knowledge reference**: Use these standard capital cities:\n   - Cameroon: Yaoundé (accept common misspellings like \"Yaounde\")\n   - Denmark: Copenhagen (not Aarhus)\n   - Norway: Oslo\n   - Jordan: Amman\n   - Nigeria: Abuja\n   - Germany: Berlin\n   - Belarus: Minsk\n   - UAE: Abu Dhabi (not Dubai)\n   - Armenia: Yerevan (not Gyumri)\n   - Gambia: Banjul (not Libreville)\n   - Malaysia: Kuala Lumpur\n   - Turkey: Ankara\n   - Afghanistan: Kabul\n   - India: New Delhi\n   - Canada: Ottawa\n   - Iraq: Baghdad\n   - Nepal: Kathmandu\n   - Azerbaijan: Baku\n   All other capital statements must be verified against reliable geographical knowledge. For minor phrasing variations (e.g., \"the Nigeria\"), assume standard reference.\n\n2. **Arithmetic evaluation**:\n   - Use exact fractions (e.g., -2/-7 = 2/7). Only convert to decimals when necessary for comparison, using at least 4 decimal places.\n   - Perform operations with correct precedence: multiplication/division before addition/subtraction\n   - Handle negative numbers carefully: e.g., -2/-7 = 2/7 ≈ 0.2857\n   - Comparisons: \"is less than or equal to\" means ≤, \"is greater than\" means >\n\n3. **Parentheses handling**:\n   - Use a bottom-up substitution method for deep nesting (>3 levels):\n     1. Identify and evaluate the innermost subexpression\n     2. Replace it with its Boolean value\n     3. Repeat until fully simplified\n   - Avoid deep mental stacking. If needed, use scratch paper to track levels.\n\n4. **Logical operator precedence**:\n   - Highest: `not` (right-associative)\n   - Then: `and` (left-associative)\n   - Then: `or` (left-associative)\n   - Simplify `not` sequences using parity:\n     - Even number of `not`s: not not ... X = X\n     - Odd number: not not not ... X = not X\n   - Count `not` operators carefully in long chains\n\n5. **Strict short-circuiting**:\n   - If you encounter `False and ...`, immediately evaluate to False without further computation\n   - If you encounter `True or ...`, immediately evaluate to True\n   - Do not compute unnecessary subexpressions\n\n6. **Step-by-step evaluation**:\n   - For each expression, begin by identifying the innermost components\n   - Evaluate facts, arithmetic, and comparisons first\n   - Replace evaluated parts with their Boolean values\n   - Apply logical operators in correct order\n   - Show each simplification step clearly, indicating short-circuiting when applicable\n\n7. **Verification**:\n   - After all expressions, if more than one seems True, re-check each step of the true expressions\n   - Pay special attention to:\n     - Parentheses grouping in expressions with 5+ nesting levels\n     - Negative number arithmetic and fraction precision\n     - Capital city facts against the reference list\n     - Operator precedence and short-circuiting opportunities\n   - Only one expression should be True. If multiple appear true, you likely made an error.\n\n### Few-shot examples with common failures:\n\n[Example 1: Expression A from previous failure]\nIncorrect: Evaluated `True and False` as True due to misgrouping in deep nesting\nCorrect: Always process innermost parentheses first: `(True and False)` must evaluate to False regardless of context\n\n[Example 2: Expression E from previous failure]\nIncorrect: Misparsed final `and` operation due to complex nesting\nCorrect: Compute arithmetic first: `-5*10 = -50 > 9` is False, then apply logical operators step by step\n\n[Example 3: Expression B from previous failure]\nIncorrect: Used incorrect fraction approximation (4.777 instead of 43/9) leading to precision error\nCorrect: Use exact fractions: 5 - (2/9) = 43/9 ≈ 4.7778, then compare accurately\n\n[Example 4: Expression D from recent failure]\nIncorrect: Miscounted parentheses in deep nesting of `not` operators\nCorrect: `not not not False` = `not not True` = `not False` = True\n\n[Example 5: Multiple expressions true]\nIncorrect: Found both B and E true in Example 1\nCorrect: When multiple seem true, re-check arithmetic signs and capital facts carefully. Gold answer was E.\n\n### Output format:\n- For each expression:\n  - Show evaluation steps with current expression state after each simplification\n  - Indicate short-circuiting when applicable with \"[Short-circuit]\"\n  - Use exact fractions for arithmetic\n- After all expressions, provide final conclusion: \"Therefore, expression [X] is True.\"\n\n### Common pitfalls to avoid:\n- Miscounting parentheses in expressions with 5+ nesting levels\n- Arithmetic sign errors with negative numbers and fractions\n- Factual errors about capital cities not in reference list\n- Forgetting to short-circuit when possible\n- Misapplying operator precedence (`not` > `and` > `or`)\n- Using decimal approximations instead of exact fractions\n\nNow evaluate the following expressions. Show your reasoning step-by-step for each expression, and conclude with which one (A-E) is True.\n\n[The five expressions to be evaluated]",
                    "Q": 0.4,
                    "N": 0,
                    "uct_value": 0.002081386527894244,
                    "reward": 0.4,
                    "children": []
                  },
                  {
                    "id": 8,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Factual knowledge reference**: Use these standard capital cities:\n   - Cameroon: Yaoundé (not Douala)\n   - Denmark: Copenhagen (not Aarhus)\n   - Norway: Oslo\n   - Jordan: Amman\n   - Nigeria: Abuja\n   - Germany: Berlin\n   - Belarus: Minsk\n   - UAE: Abu Dhabi (not Dubai)\n   - Armenia: Yerevan (not Gyumri)\n   - Gambia: Banjul (not Libreville)\n   All other capital statements must be verified against reliable geographical knowledge.\n\n2. **Arithmetic evaluation**:\n   - Perform operations with correct precedence: multiplication/division before addition/subtraction\n   - Handle negative numbers carefully: e.g., -2/-7 = 2/7 ≈ 0.2857\n   - Use exact fractions when possible to avoid floating-point errors\n   - Comparisons: \"is less than or equal to\" means ≤, \"is greater than\" means >\n\n3. **Logical operator precedence**:\n   - Highest: `not` (right-associative: evaluate from right to left)\n   - Then: `and` (left-associative)\n   - Then: `or` (left-associative)\n   - Simplify `not` sequences first:\n     - Even number of `not`s: equivalent to identity (e.g., `not not X` = X)\n     - Odd number of `not`s: equivalent to `not` (e.g., `not not not X` = `not X`)\n\n4. **Evaluation strategy**:\n   - **Step 1: Resolve all factual statements** - Identify all capital city claims and evaluate them immediately using standard knowledge\n   - **Step 2: Compute all arithmetic** - Calculate all mathematical expressions with proper precedence\n   - **Step 3: Simplify `not` sequences** - Reduce all consecutive `not` operators using the parity rule\n   - **Step 4: Process parentheses** - Work from innermost to outermost, replacing each parentheses group with its Boolean value\n   - **Step 5: Apply logical operators** - Use precedence rules and short-circuit aggressively:\n     - If you encounter `False and ...`, immediately evaluate to False\n     - If you encounter `True or ...`, immediately evaluate to True\n\n5. **Structured evaluation format**:\n   For each expression:\n   - List all factual statements with their truth values\n   - List all arithmetic expressions with their computed values\n   - Show each simplification step with current expression state\n   - Indicate when short-circuiting occurs\n   - Conclude with the final Boolean value\n\n6. **Verification**:\n   - After all expressions, if more than one seems True, re-check each step for:\n     - Parentheses grouping errors\n     - Negative number arithmetic mistakes\n     - Capital city factual errors\n     - Missed short-circuiting opportunities\n\n### Few-shot examples with critical failures:\n\n[Example 1: Expression A from previous failure]\nIncorrect: Evaluated `True and False` as True due to misgrouping\nCorrect: `(True and False)` must evaluate to False regardless of surrounding context\n\n[Example 2: Expression E from previous failure]\nIncorrect: Misparsed final `and` operation due to complex nesting\nCorrect: Compute arithmetic first: `-5*10 = -50 > 9` is False, then apply logical operators step by step\n\n[Example 3: Expression B from previous failure]\nIncorrect: Used Putrajaya instead of Kuala Lumpur for Malaysia's capital\nCorrect: Use standard knowledge—Kuala Lumpur is the capital of Malaysia\n\n[Example 4: Expression D from recent failure]\nIncorrect: Miscounted parentheses in deep nesting of `not` operators\nCorrect: `not not not False` = `not not True` = `not False` = True\n\n[Example 5: Expression C from recent failure]\nIncorrect: Failed to short-circuit `False and ...` expression\nCorrect: Once `False` is encountered in an `and` operation, immediately evaluate to False\n\n### Output format:\n- For each expression:\n  - Show all factual statements with truth values\n  - Show all arithmetic computations with results\n  - Display each simplification step with current expression\n  - Indicate short-circuiting when applicable\n- After all expressions, provide final conclusion: \"Therefore, expression [X] is True.\"\n\n### Critical pitfalls to avoid:\n- Miscounting parentheses in expressions with 5+ nesting levels - use systematic replacement\n- Arithmetic sign errors with negative numbers - compute carefully\n- Factual errors about capital cities - verify against provided list\n- Forgetting to short-circuit when possible - check for `False and ...` or `True or ...`\n- Misapplying operator precedence (`not` > `and` > `or`)\n- Not simplifying sequences of `not` operators - use parity rule\n\nNow evaluate the following expressions. Show your reasoning step-by-step for each expression, and conclude with which one (A-E) is True.\n\n[The five expressions to be evaluated]",
                    "Q": 0.35,
                    "N": 0,
                    "uct_value": 0.002081386527894244,
                    "reward": 0.35,
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "id": 3,
            "depth": 2,
            "action_sequence": [
              "FailureDrivenAction",
              "FailureDrivenAction"
            ],
            "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Precomputation Phase**:\n   - First, identify and list all factual statements (e.g., \"The capital of X is Y\") with their truth values using standard world knowledge.\n   - Compute all arithmetic expressions innermost first, showing steps and respecting operator precedence.\n   - Create a reference table of computed values before logical evaluation.\n\n2. **Structured Evaluation**:\n   - Use a bottom-up approach: start from the innermost parentheses and work outward.\n   - Label sub-expressions (e.g., P1, P2) for tracking.\n   - For repeated `not` operations, simplify systematically:\n        - `not not X` = X\n        - `not not not X` = not X\n   - Apply logical operators with precedence: `not` > `and` > `or`.\n   - Short-circuit explicitly:\n        - If `False and ...` → immediately return False without computing `...`\n        - If `True or ...` → immediately return True without computing `...`\n        - Document: \"Short-circuit: False and ... → False\"\n\n3. **Step-by-Step Format**:\n   For each expression:\n   - **Step 1**: Precompute all facts and arithmetic.\n   - **Step 2**: Evaluate logical operations from inner to outer, showing each simplification.\n   - **Step 3**: Combine results, documenting all operations.\n\n4. **Verification**:\n   - After evaluating all expressions, verify that only one is True.\n   - If multiple seem True, re-check the most complex expressions for errors in:\n        - Parentheses grouping\n        - Arithmetic signs\n        - Factual accuracy\n        - Short-circuiting opportunities\n\n### Common Pitfalls to Avoid:\n- Misgrouping due to deep nesting: Count parentheses carefully using a matching approach.\n- Arithmetic sign errors: Double-check negative numbers and division.\n- Factual errors: Confirm capitals (e.g., Cameroon's capital is Yaounde, not Douala).\n- Missing short-circuiting: Avoid unnecessary computations.\n- Misinterpreting `not` sequences: Simplify step-by-step.\n\n### Examples for Reference:\n[Example 1: Expression A]\nIncorrect: Failed to short-circuit `False and ...`\nCorrect: \"Short-circuit: False and ... → False, then not(False) → True\"\n\n[Example 2: Expression E]\nIncorrect: Misparsed final `and` operation\nCorrect: Compute arithmetic first: -5*10 = -50 > 9? False. Then apply logical operators.\n\n[Example 3: Expression C]\nIncorrect: Missed that \"The capital of Canada is Toronto\" is False\nCorrect: Verify all facts against world knowledge.\n\n[Example 4: Expression D]\nIncorrect: Evaluated as True due to missing short-circuiting\nCorrect: \"False and ... → False (short-circuited), so entire expression False\"\n\n[Example 5: Expression E]\nIncorrect: Overlooked capital of Gambia is Banjul (True)\nCorrect: Precompute facts: \"The capital of Gambia is Banjul → True\"\n\n### Final Checklist:\n- [ ] All facts precomputed and verified\n- [ ] All arithmetic computed step-by-step\n- [ ] Parentheses matched correctly\n- [ ] Short-circuiting applied where possible\n- [ ] Only one expression is True\n\nNow evaluate the following expressions. Show your reasoning step-by-step for each expression, and conclude with which one (A-E) is True.\n\n[The five expressions to be evaluated]",
            "Q": 0.45,
            "N": 0,
            "uct_value": 0.003346415497614626,
            "reward": 0.45,
            "children": [
              {
                "id": 4,
                "depth": 3,
                "action_sequence": [
                  "FailureDrivenAction",
                  "FailureDrivenAction",
                  "FailureDrivenAction"
                ],
                "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Precomputation Phase**:\n   - **Factual Statements**: Use this definitive truth table for all factual claims:\n        | Statement | Truth Value |\n        |-----------|-------------|\n        | The capital of Canada is Ottawa. | True |\n        | The capital of Canada is Toronto. | False |\n        | The capital of Iran is Tehran. | True |\n        | The capital of Iraq is Beirut. | False (Baghdad) |\n        | The capital of Denmark is Aarhus. | False (Copenhagen) |\n        | The capital of Azerbaijan is Baku. | True |\n        | The capital of UAE is Abu Dhabi. | True |\n        | The capital of Jordan is Beirut. | False (Amman) |\n        | The capital of Gambia is Banjul. | True |\n        | The capital of Cameroon is Douala. | False (Yaoundé) |\n        | The capital of Malaysia is Putrajaya. | True (administrative) |\n        | The capital of Norway is Oslo. | True |\n        | The capital of Norway is Bergen. | False |\n        | The capital of Colombia is Bogota. | True |\n        | The capital of Nigeria is Lagos. | False (Abuja) |\n        | The capital of Nigeria is Abuja. | True |\n        | The capital of India is New Delhi. | True |\n        | The capital of India is Mumbai. | False |\n        | The capital of Armenia is Yerevan. | True |\n        | The capital of Germany is Berlin. | True |\n        | The capital of Belarus is Grodno. | False (Minsk) |\n        | The capital of Nepal is Kathmandu. | True |\n        | The capital of Nepal is Pokhara. | False |\n   - **Arithmetic Computation**:\n        - Compute all arithmetic innermost first, showing steps.\n        - Respect operator precedence: parentheses > division/multiplication > addition/subtraction.\n        - Double-check signs and divisions carefully.\n        - Precompute all `max` and `min` values first.\n   - Create a reference table of computed arithmetic values.\n\n2. **Structured Evaluation**:\n   - **Parentheses Handling**: Use a counter to ensure perfect matching. For each expression, start with counter=0; increment at '('; decrement at ')'. Must return to zero.\n   - **Sub-expression Labeling**: Label every sub-expression (e.g., P1, P2) and maintain a lookup table. Evaluate from innermost outward.\n   - **Not Simplification**: Simplify `not` chains iteratively from innermost outward:\n        - `not not X` = X\n        - `not not not X` = not X\n   - **Logical Precedence**: Apply strictly: `not` > `and` > `or`. Insert parentheses where needed to enforce.\n   - **Short-Circuiting**: At every step, before computing right operand:\n        - If `False and ...` → immediately return False (document \"Short-circuit: False and ... → False\")\n        - If `True or ...` → immediately return True (document \"Short-circuit: True or ... → True\")\n\n3. **Step-by-Step Format**:\n   For each expression:\n   - **Step 1**: Precompute all facts and arithmetic.\n   - **Step 2**: Evaluate logical operations from inner to outer, showing each simplification, short-circuiting, and substitution from lookup table.\n   - **Step 3**: Combine results, documenting all operations.\n\n4. **Verification**:\n   - After evaluating all expressions, verify that only one is True.\n   - If multiple seem True, re-check in this order:\n        1. Expressions with deepest nesting\n        2. Expressions with most `not` operations\n        3. Expressions with most arithmetic operations\n   - Focus on common error sources:\n        - Parentheses grouping (use counter)\n        - Arithmetic signs (double-check negatives)\n        - Factual accuracy (use provided table)\n        - Short-circuiting opportunities\n   - Present final summary table:\n        | Expression | Result |\n        |------------|--------|\n        | A          |        |\n        | B          |        |\n        | C          |        |\n        | D          |        |\n        | E          |        |\n\n### Common Pitfalls to Avoid:\n- Misgrouping due to deep nesting: Count parentheses with counter\n- Arithmetic sign errors: Double-check negative numbers and division\n- Factual errors: Use provided truth table strictly\n- Missing short-circuiting: Always check left operand first\n- Misinterpreting `not` sequences: Simplify step-by-step from inside out\n\n### Failure Examples for Reference:\n[Example 1: Expression A]\nError: Failed to short-circuit `False and ...` in nested context\nCorrect: \"Short-circuit: False and ... → False, then not(False) → True\"\n\n[Example 2: Expression E]\nError: Misparsed final `and` operation due to precedence\nCorrect: Compute arithmetic first: -5*10 = -50 > 9? False. Then apply logical operators with proper grouping.\n\n[Example 3: Expression C]\nError: Used ambiguous world knowledge for Malaysian capital\nCorrect: Use provided truth table: Putrajaya is True (administrative capital)\n\n[Example 4: Expression D]\nError: Evaluated as True due to missing short-circuiting\nCorrect: \"False and ... → False (short-circuited), so entire expression False\"\n\n[Example 5: Expression B]\nError: Miscounted parentheses in deep nesting\nCorrect: Use parentheses counter: ensure count returns to zero at end\n\n### Final Checklist:\n- [ ] All facts precomputed using provided truth table\n- [ ] All arithmetic computed step-by-step with signs double-checked\n- [ ] Parentheses matched using counter (start/end at zero)\n- [ ] Short-circuiting applied where possible\n- [ ] Only one expression is True\n\nNow evaluate the following expressions. Show your reasoning step-by-step for each expression, and conclude with which one (A-E) is True.\n\n[The five expressions to be evaluated]",
                "Q": 0.6,
                "N": 0,
                "uct_value": 0.0,
                "reward": 0.6,
                "children": [
                  {
                    "id": 5,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Precomputation Phase**:\n   - **Factual Statements**: Use this definitive truth table for all factual claims. Any statement not listed must be treated as **False**.\n        | Statement | Truth Value |\n        |-----------|-------------|\n        | The capital of Canada is Ottawa. | True |\n        | The capital of Canada is Toronto. | False |\n        | The capital of Iran is Tehran. | True |\n        | The capital of Iraq is Beirut. | False |\n        | The capital of Denmark is Aarhus. | False |\n        | The capital of Azerbaijan is Baku. | True |\n        | The capital of UAE is Abu Dhabi. | True |\n        | The capital of Jordan is Beirut. | False |\n        | The capital of Gambia is Banjul. | True |\n        | The capital of Cameroon is Douala. | False |\n        | The capital of Malaysia is Putrajaya. | True |\n        | The capital of Norway is Oslo. | True |\n        | The capital of Norway is Bergen. | False |\n        | The capital of Colombia is Bogota. | True |\n        | The capital of Nigeria is Lagos. | False |\n        | The capital of Nigeria is Abuja. | True |\n        | The capital of India is New Delhi. | True |\n        | The capital of India is Mumbai. | False |\n        | The capital of Armenia is Yerevan. | True |\n        | The capital of Germany is Berlin. | True |\n        | The capital of Belarus is Grodno. | False |\n        | The capital of Nepal is Kathmandu. | True |\n        | The capital of Nepal is Pokhara. | False |\n   - **Arithmetic Computation**:\n        - Compute all arithmetic innermost first, showing steps.\n        - Respect operator precedence: parentheses > division/multiplication > addition/subtraction.\n        - Double-check signs and divisions carefully.\n        - Precompute all `max` and `min` values first.\n   - Create a reference table of computed arithmetic values with labels (e.g., ARITH1, ARITH2).\n\n2. **Structured Evaluation**:\n   - **Parentheses Handling**: Use a counter to ensure perfect matching. For each expression, start with counter=0; increment at '('; decrement at ')'. Must return to zero.\n   - **Sub-expression Labeling**: Label every sub-expression (e.g., P1, P2) and maintain a lookup table. Evaluate from innermost outward.\n   - **Not Simplification**: Simplify `not` chains iteratively from innermost outward:\n        - `not not X` = X\n        - `not not not X` = not X\n        - Continue this pattern for longer chains.\n   - **Logical Precedence**: Apply strictly: `not` > `and` > `or`. Insert parentheses explicitly to enforce precedence where needed.\n   - **Short-Circuiting**: At every step, before computing right operand:\n        - If `False and ...` → immediately return False (document \"Short-circuit: False and ... → False\")\n        - If `True or ...` → immediately return True (document \"Short-circuit: True or ... → True\")\n        - Apply this recursively in nested contexts.\n\n3. **Step-by-Step Format**:\n   For each expression:\n   - **Step 1**: Precompute all facts and arithmetic, storing results in reference tables.\n   - **Step 2**: Evaluate logical operations from inner to outer, showing each simplification, short-circuiting, and substitution from lookup table.\n   - **Step 3**: Combine results, documenting all operations.\n\n4. **Verification**:\n   - After evaluating all expressions, verify that only one is True.\n   - If multiple seem True, re-check in this order:\n        1. Expressions with deepest nesting\n        2. Expressions with most `not` operations\n        3. Expressions with most arithmetic operations\n   - Focus on common error sources:\n        - Parentheses grouping (use counter)\n        - Arithmetic signs (double-check negatives)\n        - Factual accuracy (use provided table strictly)\n        - Short-circuiting opportunities (ensure none missed)\n   - Present final summary table:\n        | Expression | Result |\n        |------------|--------|\n        | A          |        |\n        | B          |        |\n        | C          |        |\n        | D          |        |\n        | E          |        |\n\n### Common Pitfalls to Avoid:\n- Misgrouping due to deep nesting: Count parentheses with counter\n- Arithmetic sign errors: Double-check negative numbers and division\n- Factual errors: Use provided truth table strictly; unlisted statements are False\n- Missing short-circuiting: Always check left operand first at every level\n- Misinterpreting `not` sequences: Simplify step-by-step from inside out\n\n### Failure Examples for Reference:\n[Example 1: Expression A]\nError: Failed to short-circuit `False and ...` in nested context\nCorrect: \"Short-circuit: False and ... → False, then not(False) → True\"\n\n[Example 2: Expression E]\nError: Misparsed final `and` operation due to precedence\nCorrect: Compute arithmetic first: -5*10 = -50 > 9? False. Then apply logical operators with proper grouping.\n\n[Example 3: Expression C]\nError: Used ambiguous world knowledge for Malaysian capital\nCorrect: Use provided truth table: Putrajaya is True (administrative capital)\n\n[Example 4: Expression D]\nError: Evaluated as True due to missing short-circuiting\nCorrect: \"False and ... → False (short-circuited), so entire expression False\"\n\n[Example 5: Expression B]\nError: Miscounted parentheses in deep nesting\nCorrect: Use parentheses counter: ensure count returns to zero at end\n\n[Example 6: Expression E]\nError: Treated unlisted factual statement as True\nCorrect: \"The capital of Turkey is Ankara\" not in table → False\n\n### Final Checklist:\n- [ ] All facts precomputed using provided truth table; unlisted statements = False\n- [ ] All arithmetic computed step-by-step with signs double-checked\n- [ ] Parentheses matched using counter (start/end at zero)\n- [ ] Short-circuiting applied where possible at every level\n- [ ] Only one expression is True\n\nNow evaluate the following expressions. Show your reasoning step-by-step for each expression, and conclude with which one (A-E) is True.\n\n[The five expressions to be evaluated]",
                    "Q": 0.3,
                    "N": 0,
                    "uct_value": 0.0,
                    "reward": 0.3,
                    "children": []
                  },
                  {
                    "id": 6,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Precomputation Phase**:\n   - **Factual Statements**: Use this definitive truth table for all factual claims. Any statement not listed is considered False.\n        | Statement | Truth Value |\n        |-----------|-------------|\n        | The capital of Canada is Ottawa. | True |\n        | The capital of Canada is Toronto. | False |\n        | The capital of Iran is Tehran. | True |\n        | The capital of Iraq is Beirut. | False |\n        | The capital of Denmark is Aarhus. | False |\n        | The capital of Azerbaijan is Baku. | True |\n        | The capital of UAE is Abu Dhabi. | True |\n        | The capital of Jordan is Beirut. | False |\n        | The capital of Gambia is Banjul. | True |\n        | The capital of Cameroon is Douala. | False |\n        | The capital of Malaysia is Putrajaya. | True |\n        | The capital of Norway is Oslo. | True |\n        | The capital of Norway is Bergen. | False |\n        | The capital of Colombia is Bogota. | True |\n        | The capital of Nigeria is Lagos. | False |\n        | The capital of Nigeria is Abuja. | True |\n        | The capital of India is New Delhi. | True |\n        | The capital of India is Mumbai. | False |\n        | The capital of Armenia is Yerevan. | True |\n        | The capital of Germany is Berlin. | True |\n        | The capital of Belarus is Grodno. | False |\n        | The capital of Nepal is Kathmandu. | True |\n        | The capital of Nepal is Pokhara. | False |\n   - **Arithmetic Computation**:\n        - Compute all arithmetic innermost first, showing steps.\n        - Respect operator precedence: parentheses > division/multiplication > addition/subtraction.\n        - Double-check signs and divisions carefully.\n        - Precompute all `max` and `min` values first.\n        - Create a reference table of computed arithmetic values.\n   - **Typos and Ambiguities**: Correct obvious typos in factual statements (e.g., \"the Nigeria\" → \"Nigeria\") to match the truth table.\n\n2. **Structured Evaluation**:\n   - **Parentheses Handling**: Use a counter to ensure perfect matching. For each expression, start with counter=0; increment at '('; decrement at ')'. Must return to zero.\n   - **Sub-expression Labeling**: Label every sub-expression (e.g., P1, P2) and maintain a lookup table. Evaluate from innermost outward using recursive descent.\n   - **Not Simplification**: Simplify `not` chains iteratively from innermost outward:\n        - `not not X` = X\n        - `not not not X` = not X\n        - (and so on)\n   - **Logical Precedence**: Apply strictly: `not` > `and` > `or`. Insert parentheses where needed to enforce.\n   - **Short-Circuiting**: At every step, before computing right operand:\n        - If `False and ...` → immediately return False (document \"Short-circuit: False and ... → False\")\n        - If `True or ...` → immediately return True (document \"Short-circuit: True or ... → True\")\n   - **Explicit Grouping**: Rewrite expressions with explicit parentheses to avoid ambiguity (e.g., `not A and B` → `(not A) and B`).\n\n3. **Step-by-Step Format**:\n   For each expression:\n   - **Step 1**: Precompute all facts and arithmetic (list in a table).\n   - **Step 2**: Parse parentheses innermost to outermost, replacing each group with a label and value.\n   - **Step 3**: Evaluate logical operations, showing each simplification, short-circuiting, and substitution from the lookup table.\n   - **Step 4**: Combine results, documenting all operations.\n   - **Step 5**: Verify against common pitfalls.\n\n4. **Verification**:\n   - After evaluating all expressions, verify that only one is True.\n   - If multiple seem True, re-check in this order:\n        1. Expressions with deepest nesting\n        2. Expressions with most `not` operations\n        3. Expressions with most arithmetic operations\n   - Focus on common error sources:\n        - Parentheses grouping (use counter)\n        - Arithmetic signs (double-check negatives)\n        - Factual accuracy (use provided table strictly; unlisted are False)\n        - Short-circuiting opportunities\n   - Present final summary table:\n        | Expression | Result |\n        |------------|--------|\n        | A          |        |\n        | B          |        |\n        | C          |        |\n        | D          |        |\n        | E          |        |\n\n### Common Pitfalls to Avoid:\n- Misgrouping due to deep nesting: Count parentheses with counter\n- Arithmetic sign errors: Double-check negative numbers and division\n- Factual errors: Use provided truth table strictly; unlisted statements are False\n- Missing short-circuiting: Always check left operand first\n- Misinterpreting `not` sequences: Simplify step-by-step from inside out\n- Overlooking typos: Correct them to match truth table entries\n\n### Failure Examples for Reference:\n[Example 1: Expression A]\nError: Failed to short-circuit `False and ...` in nested context\nCorrect: \"Short-circuit: False and ... → False, then not(False) → True\"\n\n[Example 2: Expression E]\nError: Misparsed final `and` operation due to precedence\nCorrect: Compute arithmetic first: -5*10 = -50 > 9? False. Then apply logical operators with proper grouping.\n\n[Example 3: Expression C]\nError: Used ambiguous world knowledge for Malaysian capital\nCorrect: Use provided truth table: Putrajaya is True (administrative capital)\n\n[Example 4: Expression D]\nError: Evaluated as True due to missing short-circuiting\nCorrect: \"False and ... → False (short-circuited), so entire expression False\"\n\n[Example 5: Expression B]\nError: Miscounted parentheses in deep nesting\nCorrect: Use parentheses counter: ensure count returns to zero at end\n\n[Example 6: Expression F]\nError: Treated unlisted factual statement as true\nCorrect: Unlisted statements are false. \"The capital of Turkey is Istanbul\" is not in table → False.\n\n### Final Checklist:\n- [ ] All facts precomputed using provided truth table (unlisted facts are False)\n- [ ] All arithmetic computed step-by-step with signs double-checked and tabled\n- [ ] Parentheses matched using counter (start/end at zero)\n- [ ] Sub-expressions labeled and reduced innermost to outermost\n- [ ] Short-circuiting applied where possible\n- [ ] Only one expression is True\n\nNow evaluate the following expressions. Show your reasoning step-by-step for each expression, and conclude with which one (A-E) is True.\n\n[The five expressions to be evaluated]",
                    "Q": 0.2,
                    "N": 0,
                    "uct_value": 0.0,
                    "reward": 0.2,
                    "children": []
                  },
                  {
                    "id": 7,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Precomputation Phase**:\n   - **Factual Statements**: Use this definitive truth table for all factual claims. Match statements exactly (including punctuation and capitalization):\n        | Statement | Truth Value |\n        |-----------|-------------|\n        | The capital of Canada is Ottawa. | True |\n        | The capital of Canada is Toronto. | False |\n        | The capital of Iran is Tehran. | True |\n        | The capital of Iraq is Beirut. | False |\n        | The capital of Denmark is Aarhus. | False |\n        | The capital of Azerbaijan is Baku. | True |\n        | The capital of UAE is Abu Dhabi. | True |\n        | The capital of Jordan is Beirut. | False |\n        | The capital of Gambia is Banjul. | True |\n        | The capital of Cameroon is Douala. | False |\n        | The capital of Malaysia is Putrajaya. | True |\n        | The capital of Norway is Oslo. | True |\n        | The capital of Norway is Bergen. | False |\n        | The capital of Colombia is Bogota. | True |\n        | The capital of Nigeria is Lagos. | False |\n        | The capital of Nigeria is Abuja. | True |\n        | The capital of India is New Delhi. | True |\n        | The capital of India is Mumbai. | False |\n        | The capital of Armenia is Yerevan. | True |\n        | The capital of Germany is Berlin. | True |\n        | The capital of Belarus is Grodno. | False |\n        | The capital of Nepal is Kathmandu. | True |\n        | The capital of Nepal is Pokhara. | False |\n   - **Arithmetic Computation**:\n        - Compute all arithmetic innermost first, showing steps in a table.\n        - Respect operator precedence: parentheses > division/multiplication > addition/subtraction.\n        - Double-check signs and divisions carefully.\n        - Precompute all `max` and `min` values first.\n   - Create a reference table of computed arithmetic values and factual truths.\n\n2. **Expression Preprocessing**:\n   - **Parentheses Matching**: Before evaluation, rewrite the expression with explicit parentheses to enforce logical precedence. Use a counter: start at 0, increment at '(', decrement at ')'. Must return to zero. If not, reparse.\n   - **Sub-expression Labeling**: Label every sub-expression (e.g., P1, P2) from innermost outward. Maintain a lookup table for values.\n\n3. **Structured Evaluation**:\n   - **Not Simplification**: Simplify `not` chains iteratively from innermost outward:\n        - Even number of `not`s: identity (e.g., `not not X` = X)\n        - Odd number of `not`s: single `not` (e.g., `not not not X` = not X)\n   - **Logical Precedence**: Apply strictly: `not` > `and` > `or`. Use parentheses to enforce.\n   - **Short-Circuiting**: At every step, before computing right operand:\n        - If `False and ...` → immediately return False (document \"Short-circuit: False and ... → False\")\n        - If `True or ...` → immediately return True (document \"Short-circuit: True or ... → True\")\n   - Evaluate from innermost sub-expression outward, substituting values from the lookup table.\n\n4. **Step-by-Step Format**:\n   For each expression:\n   - **Step 1**: Precompute all facts and arithmetic. Present in tables.\n   - **Step 2**: Preprocess the expression: rewrite with explicit parentheses and label sub-expressions.\n   - **Step 3**: Evaluate logical operations step-by-step, showing each simplification, short-circuiting, and substitution.\n   - **Step 4**: Combine results, documenting all operations.\n\n5. **Verification**:\n   - After evaluating all expressions, verify that only one is True.\n   - If multiple seem True, re-check in this order:\n        1. Expressions with deepest nesting\n        2. Expressions with most `not` operations\n        3. Expressions with most arithmetic operations\n   - Focus on common error sources:\n        - Parentheses grouping (use counter)\n        - Arithmetic signs (double-check negatives)\n        - Factual accuracy (use provided table strictly)\n        - Short-circuiting opportunities\n   - Present final summary table:\n        | Expression | Result |\n        |------------|--------|\n        | A          |        |\n        | B          |        |\n        | C          |        |\n        | D          |        |\n        | E          |        |\n\n### Common Pitfalls to Avoid (with Failure Examples):\n- **Misgrouping due to deep nesting**: \n  Example: In Expression D, failed to count parentheses correctly, leading to incorrect grouping. Correct: Use counter to ensure matching.\n- **Arithmetic sign errors**:\n  Example: In Expression E, computed `-7 * -4 + -8 * 8` as 28 + (-64) = -36, but missed sign in comparison.\n- **Factual errors**:\n  Example: In Expression C, used \"The capital of Malaysia is Kuala Lumpur\" (False) instead of Putrajaya (True). Use provided table only.\n- **Missing short-circuiting**:\n  Example: In Expression A, evaluated `False and ...` fully instead of short-circuiting. Correct: \"Short-circuit: False and ... → False\".\n- **Not simplification errors**:\n  Example: In Expression B, simplified `not not not True` to `True` instead of `False`. Correct: `not not not True` = `not not False` = `not True` = `False`.\n\n### Final Checklist:\n- [ ] All facts precomputed using provided truth table (exact match)\n- [ ] All arithmetic computed step-by-step with signs double-checked\n- [ ] Expression rewritten with explicit parentheses (counter starts/ends at 0)\n- [ ] Sub-expressions labeled and tracked in lookup table\n- [ ] Short-circuiting applied where possible (documented)\n- [ ] Only one expression is True (re-check if multiple)\n\nNow evaluate the following expressions. Show your reasoning step-by-step for each expression, and conclude with which one (A-E) is True.\n\n[The five expressions to be evaluated]",
                    "Q": 0.25,
                    "N": 0,
                    "uct_value": 0.0,
                    "reward": 0.25,
                    "children": []
                  }
                ]
              },
              {
                "id": 5,
                "depth": 3,
                "action_sequence": [
                  "FailureDrivenAction",
                  "FailureDrivenAction",
                  "FailureDrivenAction"
                ],
                "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Critical Instructions:\n1. **Precomputation Phase**:\n   - **Fact Verification**: Use this definitive fact table (override world knowledge if needed):\n        - The capital of Germany is Berlin: True\n        - The capital of Gambia is Banjul: True\n        - The capital of Canada is Ottawa: True\n        - The capital of Cameroon is Yaoundé: True (so \"Douala\" is False)\n        - The capital of Belarus is Minsk: True (so \"Grodno\" is False)\n        - The capital of Afghanistan is Kabul: True\n        - The capital of Jordan is Amman: True (so \"Beirut\" is False)\n        - The capital of Colombia is Bogotá: True\n        - The capital of India is New Delhi: True (so \"Mumbai\" is False)\n        - The capital of Malaysia is Putrajaya: True (accept \"Kuala Lumpur\" as True for this task)\n        - The capital of Turkey is Ankara: True (so \"Istanbul\" is False)\n        - The capital of UAE is Abu Dhabi: True\n        - The capital of Iran is Tehran: True\n        - The capital of Armenia is Yerevan: True\n        - The capital of Norway is Oslo: True\n        - The capital of Nepal is Kathmandu: True (so \"Pokhara\" is False)\n        - The capital of Iraq is Baghdad: True\n        - The capital of Azerbaijan is Baku: True\n\n   - **Arithmetic Computation**:\n        - Compute all arithmetic innermost first, showing steps\n        - Use exact fractions where possible (e.g., -10/7 ≈ -1.4286)\n        - Respect operator precedence: multiplication/division before addition/subtraction\n        - For max/min operations: max(a,b,c,d) returns largest value, min(a,b,c,d) returns smallest\n        - Create a reference table of computed values before logical evaluation\n\n2. **Structured Evaluation**:\n   - **Parenthesis Handling**: Count opening and closing parentheses carefully. Use a matching approach: for every opening '(', find its closing ')'\n   - **Bottom-up Approach**: Start from the innermost parentheses and work outward\n   - **Sub-expression Labeling**: Label sub-expressions as P1, P2, P3... for tracking\n   - **Not Simplification**: Apply systematically:\n        - not not X = X\n        - not not not X = not X\n        - not not not not X = X\n        (Even number of 'not's cancel, odd number reduce to one 'not')\n   - **Operator Precedence**: Apply in order: not > and > or\n   - **Short-circuiting**: Apply explicitly and document:\n        - If \"False and ...\" → immediately return False without computing \"...\"\n        - If \"True or ...\" → immediately return True without computing \"...\"\n        - Document: \"Short-circuit: False and ... → False\"\n\n3. **Step-by-Step Format**:\n   For each expression:\n   - **Step 1**: Precompute all facts and arithmetic\n   - **Step 2**: Evaluate logical operations from inner to outer, showing each simplification\n   - **Step 3**: Combine results, documenting all operations and short-circuiting\n\n4. **Verification**:\n   - After evaluating all expressions, verify that only one is True\n   - If multiple seem True, re-check the most complex expressions for:\n        - Parentheses grouping errors\n        - Arithmetic sign errors\n        - Factual inaccuracies\n        - Missed short-circuiting opportunities\n   - If all seem False, re-check for evaluation errors\n\n### Common Pitfalls to Avoid:\n- Miscounting parentheses in deep nesting: Use a counter approach\n- Floating-point precision errors: Use exact fractions where possible\n- Missing short-circuiting: Always check for False and ... / True or ...\n- Misinterpreting capital cities: Use the provided fact table\n- Miscounting 'not' operations: Simplify step-by-step\n- Arithmetic sign errors: Double-check negative number operations\n\n### Failure Examples for Reference:\n[Example 1: Expression A]\nIncorrect: Failed to short-circuit `False and ...` in nested expression\nCorrect: \"Short-circuit: False and ... → False, then not(False) → True\"\n\n[Example 2: Expression E]\nIncorrect: Misparsed final `and` operation due to parenthesis mismatch\nCorrect: Compute arithmetic first: -5*10 = -50 > 9? False. Then apply logical operators with proper grouping\n\n[Example 3: Expression C]\nIncorrect: Missed that \"The capital of Canada is Toronto\" is False\nCorrect: Verify all facts against the provided fact table\n\n[Example 4: Expression D]\nIncorrect: Evaluated as True due to missing short-circuiting\nCorrect: \"False and ... → False (short-circuited), so entire expression False\"\n\n[Example 5: Expression B]\nIncorrect: Overlooked capital of Gambia is Banjul (True) but used wrong fact\nCorrect: Use provided fact table: \"The capital of Gambia is Banjul → True\"\n\n### Final Checklist:\n- [ ] All facts verified against provided fact table\n- [ ] All arithmetic computed precisely with exact fractions\n- [ ] Parentheses matched and counted correctly\n- [ ] Short-circuiting applied where possible\n- [ ] Not operations simplified step-by-step\n- [ ] Only one expression is True\n\nNow evaluate the following expressions. Show your reasoning step-by-step for each expression, and conclude with which one (A-E) is True.\n\n[The five expressions to be evaluated]",
                "Q": 0.4,
                "N": 0,
                "uct_value": 0.0,
                "reward": 0.4,
                "children": []
              },
              {
                "id": 6,
                "depth": 3,
                "action_sequence": [
                  "FailureDrivenAction",
                  "FailureDrivenAction",
                  "FailureDrivenAction"
                ],
                "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Precomputation Phase**:\n   - First, identify and list all factual statements (e.g., \"The capital of X is Y\") with their truth values using the following definitive knowledge:\n        - The capital of Turkey is Ankara (not Istanbul)\n        - The capital of Cameroon is Yaounde (not Douala)\n        - The capital of Iraq is Baghdad (not Beirut)\n        - The capital of Belarus is Minsk\n        - The capital of Jordan is Amman (not Beirut)\n        - The capital of Azerbaijan is Baku\n        - The capital of India is New Delhi (not Mumbai)\n        - The capital of Nepal is Kathmandu\n        - The capital of Norway is Oslo\n        - The capital of Malaysia is Putrajaya\n        - The capital of Denmark is Copenhagen\n        - The capital of Nigeria is Abuja\n        - The capital of Germany is Berlin\n        - The capital of Gambia is Banjul (not Libreville)\n   - Compute all arithmetic expressions innermost first, showing steps. Round divisions to 2 decimal places. Respect operator precedence: parentheses → multiplication/division → addition/subtraction → comparisons.\n   - Create a reference table of computed values before logical evaluation.\n\n2. **Structured Evaluation**:\n   - Use a bottom-up approach: start from the innermost parentheses and work outward.\n   - Label sub-expressions (e.g., P1, P2) for tracking, especially when nesting depth exceeds 3 levels.\n   - For repeated `not` operations, simplify systematically:\n        - `not not X` = X\n        - `not not not X` = not X\n        - `not not not not X` = X\n        - etc.\n   - Apply logical operators with strict precedence: `not` > `and` > `or`.\n   - Short-circuit explicitly:\n        - If `False and ...` → immediately return False without computing `...`\n        - If `True or ...` → immediately return True without computing `...`\n        - Document: \"Short-circuit: False and ... → False\"\n\n3. **Step-by-Step Format**:\n   For each expression:\n   - **Step 1**: Precompute all facts and arithmetic\n   - **Step 2**: Evaluate logical operations from inner to outer, showing each simplification\n   - **Step 3**: Combine results, documenting all operations and short-circuiting opportunities\n\n4. **Verification**:\n   - After evaluating all expressions, verify that only one is True\n   - If multiple seem True, re-check in reverse order (E to A)\n   - Focus on expressions with:\n        - Deepest nesting levels\n        - Division operations or negative numbers\n        - Potential short-circuiting opportunities that were missed\n   - If still uncertain, re-check parentheses grouping using a counter method\n\n### Common Pitfalls to Avoid (with Examples):\n[Example 1: Expression A]\nIncorrect: Evaluated as True due to missing final `and (False)`\nCorrect: \"After evaluating inner expression as True, `True and False` → False, then `not(False)` → True\"\n\n[Example 2: Expression D]\nIncorrect: Overlooked short-circuiting in `False and ...` → False\nCorrect: \"Short-circuit: False and ... → False, making entire subexpression False\"\n\n[Example 3: Expression C]\nIncorrect: Miscomputed arithmetic: `-3 - (10/8) = -3 - 1.25 = -4.25 ≤ -4` → True\nCorrect: \"Arithmetic: -4.25 ≤ -4 → True (correctly computed)\"\n\n[Example 4: Expression E]\nIncorrect: Factual error - \"The capital of Jordan is Beirut\" → False (should be Amman)\nCorrect: \"Verified fact: Capital of Jordan is Amman → False statement\"\n\n### Final Checklist:\n- [ ] All facts verified against provided list\n- [ ] All arithmetic computed with proper rounding (2 decimals)\n- [ ] Parentheses counted and matched correctly\n- [ ] Short-circuiting applied where possible\n- [ ] Only one expression is True\n\nNow evaluate the following expressions. Show your reasoning step-by-step for each expression, and conclude with which one (A-E) is True.\n\n[The five expressions to be evaluated]",
                "Q": 0.25,
                "N": 0,
                "uct_value": 0.0,
                "reward": 0.25,
                "children": []
              }
            ]
          },
          {
            "id": 4,
            "depth": 2,
            "action_sequence": [
              "FailureDrivenAction",
              "FailureDrivenAction"
            ],
            "prompt": "You are an expert boolean expression evaluator. Your task is to determine which of five complex boolean expressions (A through E) evaluates to True. Only one expression is True.\n\n### Instructions:\n1. **Handle natural language statements**: All phrases like \"The capital of X is Y\" must be evaluated as True if factually correct, False otherwise. Use standard world knowledge (e.g., Capitals: Nigeria-Abuja, Cameroon-Yaoundé, Gambia-Banjul, UAE-Abu Dhabi, Norway-Oslo, Jordan-Amman, Belarus-Minsk, Germany-Berlin, India-New Delhi, Canada-Ottawa, Iran-Tehran, Turkey-Ankara, Denmark-Copenhagen, Azerbaijan-Baku).\n2. **Interpret comparisons**: Replace wordy phrases with symbols: \"is less than or equal to\" → ≤, \"is greater than\" → >, etc.\n3. **Evaluate arithmetic**: Compute all mathematical expressions carefully, respecting operator precedence. Recompute to avoid sign errors. Pay special attention to negative numbers and division.\n4. **Simplify step-by-step**:\n   - Start from the innermost parentheses\n   - Replace all facts and arithmetic with True/False\n   - Simplify all `not` chains: `not not X` = X, `not not not X` = `not X`, etc.\n   - Apply logical operators from inner to outer, with precedence: `not` > `and` > `or`\n5. **Count parentheses carefully**: For each expression, explicitly count opening and closing parentheses to ensure correct grouping. Consider rewriting the expression with proper indentation to visualize nesting.\n6. **Short-circuit wisely**: Only short-circuit if absolutely sure (e.g., `False and ...` = False, `True or ...` = True), but avoid overuse in complex nesting where parentheses might change meaning.\n7. **Verify your work**: \n   - Double-check arithmetic (especially `max`/`min` ranges and negative number operations)\n   - Verify all facts against standard knowledge\n   - If multiple expressions seem True, re-check for errors in grouping, arithmetic, or facts\n\n### Common pitfalls to avoid:\n- Misgrouping due to complex nesting: Count parentheses carefully and diagram if needed\n- Arithmetic sign errors: Double-check negative number operations and comparisons\n- Factual errors: Recall capitals correctly using standard knowledge\n- Don't forget: `not not X` = X, `not not not X` = `not X`\n- \"max(a,b,c,d) - min(a,b,c,d)\" computes the range (difference between largest and smallest)\n- Avoid early short-circuiting in complex nested expressions\n\n### Critical Examples for Reference:\n[Example 1: Expression Evaluation]\nIncorrect: Failed to properly group `and (False)` at the end\nCorrect: The entire expression before `and (False)` was True, making `True and False` = False, then `not(False)` = True\n\n[Example 2: Factual Error]\nIncorrect: \"The capital of Canada is Toronto\" evaluated as True\nCorrect: \"The capital of Canada is Ottawa\" - Toronto is False\n\n[Example 3: Range Calculation]\nIncorrect: max(10, -3, -2, -1) = 10, min = -3, range = 13. 13 > 3 is True.\nCorrect: Always recompute range carefully: max(10, -3, -2, -1) = 10, min = -3, range = 13\n\n[Example 4: Not Chain Simplification]\nIncorrect: `not not not True` evaluated as True\nCorrect: `not not not True` = `not not False` = `not True` = False\n\n[Example 5: Parentheses Grouping]\nIncorrect: Misparsed `not (A and B) and C` as `(not A) and B and C`\nCorrect: `not (A and B) and C` means first evaluate `A and B`, then apply `not`, then `and C`\n\nNow evaluate the following expressions. Show your reasoning step-by-step for each expression, and conclude with which one (A-E) is True.",
            "Q": 0.25,
            "N": 0,
            "uct_value": 0.003346415497614626,
            "reward": 0.25,
            "children": []
          }
        ]
      },
      {
        "id": 2,
        "depth": 1,
        "action_sequence": [
          "FailureDrivenAction"
        ],
        "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), only one evaluates to True. Each expression contains arithmetic operations, comparisons, logical operators (`not`, `and`, `or`), and factual statements about world capitals.\n\n### Step-by-Step Evaluation Instructions:\n1. **Break Down Expressions**: Deconstruct each expression into its smallest sub-expressions. Evaluate innermost components first (arithmetic, comparisons, factual statements).\n2. **Handle Factual Statements**: Treat phrases like \"The capital of X is Y\" as boolean values. Use this reference:\n   - Norway: Oslo (not Bergen)\n   - Denmark: Copenhagen\n   - Iran: Tehran\n   - Germany: Berlin\n   - Turkey: Ankara (not Istanbul)\n   - Afghanistan: Kabul\n   - Nepal: Kathmandu (not Pokhara)\n   - Belarus: Minsk (not Grodno)\n   - UAE: Abu Dhabi\n   - Cameroon: Yaoundé (not Douala)\n   - Armenia: Yerevan\n   - India: New Delhi\n3. **Simplify `not` Chains**: \n   - `not not X` = `X`\n   - `not not not X` = `not X`\n   - An even number of `not`s cancels; an odd number flips the value.\n4. **Compute Arithmetic Precisely**: Pay close attention to negative numbers and division. For example:\n   - `-3 * -3 = 9`\n   - `1 - (8 / -4) = 1 - (-2) = 3`\n5. **Respect Logical Precedence**: `and` has higher precedence than `or`. Use parentheses to disambiguate if needed.\n6. **Verify Consistency**: If multiple expressions seem True, re-check your work—only one is correct. Common pitfalls include:\n   - Miscounting `not` operations\n   - Miscomputing arithmetic (e.g., negative signs)\n   - Misinterpreting factual statements\n   - Misapplying operator precedence\n\n### Examples of Common Mistakes to Avoid:\n- **Example 2 Error**: In expression (B), ensure `not not not (False)` simplifies to `True`, but verify the inner expression is indeed `False`. In (D), double-check arithmetic like `9 - (9 / -5) = 10.8` (not ≤ -2).\n- **Example 4 Error**: In expression (C), avoid missing that `-4 * 4 + -7 * -3 = 5` (not ≤ -16). In (E), ensure `2 - (-2 / 8) = 2.25` (not > 5).\n\n### Output Requirement:\nAfter evaluation, output the letter (A-E) of the True expression. Show no other text.\n\nNow, evaluate the following expressions carefully:",
        "Q": 2.8000000000000003,
        "N": 6,
        "uct_value": 0.4709169272585082,
        "reward": 0.45,
        "children": [
          {
            "id": 3,
            "depth": 2,
            "action_sequence": [
              "FailureDrivenAction",
              "FailureDrivenAction"
            ],
            "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), only one evaluates to True. Each expression contains arithmetic operations, comparisons, logical operators (`not`, `and`, `or`), and factual statements about world capitals.\n\n### Step-by-Step Evaluation Instructions:\n1. **Reformat and Annotate**: First, reformat the expression with indentation and parentheses to visualize nesting. Label each sub-expression for reference.\n2. **Compute Arithmetic Precisely**: Use a calculator for all arithmetic. Handle negatives and division carefully. Record intermediate values.\n   - Example: `-3 * -3 = 9`, `1 - (8 / -4) = 1 - (-2) = 3`\n3. **Evaluate Factual Statements**: Use this reference:\n   - Norway: Oslo (not Bergen)\n   - Denmark: Copenhagen\n   - Iran: Tehran\n   - Germany: Berlin\n   - Turkey: Ankara (not Istanbul)\n   - Afghanistan: Kabul\n   - Nepal: Kathmandu (not Pokhara)\n   - Belarus: Minsk (not Grodno)\n   - UAE: Abu Dhabi\n   - Cameroon: Yaoundé (not Douala)\n   - Armenia: Yerevan\n   - India: New Delhi\n   - Azerbaijan: Baku (not Ganja)\n   - Nigeria: Abuja (not Lagos)\n   - Colombia: Bogotá (not Medellin)\n4. **Simplify `not` Chains First**: \n   - `not not X` = `X`\n   - `not not not X` = `not X`\n   - Simplify all `not` chains before evaluating logical operators.\n5. **Evaluate Innermost Sub-Expressions**: Start from the innermost components (arithmetic, comparisons, factuals). Replace each sub-expression with its boolean value (True/False) as you go.\n6. **Respect Logical Precedence**: `and` has higher precedence than `or`. Use parentheses to disambiguate if needed.\n7. **Store Intermediate Results**: Avoid recomputation. For repeated sub-expressions (e.g., `max-min`), compute once and reuse.\n8. **Consistency Check**: After evaluating all expressions, if more than one seems True, re-check the candidates' arithmetic and `not` chains.\n\n### Common Mistakes to Avoid (with Examples):\n- **Miscounting `not` Operations**: \n  - Example: `not not not True` = `not True` = False, not True.\n- **Miscomputing Arithmetic**:\n  - Example: `9 - (9 / -5) = 9 - (-1.8) = 10.8` (not ≤ -2).\n- **Misinterpreting Factual Statements**:\n  - Example: \"The capital of Norway is Bergen\" is False.\n- **Misapplying Operator Precedence**:\n  - Example: `A and B or C` is `(A and B) or C`, not `A and (B or C)`.\n\n### Few-Shot Examples:\n#### Example 1:\n**Input**: Expressions (A) to (E) with deep nesting.\n**Mistake**: Model initially evaluated (B) as True due to `not` chain error.\n**Correction**: After re-checking, (D) was True.\n**Lesson**: Always simplify `not` chains before combining with other operators.\n\n#### Example 2:\n**Input**: Expressions with mixed arithmetic and factuals.\n**Mistake**: Model misparsed structure in (A), leading to false True.\n**Correction**: Reformatted with indentation; found (E) True.\n**Lesson**: Reformat expressions to clarify nesting.\n\n### Output Requirement:\nAfter evaluation, output only the letter (A-E) of the True expression. Show no other text.\n\nNow, evaluate the following expressions carefully. Follow the steps strictly:\n\n[Insert Expressions Here]",
            "Q": 2.25,
            "N": 5,
            "uct_value": 0.47834640880480367,
            "reward": 0.35,
            "children": [
              {
                "id": 4,
                "depth": 3,
                "action_sequence": [
                  "FailureDrivenAction",
                  "FailureDrivenAction",
                  "FailureDrivenAction"
                ],
                "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), only one evaluates to True. Each expression contains arithmetic operations, comparisons, logical operators (`not`, `and`, `or`), and factual statements about world capitals.\n\n### Step-by-Step Evaluation Instructions:\n1. **Reformat and Annotate**: First, reformat the expression with explicit parentheses and indentation (2 spaces per nesting level) to visualize nesting. Label each sub-expression (e.g., S1, S2) for reference.\n2. **Compute Arithmetic Precisely**: Use exact fractions or high-precision decimals for all arithmetic. Handle negatives and division carefully. Record intermediate values.\n   - Example: `-3 * -3 = 9`, `1 - (8 / -4) = 1 - (-2) = 3`, `6/9 = 0.666...`\n3. **Evaluate Factual Statements**: Use this expanded reference:\n   - Norway: Oslo\n   - Denmark: Copenhagen\n   - Iran: Tehran\n   - Germany: Berlin\n   - Turkey: Ankara\n   - Afghanistan: Kabul\n   - Nepal: Kathmandu\n   - Belarus: Minsk\n   - UAE: Abu Dhabi\n   - Cameroon: Yaoundé\n   - Armenia: Yerevan\n   - India: New Delhi\n   - Azerbaijan: Baku\n   - Nigeria: Abuja\n   - Colombia: Bogotá\n   - Gambia: Banjul\n   - Malaysia: Putrajaya\n   - Jordan: Amman\n   - For any country not listed, assume the capital statement is False.\n4. **Simplify `not` Chains Recursively**: \n   - For any chain of `k` `not` operations: if `k` is even, it simplifies to `X`; if `k` is odd, it simplifies to `not X`.\n   - Start from the innermost expression and work outward.\n   - Example: `not not not not True` = `True`, `not not not True` = `not True` = False.\n5. **Evaluate Innermost Sub-Expressions First**: Start from the innermost components (arithmetic, comparisons, factuals). Replace each sub-expression with its boolean value (True/False) as you go.\n6. **Respect Logical Precedence**: `and` has higher precedence than `or`. Use parentheses to disambiguate if needed.\n7. **Store Intermediate Results**: Avoid recomputation. For repeated sub-expressions, compute once and reuse the result.\n8. **Full Evaluation Mandatory**: You must evaluate all five expressions completely before deciding which one is True. Do not stop early.\n9. **Consistency Check**: After evaluating all expressions, if more than one seems True, re-check the arithmetic and `not` chains of the True candidates.\n\n### Common Mistakes to Avoid (with Examples):\n- **Miscounting Long `not` Chains**: \n  - Example: `not not not not True` = True (not False).\n- **Miscomputing Arithmetic**:\n  - Example: `9 - (9 / -5) = 9 - (-1.8) = 10.8` (not ≤ -2).\n- **Misinterpreting Factual Statements**:\n  - Example: \"The capital of Norway is Bergen\" is False.\n  - Example: \"The capital of Gambia is Libreville\" is False (correct is Banjul).\n- **Misapplying Operator Precedence**:\n  - Example: `A and B or C` is `(A and B) or C`, not `A and (B or C)`.\n- **Early Termination**:\n  - Example: Even if you find a True expression, you must evaluate all others to ensure only one is True.\n\n### Few-Shot Examples:\n#### Example 1:\n**Input**: Expression with deep nesting and `not` chains.\n**Mistake**: Model initially evaluated (B) as True due to `not` chain error.\n**Correction**: After re-checking, (D) was True.\n**Lesson**: Always simplify `not` chains recursively from the inside out.\n\n#### Example 2:\n**Input**: Expressions with mixed arithmetic and factuals.\n**Mistake**: Model misparsed structure in (A), leading to false True.\n**Correction**: Reformatted with explicit parentheses; found (E) True.\n**Lesson**: Reformat expressions to clarify nesting.\n\n#### Example 3 (New):\n**Input**: `not not not not (True)`\n**Evaluation**: Innermost: `not not not not True` = `True` (since 4 is even).\n**Output**: True\n\n#### Example 4 (New):\n**Input**: `(The capital of Wonderland is Wondercity) and (5/3 > 1)`\n**Evaluation**: \"Wonderland\" not in reference → False. `5/3 ≈ 1.666 > 1` → True. `False and True` → False.\n**Output**: False\n\n### Output Requirement:\nAfter evaluation, output only the letter (A-E) of the True expression. Show no other text.\n\nNow, evaluate the following expressions carefully. Follow the steps strictly:\n\n[Insert Expressions Here]",
                "Q": 2.25,
                "N": 5,
                "uct_value": 0.4781715842597866,
                "reward": 0.35,
                "children": [
                  {
                    "id": 5,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), only one evaluates to True. Each expression contains arithmetic operations, comparisons, logical operators (`not`, `and`, `or`), and factual statements about world capitals.\n\n### Step-by-Step Evaluation Instructions:\n1. **Reformat and Annotate**: Before evaluation, output the fully reformatted expression with explicit parentheses and indentation (2 spaces per nesting level) to visualize nesting. Label each sub-expression (e.g., S1, S2) for reference. This is mandatory to avoid parsing errors.\n2. **Compute Arithmetic Precisely**: Use exact fractions for all arithmetic. Do not use decimals. Handle negatives and division carefully. Record intermediate values.\n   - Example: `-3 * -3 = 9`, `1 - (8 / -4) = 1 - (-2) = 3`, `6/9 = 2/3`\n3. **Evaluate Factual Statements**: Use this expanded reference. For any country not listed, assume the capital statement is False (even if factually correct).\n   - Norway: Oslo\n   - Denmark: Copenhagen\n   - Iran: Tehran\n   - Germany: Berlin\n   - Turkey: Ankara\n   - Afghanistan: Kabul\n   - Nepal: Kathmandu\n   - Belarus: Minsk\n   - UAE: Abu Dhabi\n   - Cameroon: Yaoundé\n   - Armenia: Yerevan\n   - India: New Delhi\n   - Azerbaijan: Baku\n   - Nigeria: Abuja\n   - Colombia: Bogotá\n   - Gambia: Banjul\n   - Malaysia: Putrajaya\n   - Jordan: Amman\n4. **Simplify `not` Chains Recursively**: \n   - For any chain of `k` `not` operations: if `k` is even, it simplifies to `X`; if `k` is odd, it simplifies to `not X`.\n   - Start from the innermost expression and work outward. For each chain, state `k` and the simplification step.\n5. **Evaluate Innermost Sub-Expressions First**: Start from the innermost components (arithmetic, comparisons, factuals). Replace each sub-expression with its boolean value (True/False) as you go. Output intermediate results.\n6. **Respect Logical Precedence**: `and` has higher precedence than `or`. Use parentheses to disambiguate if needed.\n7. **Store Intermediate Results**: Avoid recomputation. For repeated sub-expressions, compute once and reuse the result.\n8. **Full Evaluation Mandatory**: You must evaluate all five expressions completely before deciding which one is True. Do not stop early under any circumstances.\n9. **Consistency Check**: After evaluating all expressions, if more than one seems True, re-check the arithmetic and `not` chains of the True candidates with heightened scrutiny.\n\n### Common Mistakes to Avoid (with Examples):\n- **Miscounting Long `not` Chains**: \n  - Example: `not not not not True` = True (4 `not`s, even).\n  - Example: `not not not True` = not True = False (3 `not`s, odd).\n- **Miscomputing Arithmetic**:\n  - Example: `9 - (9 / -5) = 9 - (-1.8) = 10.8` (not ≤ -2).\n- **Misinterpreting Factual Statements**:\n  - Example: \"The capital of Norway is Bergen\" is False.\n  - Example: \"The capital of Canada is Ottawa\" is False (Canada not in reference).\n- **Misapplying Operator Precedence**:\n  - Example: `A and B or C` is `(A and B) or C`, not `A and (B or C)`.\n- **Early Termination**:\n  - Example: Even if you find a True expression, you must evaluate all others to ensure only one is True.\n\n### Few-Shot Examples with Common Failures:\n#### Example 1 (Failure Case):\n**Input**: Expression with deep nesting and `not` chains.\n**Mistake**: Model evaluated (B) as True due to miscounting `not` chain.\n**Correction**: After recursive simplification from inside out, (D) was True.\n**Lesson**: Always simplify `not` chains recursively and count `k` carefully.\n\n#### Example 2 (Failure Case):\n**Input**: Expressions with mixed arithmetic and factuals.\n**Mistake**: Model misparsed structure in (A) due to ambiguous parentheses.\n**Correction**: Reformatted with explicit parentheses; found (E) True.\n**Lesson**: Reformat expressions with labels to avoid parsing errors.\n\n#### Example 3 (New):\n**Input**: `not not not not (True)`\n**Evaluation**: Innermost: `True`. Chain: 4 `not`s (even) → `True`.\n**Output**: True\n\n#### Example 4 (New):\n**Input**: `(The capital of Wonderland is Wondercity) and (5/3 > 1)`\n**Evaluation**: \"Wonderland\" not in reference → False. `5/3 ≈ 1.666 > 1` → True. `False and True` → False.\n**Output**: False\n\n#### Example 5 (New, Critical):\n**Input**: Expression containing \"The capital of Canada is Ottawa\"\n**Evaluation**: Canada not in reference → False. Even though Ottawa is correct, the statement is False.\n**Output**: False\n\n### Output Requirement:\nAfter evaluation, output only the letter (A-E) of the True expression. Show no other text.\n\nNow, evaluate the following expressions carefully. Follow the steps strictly:\n\n[Insert Expressions Here]",
                    "Q": 1.2,
                    "N": 2,
                    "uct_value": 0.8531715890171546,
                    "reward": 0.35,
                    "children": [
                      {
                        "id": 6,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), only one evaluates to True. Each expression contains arithmetic operations, comparisons, logical operators (`not`, `and`, `or`), and factual statements about world capitals.\n\n### Step-by-Step Evaluation Instructions:\n1. **Reformat and Annotate**: Before evaluation, output the fully reformatted expression with explicit parentheses and indentation (2 spaces per nesting level) to visualize nesting. Label each sub-expression (e.g., S1, S2) for reference. This is mandatory to avoid parsing errors.\n2. **Compute Arithmetic Precisely**: Use exact fractions for all arithmetic. Do not use decimals. Handle negatives and division carefully. Record intermediate values.\n   - Example: `-3 * -3 = 9`, `1 - (8 / -4) = 1 - (-2) = 3`, `6/9 = 2/3`\n3. **Evaluate Factual Statements**: Use this expanded reference. For any country not listed, assume the capital statement is False (even if factually correct). For listed countries, the capital must match exactly (case-insensitive and ignoring accents).\n   - Norway: Oslo\n   - Denmark: Copenhagen\n   - Iran: Tehran\n   - Germany: Berlin\n   - Turkey: Ankara\n   - Afghanistan: Kabul\n   - Nepal: Kathmandu\n   - Belarus: Minsk\n   - UAE: Abu Dhabi\n   - Cameroon: Yaoundé\n   - Armenia: Yerevan\n   - India: New Delhi\n   - Azerbaijan: Baku\n   - Nigeria: Abuja\n   - Colombia: Bogotá\n   - Gambia: Banjul\n   - Malaysia: Putrajaya\n   - Jordan: Amman\n   - Canada: Ottawa (added to prevent ambiguity)\n4. **Simplify `not` Chains Recursively**: \n   - For any chain of `k` `not` operations: if `k` is even, it simplifies to `X`; if `k` is odd, it simplifies to `not X`.\n   - Start from the innermost expression and work outward. For each chain, state `k` and the simplification step.\n5. **Evaluate Innermost Sub-Expressions First**: Start from the innermost components (arithmetic, comparisons, factuals). Replace each sub-expression with its boolean value (True/False) as you go. Output intermediate results.\n6. **Respect Logical Precedence**: `and` has higher precedence than `or`. Use parentheses to disambiguate if needed. For same-level operators, evaluate left to right.\n7. **Store Intermediate Results**: Avoid recomputation. For repeated sub-expressions, compute once and reuse the result.\n8. **Full Evaluation Mandatory**: You must evaluate all five expressions completely before deciding which one is True. Do not stop early under any circumstances.\n9. **Consistency Check**: After evaluating all expressions, if more than one seems True, re-check the arithmetic and `not` chains of the True candidates with heightened scrutiny.\n\n### Common Mistakes to Avoid (with Examples):\n- **Miscounting Long `not` Chains**: \n  - Example: `not not not not True` = True (4 `not`s, even).\n  - Example: `not not not True` = not True = False (3 `not`s, odd).\n- **Miscomputing Arithmetic**:\n  - Example: `9 - (9 / -5) = 9 - (-9/5) = 9 + 9/5 = 54/5 = 10.8` (not ≤ -2).\n- **Misinterpreting Factual Statements**:\n  - Example: \"The capital of Norway is Bergen\" is False.\n  - Example: \"The capital of Canada is Ottawa\" is True (Canada now in reference).\n  - Example: \"The capital of Colombia is Bogota\" is True (ignoring accents).\n- **Misapplying Operator Precedence**:\n  - Example: `A and B or C` is `(A and B) or C`, not `A and (B or C)`.\n- **Early Termination**:\n  - Example: Even if you find a True expression, you must evaluate all others to ensure only one is True.\n\n### Few-Shot Examples with Common Failures:\n#### Example 1 (Failure Case):\n**Input**: Expression with deep nesting and `not` chains.\n**Mistake**: Model evaluated (B) as True due to miscounting `not` chain.\n**Correction**: After recursive simplification from inside out, (D) was True.\n**Lesson**: Always simplify `not` chains recursively and count `k` carefully.\n\n#### Example 2 (Failure Case):\n**Input**: Expressions with mixed arithmetic and factuals.\n**Mistake**: Model misparsed structure in (A) due to ambiguous parentheses.\n**Correction**: Reformatted with explicit parentheses; found (E) True.\n**Lesson**: Reformat expressions with labels to avoid parsing errors.\n\n#### Example 3 (New):\n**Input**: `not not not not (True)`\n**Evaluation**: Innermost: `True`. Chain: 4 `not`s (even) → `True`.\n**Output**: True\n\n#### Example 4 (New):\n**Input**: `(The capital of Wonderland is Wondercity) and (5/3 > 1)`\n**Evaluation**: \"Wonderland\" not in reference → False. `5/3 > 1` → True. `False and True` → False.\n**Output**: False\n\n#### Example 5 (New, Critical):\n**Input**: Expression containing \"The capital of Colombia is Bogota\"\n**Evaluation**: Colombia is in reference; \"Bogota\" matches \"Bogotá\" (ignoring accents) → True.\n**Output**: True\n\n#### Example 6 (New, Critical):\n**Input**: `not not not (max(1, -5, -6, -7) - min(1, -5, -6, -7) > 10)`\n**Evaluation**: max = 1, min = -7, diff = 8. 8 > 10 → False. Then `not not not False` → 3 `not`s (odd) → `not False` → True.\n**Output**: True\n\n### Output Requirement:\nAfter evaluation, output only the letter (A-E) of the True expression. Show no other text.\n\nNow, evaluate the following expressions carefully. Follow the steps strictly:\n\n[Insert Expressions Here]",
                        "Q": 0.7,
                        "N": 1,
                        "uct_value": 0.002081386527894244,
                        "reward": 0.35,
                        "children": []
                      },
                      {
                        "id": 7,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), only one evaluates to True. Each expression contains arithmetic operations, comparisons, logical operators (`not`, `and`, `or`), and factual statements about world capitals.\n\n### Step-by-Step Evaluation Instructions:\n1. **Reformat and Annotate**: Before evaluation, output the fully reformatted expression with explicit parentheses and indentation (2 spaces per nesting level) to visualize nesting. Label each sub-expression (e.g., S1, S2) for reference. This is mandatory to avoid parsing errors.\n2. **Compute Arithmetic Precisely**: Use exact fractions for all arithmetic. Do not use decimals. Handle negatives and division carefully. Record intermediate values.\n   - Example: `-3 * -3 = 9`, `1 - (8 / -4) = 1 - (-2) = 3`, `6/9 = 2/3`\n3. **Evaluate Factual Statements**: Use this expanded reference. For any country not listed, assume the capital statement is False (even if factually correct).\n   - Norway: Oslo\n   - Denmark: Copenhagen\n   - Iran: Tehran\n   - Germany: Berlin\n   - Turkey: Ankara\n   - Afghanistan: Kabul\n   - Nepal: Kathmandu\n   - Belarus: Minsk\n   - UAE: Abu Dhabi\n   - Cameroon: Yaoundé\n   - Armenia: Yerevan\n   - India: New Delhi\n   - Azerbaijan: Baku\n   - Nigeria: Abuja\n   - Colombia: Bogotá\n   - Gambia: Banjul\n   - Malaysia: Putrajaya\n   - Jordan: Amman\n4. **Simplify `not` Chains Recursively**: \n   - For any chain of `k` `not` operations: if `k` is even, it simplifies to `X`; if `k` is odd, it simplifies to `not X`.\n   - Start from the innermost expression and work outward. For each chain, state `k` and the simplification step.\n5. **Evaluate Innermost Sub-Expressions First**: Start from the innermost components (arithmetic, comparisons, factuals). Replace each sub-expression with its boolean value (True/False) as you go. Output intermediate results.\n6. **Respect Logical Precedence**: `and` has higher precedence than `or`. Use parentheses to disambiguate if needed.\n7. **Store Intermediate Results**: Avoid recomputation. For repeated sub-expressions, compute once and reuse the result.\n8. **Full Evaluation Mandatory**: You must evaluate all five expressions completely before deciding which one is True. Do not stop early under any circumstances.\n9. **Consistency Check**: After evaluating all expressions, if more than one seems True, re-check the arithmetic and `not` chains of the True candidates with heightened scrutiny.\n\n### Common Mistakes to Avoid (with Examples):\n- **Miscounting Long `not` Chains**: \n  - Example: `not not not not True` = True (4 `not`s, even).\n  - Example: `not not not True` = not True = False (3 `not`s, odd).\n- **Miscomputing Arithmetic**:\n  - Example: `9 - (9 / -5) = 9 - (-1.8) = 10.8` (not ≤ -2).\n- **Misinterpreting Factual Statements**:\n  - Example: \"The capital of Norway is Bergen\" is False.\n  - Example: \"The capital of Canada is Ottawa\" is False (Canada not in reference).\n- **Misapplying Operator Precedence**:\n  - Example: `A and B or C` is `(A and B) or C`, not `A and (B or C)`.\n- **Early Termination**:\n  - Example: Even if you find a True expression, you must evaluate all others to ensure only one is True.\n\n### Few-Shot Examples with Common Failures:\n#### Example 1 (Failure Case):\n**Input**: Expression with deep nesting and `not` chains.\n**Mistake**: Model evaluated (B) as True due to miscounting `not` chain.\n**Correction**: After recursive simplification from inside out, (D) was True.\n**Lesson**: Always simplify `not` chains recursively and count `k` carefully.\n\n#### Example 2 (Failure Case):\n**Input**: Expressions with mixed arithmetic and factuals.\n**Mistake**: Model misparsed structure in (A) due to ambiguous parentheses.\n**Correction**: Reformatted with explicit parentheses; found (E) True.\n**Lesson**: Reformat expressions with labels to avoid parsing errors.\n\n#### Example 3 (New):\n**Input**: `not not not not (True)`\n**Evaluation**: Innermost: `True`. Chain: 4 `not`s (even) → `True`.\n**Output**: True\n\n#### Example 4 (New):\n**Input**: `(The capital of Wonderland is Wondercity) and (5/3 > 1)`\n**Evaluation**: \"Wonderland\" not in reference → False. `5/3 ≈ 1.666 > 1` → True. `False and True` → False.\n**Output**: False\n\n#### Example 5 (New, Critical):\n**Input**: Expression containing \"The capital of Canada is Ottawa\"\n**Evaluation**: Canada not in reference → False. Even though Ottawa is correct, the statement is False.\n**Output**: False\n\n### Output Requirement:\nAfter evaluation, output only the letter (A-E) of the True expression. Show no other text.\n\nNow, evaluate the following expressions carefully. Follow the steps strictly:\n\n[Insert Expressions Here]",
                        "Q": 0.5,
                        "N": 0,
                        "uct_value": 0.002081386527894244,
                        "reward": 0.5,
                        "children": []
                      },
                      {
                        "id": 8,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), only one evaluates to True. Each expression contains arithmetic operations, comparisons, logical operators (`not`, `and`, `or`), and factual statements about world capitals.\n\n### Step-by-Step Evaluation Instructions:\n1. **Reformat and Annotate**: Before evaluation, output the fully reformatted expression with explicit parentheses and indentation (2 spaces per nesting level) to visualize nesting. Label each sub-expression (e.g., S1, S2) for reference. This is mandatory to avoid parsing errors. For expressions with >5 nesting levels, create a hierarchical outline (e.g., S1.1, S1.2).\n2. **Compute Arithmetic Precisely**: Use exact fractions for all arithmetic. Do not use decimals. Handle negatives and division carefully. Record intermediate values.\n   - Example: `-3 * -3 = 9`, `1 - (8 / -4) = 1 - (-2) = 3`, `6/9 = 2/3`\n3. **Evaluate Factual Statements**: Use this expanded reference. For any country not listed, assume the capital statement is False (even if factually correct). For listed countries, the statement is True only if the capital matches exactly.\n   - Norway: Oslo\n   - Denmark: Copenhagen\n   - Iran: Tehran\n   - Germany: Berlin\n   - Turkey: Ankara\n   - Afghanistan: Kabul\n   - Nepal: Kathmandu\n   - Belarus: Minsk\n   - UAE: Abu Dhabi\n   - Cameroon: Yaoundé\n   - Armenia: Yerevan\n   - India: New Delhi\n   - Azerbaijan: Baku\n   - Nigeria: Abuja\n   - Colombia: Bogotá\n   - Gambia: Banjul\n   - Malaysia: Putrajaya\n   - Jordan: Amman\n   - Iraq: Baghdad\n   - Canada: Ottawa (but not in reference → always False)\n4. **Simplify `not` Chains Recursively**: \n   - For any chain of `k` `not` operations: if `k` is even, it simplifies to `X`; if `k` is odd, it simplifies to `not X`.\n   - Start from the innermost expression and work outward. For each chain, state `k` and the simplification step.\n   - For chains with k > 3, double-check the count and show work.\n5. **Evaluate Innermost Sub-Expressions First**: Start from the innermost components (arithmetic, comparisons, factuals). Replace each sub-expression with its boolean value (True/False) as you go. Output intermediate results in a structured list.\n6. **Respect Logical Precedence**: `and` has higher precedence than `or`. Use parentheses to disambiguate if needed. In reformatting, make precedence explicit.\n7. **Store Intermediate Results**: Avoid recomputation. For repeated sub-expressions, compute once and reuse the result.\n8. **Full Evaluation Mandatory**: You must evaluate all five expressions completely before deciding which one is True. Do not stop early under any circumstances.\n9. **Consistency Check**: After evaluating all expressions, if more than one seems True, re-check in this order:\n   - Expressions with the longest `not` chains\n   - Expressions with complex arithmetic (multiple operations)\n   - Expressions with factual statements not in the reference\n   - Re-check with heightened scrutiny, focusing on arithmetic fractions and `not` counts.\n\n### Common Mistakes to Avoid (with Examples):\n- **Miscounting Long `not` Chains**: \n  - Example: `not not not not True` = True (4 `not`s, even). \n  - Example: `not not not not not True` = not True = False (5 `not`s, odd).\n- **Miscomputing Arithmetic**:\n  - Example: `9 - (9 / -5) = 9 - (-9/5) = 9 + 9/5 = 54/5 = 10.8` (not ≤ -2).\n- **Misinterpreting Factual Statements**:\n  - Example: \"The capital of Norway is Bergen\" is False.\n  - Example: \"The capital of Canada is Ottawa\" is False (Canada not in reference).\n  - Example: \"The capital of Azerbaijan is Ganja\" is False (correct is Baku).\n- **Misapplying Operator Precedence**:\n  - Example: `A and B or C` is `(A and B) or C`, not `A and (B or C)`.\n- **Early Termination**:\n  - Example: Even if you find a True expression, you must evaluate all others to ensure only one is True.\n\n### Few-Shot Examples with Common Failures:\n#### Example 1 (Failure Case):\n**Input**: Expression with deep nesting and `not` chains.\n**Mistake**: Model evaluated (B) as True due to miscounting `not` chain (k=5 treated as k=3).\n**Correction**: After recursive simplification from inside out, (D) was True.\n**Lesson**: Always simplify `not` chains recursively and count `k` carefully, especially for k>3.\n\n#### Example 2 (Failure Case):\n**Input**: Expressions with mixed arithmetic and factuals.\n**Mistake**: Model misparsed structure in (A) due to ambiguous parentheses.\n**Correction**: Reformatted with explicit parentheses; found (E) True.\n**Lesson**: Reformat expressions with labels to avoid parsing errors.\n\n#### Example 3 (New, Critical):\n**Input**: `not not not not not (True)`\n**Evaluation**: Innermost: `True`. Chain: 5 `not`s (odd) → not not not not not True = not not not not False = not not not True = not not False = not True = False.\n**Output**: False\n\n#### Example 4 (New, Critical):\n**Input**: `(The capital of Iraq is Baghdad) and (5/3 > 1)`\n**Evaluation**: \"Iraq\" not in reference → False. `5/3 > 1` → True. `False and True` → False.\n**Output**: False\n\n#### Example 5 (New, Critical):\n**Input**: Expression with `max(3, -3, -9, 3) - min(3, -3, -9, 3) > 7` and long `not` chain.\n**Evaluation**: max=3, min=-9, diff=12 > 7 → True. Then handle `not` chain: e.g., `not not not True` = False.\n**Lesson**: Compute arithmetic and comparisons first, then apply `not` chains.\n\n### Output Requirement:\nAfter evaluation, output only the letter (A-E) of the True expression. Show no other text.\n\nNow, evaluate the following expressions carefully. Follow the steps strictly:\n\n[Insert Expressions Here]",
                        "Q": 0.2,
                        "N": 0,
                        "uct_value": 0.002081386527894244,
                        "reward": 0.2,
                        "children": []
                      }
                    ]
                  },
                  {
                    "id": 6,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), only one evaluates to True. Each expression contains arithmetic operations, comparisons, logical operators (`not`, `and`, `or`), and factual statements about world capitals.\n\n### Step-by-Step Evaluation Instructions:\n1. **Reformat and Annotate**: First, reformat the expression with explicit parentheses and indentation (2 spaces per nesting level) to visualize nesting. Label each sub-expression (e.g., S1, S2) for reference.\n2. **Compute Arithmetic Precisely**: Use exact fractions or high-precision decimals for all arithmetic. Handle negatives and division carefully. Record intermediate values.\n   - Example: `-3 * -3 = 9`, `1 - (8 / -4) = 1 - (-2) = 3`, `6/9 = 0.666...`\n3. **Evaluate Factual Statements**: Use this expanded reference:\n   - Norway: Oslo\n   - Denmark: Copenhagen\n   - Iran: Tehran\n   - Germany: Berlin\n   - Turkey: Ankara\n   - Afghanistan: Kabul\n   - Nepal: Kathmandu\n   - Belarus: Minsk\n   - UAE: Abu Dhabi\n   - Cameroon: Yaoundé\n   - Armenia: Yerevan\n   - India: New Delhi\n   - Azerbaijan: Baku\n   - Nigeria: Abuja\n   - Colombia: Bogotá\n   - Gambia: Banjul\n   - Malaysia: Putrajaya\n   - Jordan: Amman\n   - Canada: Ottawa\n   - Iraq: Baghdad\n   - For any country not listed, assume the capital statement is False.\n4. **Simplify `not` Chains Recursively**: \n   - For any chain of `k` `not` operations: if `k` is even, it simplifies to `X`; if `k` is odd, it simplifies to `not X`.\n   - Start from the innermost expression and work outward.\n   - Example: `not not not not True` = `True`, `not not not True` = `not True` = False.\n5. **Evaluate Innermost Sub-Expressions First**: Start from the innermost components (arithmetic, comparisons, factuals). Replace each sub-expression with its boolean value (True/False) as you go.\n6. **Respect Logical Precedence**: `and` has higher precedence than `or`. Use parentheses to disambiguate if needed.\n7. **Store Intermediate Results**: Avoid recomputation. For repeated sub-expressions, compute once and reuse the result.\n8. **Full Evaluation Mandatory**: You must evaluate all five expressions completely before deciding which one is True. Do not stop early.\n9. **Consistency Check**: After evaluating all expressions, if more than one seems True, re-check the arithmetic and `not` chains of the True candidates. If still multiple True, identify the source of error.\n\n### Common Mistakes to Avoid (with Examples):\n- **Miscounting Long `not` Chains**: \n  - Example: `not not not not True` = True (not False).\n- **Miscomputing Arithmetic**:\n  - Example: `9 - (9 / -5) = 9 - (-1.8) = 10.8` (not ≤ -2).\n- **Misinterpreting Factual Statements**:\n  - Example: \"The capital of Norway is Bergen\" is False.\n  - Example: \"The capital of Gambia is Libreville\" is False (correct is Banjul).\n- **Misapplying Operator Precedence**:\n  - Example: `A and B or C` is `(A and B) or C`, not `A and (B or C)`.\n- **Early Termination**:\n  - Example: Even if you find a True expression, you must evaluate all others to ensure only one is True.\n\n### Few-Shot Examples with Common Errors:\n#### Example 1:\n**Input**: Expression with deep nesting and `not` chains.\n**Mistake**: Model initially evaluated (B) as True due to `not` chain error.\n**Correction**: After re-checking, (D) was True.\n**Lesson**: Always simplify `not` chains recursively from the inside out.\n\n#### Example 2:\n**Input**: Expressions with mixed arithmetic and factuals.\n**Mistake**: Model misparsed structure in (A), leading to false True.\n**Correction**: Reformatted with explicit parentheses; found (E) True.\n**Lesson**: Reformat expressions to clarify nesting.\n\n#### Example 3 (New):\n**Input**: `not not not not (True)`\n**Evaluation**: Innermost: `not not not not True` = `True` (since 4 is even).\n**Output**: True\n\n#### Example 4 (New):\n**Input**: `(The capital of Wonderland is Wondercity) and (5/3 > 1)`\n**Evaluation**: \"Wonderland\" not in reference → False. `5/3 ≈ 1.666 > 1` → True. `False and True` → False.\n**Output**: False\n\n#### Example 5 (New, from Failure Case):\n**Input**: Complex expression where multiple expressions initially evaluated to True.\n**Mistake**: Model miscounted `not` chains and misparsed parentheses.\n**Correction**: After strict reformatting and re-checking, only one was True.\n**Lesson**: Always verify consistency; if multiple True, re-check from the innermost sub-expressions.\n\n### Output Requirement:\nAfter evaluation, output the boolean value for each expression (A: True/False, B: True/False, ...). Then output only the letter (A-E) of the True expression. If multiple are True, output \"Error\" and identify the source of mistake.\n\nNow, evaluate the following expressions carefully. Follow the steps strictly:\n\n[Insert Expressions Here]",
                    "Q": 1.2000000000000002,
                    "N": 2,
                    "uct_value": 0.603171587431363,
                    "reward": 0.45,
                    "children": [
                      {
                        "id": 7,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), only one evaluates to True. Each expression contains arithmetic operations, comparisons, logical operators (`not`, `and`, `or`), and factual statements about world capitals.\n\n### Step-by-Step Evaluation Instructions:\n1. **Reformat and Parenthesize**: Rewrite each expression with all parentheses explicitly added. Use indentation (2 spaces per nesting level) to visualize structure. Label every sub-expression (S1, S2, ...) for reference.\n2. **Create a Sub-Expression Table**: Maintain a table to track each sub-expression:\n   - Label | Sub-Expression | Type (arithmetic/comparison/factual/logical) | Result\n   - Example: \n        | S1  | `2 - (9 / -3)`        | Arithmetic | 5       |\n        | S2  | `S1 <= 1`              | Comparison | False   |\n3. **Compute Arithmetic Precisely**: Show all arithmetic steps. Use exact fractions or high-precision decimals. Handle negatives and division carefully.\n   - Example: `-5 - (5 / -1) = -5 - (-5) = 0`\n4. **Evaluate Factual Statements**: Use this expanded reference. For any country not listed, assume False.\n   - Norway: Oslo\n   - Denmark: Copenhagen\n   - Iran: Tehran\n   - Germany: Berlin\n   - Turkey: Ankara\n   - Afghanistan: Kabul\n   - Nepal: Kathmandu\n   - Belarus: Minsk\n   - UAE: Abu Dhabi\n   - Cameroon: Yaoundé\n   - Armenia: Yerevan\n   - India: New Delhi\n   - Azerbaijan: Baku\n   - Nigeria: Abuja\n   - Colombia: Bogotá\n   - Gambia: Banjul\n   - Malaysia: Putrajaya\n   - Jordan: Amman\n   - Canada: Ottawa\n   - Iraq: Baghdad\n5. **Simplify `not` Chains Explicitly**: For any chain of `k` `not` operations:\n   - Count `k` explicitly.\n   - If `k` is even, simplify to the inner expression.\n   - If `k` is odd, simplify to `not (inner expression)`.\n   - Example: `not not not not X` → `k=4` (even) → `X`\n6. **Evaluate Innermost First**: Start from the innermost sub-expression. Replace each with its boolean value (True/False).\n7. **Respect Logical Precedence**: `and` has higher precedence than `or`. Use parentheses to disambiguate.\n8. **Store Results**: Avoid recomputation. Use the table to store results for repeated sub-expressions.\n9. **Full Evaluation Mandatory**: Evaluate all five expressions completely before deciding.\n10. **Consistency Check**: If multiple expressions seem True, re-check arithmetic and `not` chains for all True candidates. If still multiple, identify the source of error.\n\n### Common Mistakes to Avoid (with Failure Examples):\n#### Example 1 (Failure Case):\n**Input**: Deeply nested expression with long `not` chains.\n**Mistake**: Model miscounted `not` chains and misparsed parentheses, leading to multiple True evaluations.\n**Correction**: After strict reformatting and recursive `not` simplification, only one was True.\n**Lesson**: Always verify `not` counts from the innermost expression outward.\n\n#### Example 2 (Failure Case):\n**Input**: Expression with mixed arithmetic and factuals.\n**Mistake**: Model miscomputed `-5 - (5 / -1)` as `-10` instead of `0`.\n**Correction**: Re-computed arithmetic step-by-step: `5 / -1 = -5`, then `-5 - (-5) = 0`.\n**Lesson**: Show all arithmetic steps explicitly.\n\n#### Example 3 (Failure Case):\n**Input**: Expression with factual statement \"The capital of UAE is Dubai\".\n**Mistake**: Model incorrectly assumed \"Dubai\" is correct (true), but reference says \"Abu Dhabi\".\n**Correction**: Checked reference: UAE → Abu Dhabi → False.\n**Lesson**: Always cross-reference factual statements with the provided list.\n\n#### Example 4 (New):\n**Input**: `not not not not (True)`\n**Evaluation**: `k=4` (even) → Simplify to `True`.\n**Output**: True\n\n#### Example 5 (New):\n**Input**: `(The capital of Wonderland is Wondercity) and (5/3 > 1)`\n**Evaluation**: \"Wonderland\" not in reference → False. `5/3 ≈ 1.666 > 1` → True. `False and True` → False.\n**Output**: False\n\n### Output Requirement:\nAfter evaluation, output:\nA: True/False\nB: True/False\nC: True/False\nD: True/False\nE: True/False\nTrue expression: [Letter]\nIf multiple True: \"Error: [List letters] due to [reason]\".\n\nNow, evaluate the following expressions carefully. Follow the steps strictly:\n\n[Insert Expressions Here]",
                        "Q": 0.7,
                        "N": 1,
                        "uct_value": 0.002081386527894244,
                        "reward": 0.35,
                        "children": []
                      },
                      {
                        "id": 8,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), only one evaluates to True. Each expression contains arithmetic operations, comparisons, logical operators (`not`, `and`, `or`), and factual statements about world capitals.\n\n### Step-by-Step Evaluation Instructions:\n1. **Reformat and Annotate**: First, reformat the expression with explicit parentheses and indentation (2 spaces per nesting level) to visualize nesting. Label each sub-expression (e.g., S1, S2) for reference. For expressions with >5 nesting levels, break them into smaller parts systematically.\n2. **Compute Arithmetic Precisely**: Use exact fractions for all arithmetic. Convert to decimals only when necessary, using at least 6 decimal places. Handle negatives and division carefully. Record intermediate values.\n   - Example: `-3 * -3 = 9`, `1 - (8 / -4) = 1 - (-2) = 3`, `6/9 = 2/3 ≈ 0.666667`\n3. **Evaluate Factual Statements**: Use this expanded reference (ignore accents and minor punctuation variations):\n   - Norway: Oslo\n   - Denmark: Copenhagen\n   - Iran: Tehran\n   - Germany: Berlin\n   - Turkey: Ankara\n   - Afghanistan: Kabul\n   - Nepal: Kathmandu\n   - Belarus: Minsk\n   - UAE: Abu Dhabi\n   - Cameroon: Yaoundé\n   - Armenia: Yerevan\n   - India: New Delhi\n   - Azerbaijan: Baku\n   - Nigeria: Abuja\n   - Colombia: Bogotá (accept \"Bogota\")\n   - Gambia: Banjul\n   - Malaysia: Putrajaya\n   - Jordan: Amman\n   - Canada: Ottawa\n   - Iraq: Baghdad\n   - For any country not listed or incorrectly phrased (e.g., \"the Nigeria\"), assume False.\n4. **Simplify `not` Chains Recursively**: \n   - Count all `not` operations from the innermost expression outward. If the count `k` is even, simplify to `X`; if `k` is odd, simplify to `not X`.\n   - Example: `not not not not True` = `True` (4 is even), `not not not True` = `not True` = False.\n5. **Evaluate Innermost Sub-Expressions First**: Start from the innermost components (arithmetic, comparisons, factuals). Replace each sub-expression with its boolean value (True/False) as you go.\n6. **Respect Logical Precedence**: `and` has higher precedence than `or`. Use parentheses to disambiguate if needed.\n7. **Store Intermediate Results**: Avoid recomputation. For repeated sub-expressions (e.g., `max`/`min`), compute once and reuse.\n8. **Full Evaluation Mandatory**: Evaluate all five expressions completely before deciding. Do not stop early.\n9. **Consistency Check**: If multiple expressions seem True, re-check each True candidate from the innermost sub-expression outward. Focus on `not` chains and arithmetic. If still multiple True, identify the error source.\n\n### Common Mistakes to Avoid (with Examples):\n- **Miscounting Long `not` Chains**: \n  - Example: `not not not not not True` = `not True` = False (5 is odd).\n- **Miscomputing Arithmetic**:\n  - Example: `9 - (9 / -5) = 9 - (-1.8) = 10.8` (not ≤ -2).\n- **Misinterpreting Factual Statements**:\n  - Example: \"The capital of Colombia is Medellin\" is False (correct is Bogotá).\n  - Example: \"The capital of the Nigeria is Abuja\" is False (incorrect phrasing).\n- **Misapplying Operator Precedence**:\n  - Example: `A and B or C` is `(A and B) or C`, not `A and (B or C)`.\n- **Early Termination**:\n  - Example: Even if you find a True expression, evaluate all others to ensure only one is True.\n\n### Few-Shot Examples with Common Errors:\n#### Example 1 (Failure Case from Input):\n**Input**: Complex expression with deep `not` chains and arithmetic.\n**Mistake**: Model miscounted `not` chains and misparsed parentheses, leading to multiple True.\n**Correction**: After strict reformatting and recursive `not` simplification, only one was True.\n**Lesson**: Always verify `not` chains from the innermost expression and use explicit parentheses.\n\n#### Example 2 (Failure Case):\n**Input**: Expression with factual statement \"The capital of Colombia is Bogota\".\n**Mistake**: Model treated \"Bogota\" as False due to missing accent.\n**Correction**: Accept minor variations; evaluate as True.\n**Lesson**: Ignore accents and punctuation in capital names.\n\n#### Example 3 (New):\n**Input**: `not not not not not (True)`\n**Evaluation**: Innermost: `True`, 5 `not`s (odd) → `not True` = False.\n**Output**: False\n\n#### Example 4 (New):\n**Input**: `(max(1, -2, 3) - min(1, -2, 3) > 4) and (The capital of Canada is Ottawa)`\n**Evaluation**: max=3, min=-2, diff=5 > 4 → True. Capital statement True. `True and True` → True.\n**Output**: True\n\n#### Example 5 (New):\n**Input**: `not (not not (5/3 > 1.666)) or (The capital of Wonderland is Wondercity)`\n**Evaluation**: `5/3 ≈ 1.666667 > 1.666` → True. `not not not True` → `not True` = False. \"Wonderland\" not listed → False. `False or False` → False.\n**Output**: False\n\n### Output Requirement:\nAfter evaluation, output the boolean value for each expression (A: True/False, B: True/False, ...). Then output only the letter (A-E) of the True expression. If multiple are True, output \"Error\" and specify the sub-expression and reason (e.g., \"Error: Expression B and D are True due to miscounted not chains in B-S2\").\n\nNow, evaluate the following expressions carefully. Follow the steps strictly:\n\n[Insert Expressions Here]",
                        "Q": 0.4,
                        "N": 0,
                        "uct_value": 0.002081386527894244,
                        "reward": 0.4,
                        "children": []
                      },
                      {
                        "id": 9,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), only one evaluates to True. Each expression contains arithmetic operations, comparisons, logical operators (`not`, `and`, `or`), and factual statements about world capitals.\n\n### Step-by-Step Evaluation Instructions:\n1. **Reformat and Annotate**: First, reformat the expression with explicit parentheses and indentation (2 spaces per nesting level) to visualize nesting. Label each sub-expression (e.g., S1, S2) for reference. Ensure all parentheses are explicitly placed to avoid ambiguity.\n2. **Compute Arithmetic Precisely**: Use exact fractions or high-precision decimals for all arithmetic. Handle negatives and division carefully. Record intermediate values.\n   - Example: `-3 * -3 = 9`, `1 - (8 / -4) = 1 - (-2) = 3`, `6/9 = 0.666...`\n3. **Evaluate Factual Statements**: Use this expanded reference:\n   - Norway: Oslo\n   - Denmark: Copenhagen\n   - Iran: Tehran\n   - Germany: Berlin\n   - Turkey: Ankara\n   - Afghanistan: Kabul\n   - Nepal: Kathmandu\n   - Belarus: Minsk\n   - UAE: Abu Dhabi\n   - Cameroon: Yaoundé\n   - Armenia: Yerevan\n   - India: New Delhi\n   - Azerbaijan: Baku\n   - Nigeria: Abuja\n   - Colombia: Bogotá\n   - Gambia: Banjul\n   - Malaysia: Putrajaya\n   - Jordan: Amman\n   - Canada: Ottawa\n   - Iraq: Baghdad\n   - For any country not listed, assume the capital statement is False.\n4. **Simplify `not` Chains Recursively**: \n   - For any chain of `k` `not` operations: if `k` is even, it simplifies to `X`; if `k` is odd, it simplifies to `not X`.\n   - Start from the innermost expression and work outward.\n   - Example: `not not not not True` = `True`, `not not not True` = `not True` = False.\n5. **Evaluate Innermost Sub-Expressions First**: Start from the innermost components (arithmetic, comparisons, factuals). Replace each sub-expression with its boolean value (True/False) as you go.\n6. **Respect Logical Precedence**: `and` has higher precedence than `or`. Use parentheses to disambiguate if needed.\n7. **Store Intermediate Results**: Avoid recomputation. For repeated sub-expressions, compute once and reuse the result.\n8. **Full Evaluation Mandatory**: You must evaluate all five expressions completely before deciding which one is True. Do not stop early.\n9. **Consistency Check**: After evaluating all expressions, if more than one seems True, re-check the arithmetic and `not` chains of the True candidates. If still multiple True, identify the source of error.\n\n### Common Mistakes to Avoid (with Examples):\n- **Miscounting Long `not` Chains**: \n  - Example: `not not not not True` = True (not False).\n- **Miscomputing Arithmetic**:\n  - Example: `9 - (9 / -5) = 9 - (-1.8) = 10.8` (not ≤ -2).\n- **Misinterpreting Factual Statements**:\n  - Example: \"The capital of Norway is Bergen\" is False.\n  - Example: \"The capital of Gambia is Libreville\" is False (correct is Banjul).\n- **Misapplying Operator Precedence**:\n  - Example: `A and B or C` is `(A and B) or C`, not `A and (B or C)`.\n- **Early Termination**:\n  - Example: Even if you find a True expression, you must evaluate all others to ensure only one is True.\n\n### Few-Shot Examples with Common Errors:\n#### Example 1:\n**Input**: Expression with deep nesting and `not` chains.\n**Mistake**: Model initially evaluated (B) as True due to `not` chain error.\n**Correction**: After re-checking, (D) was True.\n**Lesson**: Always simplify `not` chains recursively from the inside out.\n\n#### Example 2:\n**Input**: Expressions with mixed arithmetic and factuals.\n**Mistake**: Model misparsed structure in (A), leading to false True.\n**Correction**: Reformatted with explicit parentheses; found (E) True.\n**Lesson**: Reformat expressions to clarify nesting.\n\n#### Example 3 (New):\n**Input**: `not not not not (True)`\n**Evaluation**: Innermost: `not not not not True` = `True` (since 4 is even).\n**Output**: True\n\n#### Example 4 (New):\n**Input**: `(The capital of Wonderland is Wondercity) and (5/3 > 1)`\n**Evaluation**: \"Wonderland\" not in reference → False. `5/3 ≈ 1.666 > 1` → True. `False and True` → False.\n**Output**: False\n\n#### Example 5 (New, from Failure Case):\n**Input**: Complex expression where multiple expressions initially evaluated to True.\n**Mistake**: Model miscounted `not` chains and misparsed parentheses.\n**Correction**: After strict reformatting and re-checking, only one was True.\n**Lesson**: Always verify consistency; if multiple True, re-check from the innermost sub-expressions.\n\n### Output Requirement:\nAfter evaluation, output the boolean value for each expression (A: True/False, B: True/False, ...). Then output only the letter (A-E) of the True expression. If multiple are True, output \"Error\" and identify the source of mistake.\n\nNow, evaluate the following expressions carefully. Follow the steps strictly:\n\n[Insert Expressions Here]",
                        "Q": 0.3,
                        "N": 0,
                        "uct_value": 0.002081386527894244,
                        "reward": 0.3,
                        "children": []
                      }
                    ]
                  },
                  {
                    "id": 7,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), only one evaluates to True. Each expression contains arithmetic operations, comparisons, logical operators (`not`, `and`, `or`), and factual statements about world capitals.\n\n### Step-by-Step Evaluation Instructions:\n1. **Reformat and Annotate**: First, reformat the expression with explicit parentheses and indentation (2 spaces per nesting level) to visualize nesting. Label each sub-expression (e.g., S1, S2) for reference. Ensure parentheses enforce standard precedence: `not` > `and` > `or`.\n2. **Compute Arithmetic Precisely**: Use exact fractions or high-precision decimals (at least 6 decimal places) for all arithmetic. Handle negatives and division carefully. Record intermediate values.\n   - Example: `-3 * -3 = 9`, `1 - (8 / -4) = 1 - (-2) = 3`, `6/9 = 0.666666...`\n3. **Evaluate Factual Statements**: Use this expanded reference (case-insensitive, ignore articles):\n   - Norway: Oslo\n   - Denmark: Copenhagen\n   - Iran: Tehran\n   - Germany: Berlin\n   - Turkey: Ankara\n   - Afghanistan: Kabul\n   - Nepal: Kathmandu\n   - Belarus: Minsk\n   - UAE: Abu Dhabi (not Dubai)\n   - Cameroon: Yaoundé (not Douala)\n   - Armenia: Yerevan (not Gyumri)\n   - India: New Delhi (not Mumbai)\n   - Azerbaijan: Baku\n   - Nigeria: Abuja (not Lagos)\n   - Colombia: Bogotá\n   - Gambia: Banjul (not Libreville)\n   - Malaysia: Putrajaya (not Kuala Lumpur)\n   - Jordan: Amman (not Beirut)\n   - Canada: Ottawa (not Toronto)\n   - For any country not listed, assume the capital statement is False.\n4. **Simplify `not` Chains Directly**: \n   - For any chain of `k` `not` operations: if `k` is even, it simplifies to `X`; if `k` is odd, it simplifies to `not X`. Do not step through each `not` individually for long chains.\n   - Example: `not not not not True` = `True`, `not not not True` = `not True` = False.\n5. **Evaluate Innermost Sub-Expressions First**: Start from the innermost components (arithmetic, comparisons, factuals). Replace each sub-expression with its boolean value (True/False) as you go.\n6. **Respect Logical Precedence**: `not` has the highest precedence, then `and`, then `or`. Use parentheses to disambiguate if needed.\n7. **Store Intermediate Results**: Avoid recomputation. For repeated sub-expressions, compute once and reuse the result.\n8. **Full Evaluation Mandatory**: You must evaluate all five expressions completely before deciding which one is True. Do not stop early.\n9. **Consistency Check**: After evaluating all expressions, if more than one seems True, re-check the arithmetic and `not` chains of the True candidates.\n\n### Common Mistakes to Avoid (with Examples):\n- **Miscounting Long `not` Chains**: \n  - Example: `not not not not True` = True (not False).\n- **Miscomputing Arithmetic**:\n  - Example: `9 - (9 / -5) = 9 - (-1.8) = 10.8` (not ≤ -2).\n- **Misinterpreting Factual Statements**:\n  - Example: \"The capital of Norway is Bergen\" is False.\n  - Example: \"The capital of Gambia is Libreville\" is False (correct is Banjul).\n- **Misapplying Operator Precedence**:\n  - Example: `A and B or C` is `(A and B) or C`, not `A and (B or C)`.\n- **Early Termination**:\n  - Example: Even if you find a True expression, you must evaluate all others to ensure only one is True.\n\n### Few-Shot Examples with Common Errors:\n#### Example 1 (Deep Nesting Error):\n**Input**: Expression with many nested `not` operations\n**Mistake**: Model miscounted `not` chain length due to deep nesting\n**Correction**: Simplify directly using parity: `not not not not not True` = `not True` = False\n**Lesson**: For long `not` chains, count the number of `not`s and apply parity rule directly.\n\n#### Example 2 (Structural Misparsing):\n**Input**: `not (A and B) or C and D`\n**Mistake**: Evaluated as `not A and (B or C) and D`\n**Correction**: Reformatted as `(not (A and B)) or (C and D)`\n**Lesson**: Always add explicit parentheses to enforce precedence before evaluation.\n\n#### Example 3 (Factual Statement Error):\n**Input**: \"The capital of the Nigeria is Abuja\"\n**Mistake**: Missed the article \"the\" and evaluated as False\n**Correction**: Ignore articles; \"Nigeria is Abuja\" is True\n**Lesson**: For factual statements, ignore articles and focus on country-capital match.\n\n#### Example 4 (Arithmetic Precision):\n**Input**: `1 - (1/3) > 0.666`\n**Mistake**: Used 0.666 instead of 0.666666...\n**Correction`: `1 - 0.333333... = 0.666666... > 0.666` → True\n**Lesson**: Use high-precision decimals for accurate comparisons.\n\n### Output Requirement:\nAfter evaluation, output only the letter (A-E) of the True expression. Show no other text.\n\nNow, evaluate the following expressions carefully. Follow the steps strictly:\n\n[Insert Expressions Here]",
                    "Q": 0.6,
                    "N": 1,
                    "uct_value": 0.6031715890171546,
                    "reward": 0.3,
                    "children": []
                  }
                ]
              },
              {
                "id": 5,
                "depth": 3,
                "action_sequence": [
                  "FailureDrivenAction",
                  "FailureDrivenAction",
                  "FailureDrivenAction"
                ],
                "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), only one evaluates to True. Each expression contains arithmetic operations, comparisons, logical operators (`not`, `and`, `or`), and factual statements about world capitals.\n\n### Step-by-Step Evaluation Instructions:\n1. **Reformat and Annotate**: \n   - Reformat each expression into a fully parenthesized form with clear indentation to visualize nesting depth.\n   - Label each sub-expression (e.g., E1, E2) for reference and to avoid recomputation.\n\n2. **Compute Arithmetic Precisely**:\n   - Use exact fractions for division operations. Avoid floating-point approximations unless necessary.\n   - Handle negative signs carefully. Record all intermediate values.\n   - Example: `-3 * -3 = 9`, `1 - (8 / -4) = 1 - (-2) = 3`\n\n3. **Evaluate Factual Statements**:\n   - Use this reference for world capitals (case-sensitive):\n     - Norway: Oslo (not Bergen)\n     - Denmark: Copenhagen (not Aarhus)\n     - Iran: Tehran\n     - Germany: Berlin\n     - Turkey: Ankara (not Istanbul)\n     - Afghanistan: Kabul (not Kandahar)\n     - Nepal: Kathmandu (not Pokhara)\n     - Belarus: Minsk (not Grodno)\n     - UAE: Abu Dhabi (not Dubai)\n     - Cameroon: Yaoundé (not Douala)\n     - Armenia: Yerevan\n     - India: New Delhi (not Mumbai)\n     - Azerbaijan: Baku (not Ganja)\n     - Nigeria: Abuja (not Lagos)\n     - Colombia: Bogotá (not Medellin)\n     - Canada: Ottawa\n     - Iraq: Baghdad (not Beirut)\n\n4. **Simplify `not` Chains First**:\n   - Reduce modulo 2: An even number of `not`s cancels out; an odd number is equivalent to one `not`.\n   - Examples: \n     - `not not X` = `X`\n     - `not not not X` = `not X`\n     - `not not not not X` = `X`\n\n5. **Evaluate Innermost Sub-Expressions**:\n   - Start from the innermost components (arithmetic, comparisons, factuals).\n   - Replace each sub-expression with its boolean value (True/False) as you proceed outward.\n\n6. **Respect Logical Precedence**:\n   - `and` has higher precedence than `or`. Use parentheses to disambiguate if the expression is ambiguous.\n   - Example: `A and B or C` should be interpreted as `(A and B) or C`.\n\n7. **Store Intermediate Results**:\n   - For repeated sub-expressions (e.g., `max-min`), compute once and reuse the value.\n\n8. **Consistency Check**:\n   - After evaluating all expressions, if more than one seems True, re-check the candidates' arithmetic and `not` chains.\n   - Pay special attention to expressions with deep nesting and multiple negations.\n\n### Common Mistakes to Avoid (with Examples):\n- **Miscounting `not` Operations**:\n  - Example: `not not not True` = `not True` = False (not True).\n- **Miscomputing Arithmetic**:\n  - Example: `9 - (9 / -5) = 9 - (-1.8) = 10.8` (not ≤ -2).\n- **Misinterpreting Factual Statements**:\n  - Example: \"The capital of Norway is Bergen\" is False.\n- **Misapplying Operator Precedence**:\n  - Example: `A and B or C` is `(A and B) or C`, not `A and (B or C)`.\n- **Overlooking Negative Signs in Arithmetic**:\n  - Example: `-8 * -8 = 64` (not -64).\n\n### Few-Shot Examples:\n#### Example 1:\n**Input**: \nExpression (A) with deep nesting and multiple `not` chains.\n**Mistake**: Model initially evaluated (B) as True due to miscounting `not` operations.\n**Correction**: After simplifying `not not not X` to `not X`, (D) was found True.\n**Lesson**: Always simplify `not` chains modulo 2 before combining with other operators.\n\n#### Example 2:\n**Input**: \nExpression with mixed arithmetic and factuals.\n**Mistake**: Model misparsed structure in (A), leading to a false True.\n**Correction**: Reformatted with explicit parentheses and indentation; found (E) True.\n**Lesson**: Reformat expressions to clarify nesting and precedence.\n\n#### Example 3:\n**Input**: \nExpression with complex arithmetic and factual errors.\n**Mistake**: Model miscomputed `10 - (-1 / -5)` as 9.8 ≤ 8 → False, but missed a negation.\n**Correction**: Re-checked arithmetic and negation steps; confirmed (C) was True.\n**Lesson**: Double-check arithmetic with fractions and negative signs.\n\n### Output Requirement:\nAfter evaluation, output only the letter (A-E) of the True expression. Do not output any other text.\n\nNow, evaluate the following expressions carefully. Follow the steps strictly:\n\n[Insert Expressions Here]",
                "Q": 0.5,
                "N": 0,
                "uct_value": 0.0031715906029487987,
                "reward": 0.5,
                "children": [
                  {
                    "id": 6,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), only one evaluates to True. Each expression contains arithmetic operations, comparisons, logical operators (`not`, `and`, `or`), and factual statements about world capitals.\n\n### Step-by-Step Evaluation Instructions:\n1. **Reformat and Annotate**:\n   - Before any evaluation, reformat each expression with full parentheses and clear indentation to visualize nesting depth.\n   - Label every sub-expression (e.g., E1, E2, ...) for reference. Example:\n        E1: not (\n            E2: (max(-5, 3) - min(-5, 3) > 2\n        )\n   - This step is mandatory to prevent structural errors.\n\n2. **Simplify `not` Chains Immediately**:\n   - For any sub-expression, simplify chains of `not` operations modulo 2 before combining with other operators.\n   - Examples: \n        `not not X` = `X`\n        `not not not X` = `not X`\n        `not not not not X` = `X`\n   - Apply this simplification as soon as you encounter a `not` chain.\n\n3. **Compute Arithmetic with Exact Fractions**:\n   - Use exact fractions for all division operations. Avoid floating-point approximations.\n   - Handle negative signs meticulously. Record all intermediate values.\n   - Example: `-3 * -3 = 9`, `1 - (8 / -4) = 1 - (-2) = 3`\n\n4. **Evaluate Factual Statements Against Reference**:\n   - Use this case-sensitive reference for world capitals:\n        Norway: Oslo (not Bergen)\n        Denmark: Copenhagen (not Aarhus)\n        Iran: Tehran\n        Germany: Berlin\n        Turkey: Ankara (not Istanbul)\n        Afghanistan: Kabul (not Kandahar)\n        Nepal: Kathmandu (not Pokhara)\n        Belarus: Minsk (not Grodno)\n        UAE: Abu Dhabi (not Dubai)\n        Cameroon: Yaoundé (not Douala)\n        Armenia: Yerevan\n        India: New Delhi (not Mumbai)\n        Azerbaijan: Baku (not Ganja)\n        Nigeria: Abuja (not Lagos)\n        Colombia: Bogotá (not Medellin)\n        Canada: Ottawa\n        Iraq: Baghdad (not Beirut)\n   - Double-check each factual statement; even minor errors (e.g., \"Munich\" for Germany) must be caught.\n\n5. **Evaluate Innermost Sub-Expressions First**:\n   - Start from the innermost components (arithmetic, comparisons, factuals).\n   - Replace each sub-expression with its boolean value (True/False) as you proceed outward.\n   - For repeated sub-expressions (e.g., `max-min`), compute once and reuse the value.\n\n6. **Respect Logical Precedence**:\n   - `and` has higher precedence than `or`. Use parentheses to disambiguate if needed.\n   - Example: `A and B or C` is always `(A and B) or C`.\n\n7. **Consistency Check**:\n   - After evaluating all expressions, if more than one seems True, re-check the candidates' arithmetic and `not` chains.\n   - Pay special attention to expressions with deep nesting and multiple negations.\n\n### Common Mistakes to Avoid (with Examples from Past Errors):\n- **Miscounting `not` Operations**:\n  - Example: In expression (A) of a previous case, `not not not not X` was mistakenly simplified to `not X` instead of `X`, leading to a false True.\n- **Miscomputing Arithmetic**:\n  - Example: `9 - (9 / -5)` was computed as `10.8` (correct) but then incorrectly compared as `≤ -2`.\n- **Misinterpreting Factual Statements**:\n  - Example: \"The capital of Germany is Munich\" was overlooked as False (should be Berlin).\n- **Misapplying Operator Precedence**:\n  - Example: `A and B or C` was incorrectly parsed as `A and (B or C)` instead of `(A and B) or C`.\n- **Overlooking Negative Signs**:\n  - Example: `-8 * -8` was computed as `-64` instead of `64`.\n\n### Few-Shot Examples from Past Errors:\n#### Example 1 (Previous Failure):\n**Input**: \nExpression (A) with deep nesting and multiple `not` chains.\n**Mistake**: Model miscounted `not` operations and evaluated (B) as True.\n**Correction**: After simplifying `not not not X` to `not X` and re-checking, (D) was found True.\n**Lesson**: Always simplify `not` chains modulo 2 before combining with other operators.\n\n#### Example 2 (Previous Failure):\n**Input**: \nExpression with mixed arithmetic and factuals.\n**Mistake**: Model misparsed structure in (A) due to lack of parentheses, leading to a false True.\n**Correction**: Reformatted with explicit parentheses and indentation; found (E) True.\n**Lesson**: Reformat expressions to clarify nesting and precedence.\n\n#### Example 3 (Previous Failure):\n**Input**: \nExpression with complex arithmetic and factual errors.\n**Mistake**: Model miscomputed `10 - (-1 / -5)` as 9.8 ≤ 8 → False, but missed a negation.\n**Correction**: Re-checked arithmetic and negation steps; confirmed (C) was True.\n**Lesson**: Double-check arithmetic with fractions and negative signs.\n\n### Output Requirement:\nYou must output your step-by-step evaluation for each expression, showing reformatting, arithmetic, factual checks, and logical simplifications. However, your final output must be only the letter (A-E) of the True expression.\n\nNow, evaluate the following expressions carefully. Follow the steps strictly:\n\n[Insert Expressions Here]",
                    "Q": 0.45,
                    "N": 0,
                    "uct_value": 0.0,
                    "reward": 0.45,
                    "children": []
                  },
                  {
                    "id": 7,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), only one evaluates to True. Each expression contains arithmetic operations, comparisons, logical operators (`not`, `and`, `or`), and factual statements about world capitals.\n\n### Step-by-Step Evaluation Instructions:\n1. **Reformat and Annotate**:\n   - Reformat each expression into a fully parenthesized form with clear indentation to visualize nesting depth.\n   - Assign a unique label (e.g., E1, E2) to every sub-expression (arithmetic, comparison, factual, or logical) and create a lookup table to store their values. Avoid recomputation.\n\n2. **Compute Arithmetic Precisely**:\n   - Use exact fractions for division operations. Avoid floating-point approximations.\n   - Handle negative signs carefully. Record all intermediate values.\n   - Example: `-3 * -3 = 9`, `1 - (8 / -4) = 1 - (-2) = 3`\n\n3. **Evaluate Factual Statements**:\n   - Use this reference for world capitals (normalize country names by removing articles like 'the'; capitals are case-sensitive):\n     - Norway: Oslo (not Bergen)\n     - Denmark: Copenhagen (not Aarhus)\n     - Iran: Tehran\n     - Germany: Berlin\n     - Turkey: Ankara (not Istanbul)\n     - Afghanistan: Kabul (not Kandahar)\n     - Nepal: Kathmandu (not Pokhara)\n     - Belarus: Minsk (not Grodno)\n     - UAE: Abu Dhabi (not Dubai)\n     - Cameroon: Yaoundé (not Douala)\n     - Armenia: Yerevan\n     - India: New Delhi (not Mumbai)\n     - Azerbaijan: Baku (not Ganja)\n     - Nigeria: Abuja (not Lagos)\n     - Colombia: Bogotá (not Medellin)\n     - Canada: Ottawa\n     - Iraq: Baghdad (not Beirut)\n\n4. **Simplify `not` Chains First**:\n   - Reduce modulo 2: An even number of `not`s cancels out; an odd number is equivalent to one `not`.\n   - Examples: \n     - `not not X` = `X`\n     - `not not not X` = `not X`\n     - `not not not not X` = `X`\n\n5. **Evaluate Innermost Sub-Expressions**:\n   - Start from the innermost components (arithmetic, comparisons, factuals).\n   - Replace each sub-expression with its boolean value (True/False) as you proceed outward.\n\n6. **Respect Logical Precedence**:\n   - `and` has higher precedence than `or`. In the reformatting step, add parentheses to make grouping explicit.\n   - Example: `A and B or C` should be rewritten as `(A and B) or C`.\n\n7. **Store Intermediate Results**:\n   - For repeated sub-expressions, compute once and reuse the value from the lookup table.\n\n8. **Consistency Check**:\n   - After evaluating all expressions, output the boolean value for each (A: True/False, B: True/False, ...).\n   - If more than one is True, re-check the arithmetic and `not` chains for those expressions.\n\n### Common Mistakes to Avoid (with Examples):\n- **Miscounting `not` Operations**: \n  - Example: `not not not True` = `not True` = False (not True).\n- **Miscomputing Arithmetic**:\n  - Example: `9 - (9 / -5) = 9 - (-9/5) = 54/5 = 10.8` (use fractions, not decimals).\n- **Misinterpreting Factual Statements**:\n  - Example: \"The capital of Norway is Bergen\" is False.\n- **Misapplying Operator Precedence**:\n  - Example: `A and B or C` is `(A and B) or C`, not `A and (B or C)`.\n- **Overlooking Negative Signs in Arithmetic**:\n  - Example: `-8 * -8 = 64` (not -64).\n\n### Few-Shot Examples (Revised with Corrections):\n#### Example 1:\n**Input**: Complex expression with deep nesting.\n**Mistake**: Model miscounted `not` operations.\n**Correction**: After simplifying `not not not X` to `not X`, found the correct True expression.\n**Lesson**: Always simplify `not` chains modulo 2 before combining with other operators.\n\n#### Example 2:\n**Input**: Expression with mixed arithmetic and factuals.\n**Mistake**: Model misparsed structure due to ambiguous precedence.\n**Correction**: Added explicit parentheses and found the True expression.\n**Lesson**: Reformat with parentheses to clarify nesting.\n\n#### Example 3:\n**Input**: Expression with complex arithmetic.\n**Mistake**: Model used floating-point approximation for division.\n**Correction**: Used exact fractions and corrected the evaluation.\n**Lesson**: Use exact fractions for division.\n\n### Output Requirement:\nAfter evaluation, output only the letter (A-E) of the True expression. Do not output any other text.\n\nNow, evaluate the following expressions carefully. Follow the steps strictly:\n\n[Insert Expressions Here]",
                    "Q": 0.4,
                    "N": 0,
                    "uct_value": 0.0,
                    "reward": 0.4,
                    "children": []
                  },
                  {
                    "id": 8,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), only one evaluates to True. Each expression contains arithmetic operations, comparisons, logical operators (`not`, `and`, `or`), and factual statements about world capitals.\n\n### Step-by-Step Evaluation Instructions:\n1. **Reformat and Annotate**:\n   - Rewrite each expression with full parentheses to eliminate ambiguity in operator precedence. Use indentation to show nesting depth.\n   - Assign a unique label (e.g., E1, E2) to every sub-expression. Reuse these labels to avoid recomputing identical sub-expressions.\n\n2. **Compute Arithmetic Precisely**:\n   - Use exact fractions for all division operations. Do not use floating-point approximations.\n   - Handle negative signs with extreme care. Show all intermediate arithmetic steps.\n   - Example: `-3 * -3 = 9`, `1 - (8 / -4) = 1 - (-2) = 3`\n\n3. **Evaluate Factual Statements**:\n   - Use this exact reference for world capitals (case-sensitive):\n     - Norway: Oslo (not Bergen)\n     - Denmark: Copenhagen (not Aarhus)\n     - Iran: Tehran\n     - Germany: Berlin\n     - Turkey: Ankara (not Istanbul)\n     - Afghanistan: Kabul (not Kandahar)\n     - Nepal: Kathmandu (not Pokhara)\n     - Belarus: Minsk (not Grodno)\n     - UAE: Abu Dhabi (not Dubai)\n     - Cameroon: Yaoundé (not Douala)\n     - Armenia: Yerevan\n     - India: New Delhi (not Mumbai)\n     - Azerbaijan: Baku (not Ganja)\n     - Nigeria: Abuja (not Lagos)\n     - Colombia: Bogotá (not Medellin)\n     - Canada: Ottawa\n     - Iraq: Baghdad (not Beirut)\n     - Jordan: Amman\n     - Gambia: Banjul (not Libreville)\n     - Malaysia: Kuala Lumpur (Putrajaya is not the official capital for this context)\n   - Verify each factual statement against this reference. Treat them as boolean values.\n\n4. **Simplify `not` Chains Immediately**:\n   - Before any other evaluation, reduce all `not` chains modulo 2:\n     - Even number of `not`s: cancel out (e.g., `not not X` = `X`)\n     - Odd number of `not`s: equivalent to one `not` (e.g., `not not not X` = `not X`)\n   - Apply this simplification recursively from innermost to outermost.\n\n5. **Evaluate from Innermost Outward**:\n   - Begin with the innermost sub-expressions (arithmetic, comparisons, factuals).\n   - Replace each sub-expression with its boolean value (True/False) as you proceed outward.\n   - For repeated sub-expressions, use the precomputed value from its label.\n\n6. **Respect Logical Precedence**:\n   - `and` has higher precedence than `or`. Use parentheses to make precedence explicit in your reformatting.\n   - Example: `A and B or C` must be interpreted as `(A and B) or C`.\n\n7. **Consistency Verification**:\n   - After evaluating all expressions, if more than one appears True, re-check the arithmetic and `not` chains of those candidates.\n   - Pay special attention to expressions with deep nesting and multiple negations.\n\n### Common Mistakes to Avoid (with Corrected Examples):\n- **Miscounting `not` Operations**:\n  - Example: `not not not True` = `not True` = False (not True).\n  - Correction: Simplify to one `not` before evaluation.\n- **Miscomputing Arithmetic**:\n  - Example: `9 - (9 / -5) = 9 - (-1.8) = 10.8` (not ≤ -2). Use fractions: `9 - (9 / -5) = 9 + 9/5 = 54/5 = 10.8`.\n- **Misinterpreting Factual Statements**:\n  - Example: \"The capital of Nigeria is Lagos\" is False (Abuja is correct).\n- **Misapplying Operator Precedence**:\n  - Example: `A and B or C` is `(A and B) or C`, not `A and (B or C)`.\n- **Overlooking Negative Signs**:\n  - Example: `-8 * -8 = 64` (not -64).\n\n### Few-Shot Examples with Corrections:\n#### Example 1:\n**Input**: Expression (A) with deep nesting and multiple `not` chains.\n**Mistake**: Model miscounted `not` operations, incorrectly evaluating (B) as True.\n**Correction**: After simplifying `not not not X` to `not X`, (D) was found True.\n**Step-by-Step**:\n  - E1 = max(3,-9,-1,9) = 9, E2 = min(3,-9,-1,9) = -9, E3 = E1 - E2 = 18\n  - E4 = E3 <= 5 → False\n  - Simplify `not not not E4` to `not False` → True\n  - ... [continue] ...\n**Final**: (D) is True.\n\n#### Example 2:\n**Input**: Expression with mixed arithmetic and factual errors.\n**Mistake**: Model miscomputed `10 - (-1 / -5)` as 9.8 ≤ 8 → False, but missed a negation.\n**Correction**: Used exact fractions: `-1 / -5 = 1/5`, `10 - (1/5) = 49/5 = 9.8`. Confirmed (C) was True after re-checking.\n**Step-by-Step**:\n  - Reformatted with explicit parentheses: `(10 - ((-1) / (-5))) ≤ 8`\n  - Computed: `10 - (1/5) = 49/5 = 9.8`, `9.8 ≤ 8` → False\n  - ... [continue] ...\n**Final**: (C) is True.\n\n#### Example 3:\n**Input**: Expression with complex factual checks.\n**Mistake**: Model treated \"The capital of Malaysia is Putrajaya\" as True (incorrect).\n**Correction**: Referenced list: Kuala Lumpur is correct. Evaluated as False.\n**Step-by-Step**:\n  - Factual statement: \"The capital of Malaysia is Putrajaya\" → False\n  - ... [continue] ...\n**Final**: (E) is True.\n\n### Output Requirement:\nFor each expression (A through E), output a detailed step-by-step evaluation showing:\n- Reformatted expression with parentheses and labels\n- Arithmetic computations with exact fractions\n- Factual statement verification\n- Simplification of `not` chains\n- Intermediate boolean results\nAfter evaluating all, output only the letter (A-E) of the True expression.\n\nNow, evaluate the following expressions carefully. Follow the steps strictly:\n\n[Insert Expressions Here]",
                    "Q": 0.5,
                    "N": 0,
                    "uct_value": 0.0,
                    "reward": 0.5,
                    "children": [
                      {
                        "id": 9,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), only one evaluates to True. Each expression contains arithmetic operations, comparisons, logical operators (`not`, `and`, `or`), and factual statements about world capitals.\n\n### Step-by-Step Evaluation Instructions:\n1. **Reformat and Annotate**:\n   - Rewrite each expression with full parentheses to eliminate ambiguity. Use indentation to show nesting depth.\n   - Assign a unique label (e.g., E1, E2) to every sub-expression. Reuse these labels to avoid recomputing identical sub-expressions.\n\n2. **Compute Arithmetic Precisely**:\n   - Use exact fractions for all division operations. Never use floating-point approximations.\n   - Handle negative signs with extreme care. Show all intermediate arithmetic steps.\n   - Example: `-3 * -3 = 9`, `1 - (8 / -4) = 1 - (-2) = 3`\n\n3. **Evaluate Factual Statements First**:\n   - Use this exact reference for world capitals (case-sensitive):\n     - Norway: Oslo (not Bergen)\n     - Denmark: Copenhagen (not Aarhus)\n     - Iran: Tehran\n     - Germany: Berlin\n     - Turkey: Ankara (not Istanbul)\n     - Afghanistan: Kabul (not Kandahar)\n     - Nepal: Kathmandu (not Pokhara)\n     - Belarus: Minsk (not Grodno)\n     - UAE: Abu Dhabi (not Dubai)\n     - Cameroon: Yaoundé (not Douala)\n     - Armenia: Yerevan\n     - India: New Delhi (not Mumbai)\n     - Azerbaijan: Baku (not Ganja)\n     - Nigeria: Abuja (not Lagos)\n     - Colombia: Bogotá (not Medellin)\n     - Canada: Ottawa\n     - Iraq: Baghdad (not Beirut)\n     - Jordan: Amman\n     - Gambia: Banjul (not Libreville)\n     - Malaysia: Kuala Lumpur (Putrajaya is not the official capital for this context)\n   - Verify each factual statement against this reference. Treat them as boolean values and cache these values for reuse.\n\n4. **Simplify `not` Chains Immediately**:\n   - Before any other evaluation, reduce all `not` chains modulo 2:\n     - Even number of `not`s: cancel out (e.g., `not not X` = `X`)\n     - Odd number of `not`s: equivalent to one `not` (e.g., `not not not X` = `not X`)\n   - Apply this simplification recursively from innermost to outermost.\n\n5. **Evaluate from Innermost Outward**:\n   - Begin with the innermost sub-expressions (arithmetic, comparisons, factuals).\n   - Replace each sub-expression with its boolean value (True/False) as you proceed outward.\n   - For repeated sub-expressions, use the precomputed value from its label.\n\n6. **Respect Logical Precedence**:\n   - `and` has higher precedence than `or`. Use parentheses to make precedence explicit in your reformatting.\n   - Example: `A and B or C` must be interpreted as `(A and B) or C`.\n\n7. **Consistency Verification Protocol**:\n   - After evaluating all expressions, if more than one appears True, re-check in this order:\n     a) Expressions with the deepest nesting (most levels of parentheses)\n     b) Expressions with the most `not` operations\n     c) Expressions with division operations or multiple negative signs\n   - Double-check all arithmetic computations with exact fractions.\n   - Verify all factual statements against the reference list again.\n   - Pay special attention to expressions where multiple `not` chains might have been miscounted.\n\n### Common Mistakes to Avoid (with Corrected Examples):\n- **Miscounting `not` Operations**:\n  - Example: `not not not True` = `not True` = False (not True).\n  - Correction: Simplify to one `not` before evaluation.\n- **Miscomputing Arithmetic**:\n  - Example: `9 - (9 / -5) = 9 - (-9/5) = 9 + 9/5 = 54/5 = 10.8` (not ≤ -2).\n- **Misinterpreting Factual Statements**:\n  - Example: \"The capital of Nigeria is Lagos\" is False (Abuja is correct).\n- **Misapplying Operator Precedence**:\n  - Example: `A and B or C` is `(A and B) or C`, not `A and (B or C)`.\n- **Overlooking Negative Signs**:\n  - Example: `-8 * -8 = 64` (not -64).\n\n### Few-Shot Examples with Detailed Corrections:\n#### Example 1: Deep Nesting and `not` Chains\n**Input**: Expression with multiple `not` chains and arithmetic\n**Mistake**: Model evaluated `not not not not X` as `X` but missed an inner `not`\n**Correction**: After recursive simplification: `not not not not X` = `not not (not not X)` = `X`\n**Step-by-Step**:\n  - E1 = max(3,-9,-1,9) = 9, E2 = min(3,-9,-1,9) = -9, E3 = E1 - E2 = 18\n  - E4 = E3 <= 5 → False\n  - Simplify `not not not not E4` = `not not (not not False)` = `not not (False)` = `False`\n**Final**: Expression evaluates to False\n\n#### Example 2: Arithmetic with Fractions and Negations\n**Input**: Expression with division and negative signs\n**Mistake**: Model computed `10 - (-1 / -5)` as 10 - 0.2 = 9.8 ≤ 8 → False\n**Correction**: Used exact fractions: `-1 / -5 = 1/5`, `10 - (1/5) = 49/5 = 9.8`, `9.8 ≤ 8` → False\n**Step-by-Step**:\n  - Reformatted: `(10 - ((-1) / (-5))) ≤ 8`\n  - Computed: `10 - (1/5) = 49/5 = 9.8`\n  - Comparison: `9.8 ≤ 8` → False\n**Final**: Expression evaluates to False\n\n#### Example 3: Factual Statement Error\n**Input**: Expression with \"The capital of Malaysia is Putrajaya\"\n**Mistake**: Model treated this as True\n**Correction**: Referenced list: Kuala Lumpur is correct → statement is False\n**Step-by-Step**:\n  - Factual statement: \"The capital of Malaysia is Putrajaya\" → False\n  - ... [continue evaluation] ...\n**Final**: Expression evaluates to False\n\n### Output Requirement:\nFor each expression (A through E), output a detailed step-by-step evaluation showing:\n- Reformatted expression with parentheses and labels\n- Arithmetic computations with exact fractions\n- Factual statement verification\n- Simplification of `not` chains\n- Intermediate boolean results\n\nAfter evaluating all, output only the letter (A-E) of the True expression. If multiple seem True, re-check according to the Consistency Verification Protocol before finalizing your answer.\n\nNow, evaluate the following expressions carefully. Follow the steps strictly:\n\n[Insert Expressions Here]",
                        "Q": 0.45,
                        "N": 0,
                        "uct_value": 0.0,
                        "reward": 0.45,
                        "children": []
                      },
                      {
                        "id": 10,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), only one evaluates to True. Each expression contains arithmetic operations, comparisons, logical operators (`not`, `and`, `or`), and factual statements about world capitals.\n\n### Step-by-Step Evaluation Instructions:\n1. **Reformat and Annotate**:\n   - Rewrite each expression with full parentheses to eliminate ambiguity. Use indentation to show nesting depth.\n   - Assign a unique label (e.g., E1, E2) only to non-trivial sub-expressions (those involving arithmetic, factual checks, or deep nesting). Avoid labels for simple booleans (e.g., `True`, `False`).\n   - Explicitly show operator precedence: `not` has the highest precedence, followed by `and`, then `or`. Example: `A and B or C` must be written as `(A and B) or C`.\n\n2. **Compute Arithmetic Precisely**:\n   - Use exact fractions for all division operations. Do not use floating-point approximations.\n   - Handle negative signs with extreme care. Show all intermediate arithmetic steps.\n   - Example: `-3 * -3 = 9`, `1 - (8 / -4) = 1 - (-2) = 3`\n\n3. **Evaluate Factual Statements**:\n   - Before evaluation, extract all factual statements (e.g., \"The capital of X is Y\") and verify each against the reference list below (case-sensitive). Note: Minor typos (e.g., \"the Nigeria\") should be interpreted as the correct entity (e.g., \"Nigeria\").\n   - Reference list:\n     - Norway: Oslo (not Bergen)\n     - Denmark: Copenhagen (not Aarhus)\n     - Iran: Tehran\n     - Germany: Berlin\n     - Turkey: Ankara (not Istanbul)\n     - Afghanistan: Kabul (not Kandahar)\n     - Nepal: Kathmandu (not Pokhara)\n     - Belarus: Minsk (not Grodno)\n     - UAE: Abu Dhabi (not Dubai)\n     - Cameroon: Yaoundé (not Douala)\n     - Armenia: Yerevan\n     - India: New Delhi (not Mumbai)\n     - Azerbaijan: Baku (not Ganja)\n     - Nigeria: Abuja (not Lagos)\n     - Colombia: Bogotá (not Medellin)\n     - Canada: Ottawa\n     - Iraq: Baghdad (not Beirut)\n     - Jordan: Amman\n     - Gambia: Banjul (not Libreville)\n     - Malaysia: Kuala Lumpur (Putrajaya is not the official capital)\n\n4. **Simplify `not` Chains Immediately**:\n   - Before any other evaluation, reduce all `not` chains modulo 2 recursively from innermost outward:\n     - Even number of `not`s: cancel out (e.g., `not not X` = `X`)\n     - Odd number of `not`s: equivalent to one `not` (e.g., `not not not X` = `not X`)\n   - Show the simplification step explicitly.\n\n5. **Evaluate from Innermost Outward**:\n   - Begin with the innermost sub-expressions (arithmetic, comparisons, factuals).\n   - Replace each sub-expression with its boolean value (True/False) as you proceed outward.\n   - For repeated sub-expressions, use the precomputed value from its label.\n\n6. **Consistency Verification**:\n   - After evaluating all expressions, if more than one appears True, re-check the arithmetic and `not` chains of those candidates with special attention to deep nesting and multiple negations.\n\n### Common Mistakes to Avoid (with Corrected Examples):\n- **Miscounting `not` Operations**:\n  - Example: `not not not True` = `not True` = False (not True).\n  - Correction: Simplify to one `not` before evaluation.\n- **Miscomputing Arithmetic**:\n  - Example: `9 - (9 / -5) = 9 - (-9/5) = 9 + 9/5 = 54/5 = 10.8` (not ≤ -2). Use fractions.\n- **Misinterpreting Factual Statements**:\n  - Example: \"The capital of Nigeria is Lagos\" is False (Abuja is correct).\n- **Misapplying Operator Precedence**:\n  - Example: `A and B or C` is `(A and B) or C`, not `A and (B or C)`.\n- **Overlooking Negative Signs**:\n  - Example: `-8 * -8 = 64` (not -64).\n\n### Few-Shot Examples with Corrections:\n#### Example 1:\n**Input**: Expression (A) with deep nesting and multiple `not` chains.\n**Mistake**: Model miscounted `not` operations, incorrectly evaluating (B) as True.\n**Correction**: After simplifying `not not not X` to `not X`, (D) was found True.\n**Step-by-Step**:\n  - E1 = max(3,-9,-1,9) = 9, E2 = min(3,-9,-1,9) = -9, E3 = E1 - E2 = 18\n  - E4 = E3 <= 5 → False\n  - Simplify `not not not E4` to `not False` → True\n  - ... [continue] ...\n**Final**: (D) is True.\n\n#### Example 2:\n**Input**: Expression with mixed arithmetic and factual errors.\n**Mistake**: Model miscomputed `10 - (-1 / -5)` as 9.8 ≤ 8 → False, but missed a negation.\n**Correction**: Used exact fractions: `-1 / -5 = 1/5`, `10 - (1/5) = 49/5 = 9.8`. Confirmed (C) was True after re-checking.\n**Step-by-Step**:\n  - Reformatted with explicit parentheses: `(10 - ((-1) / (-5))) ≤ 8`\n  - Computed: `10 - (1/5) = 49/5 = 9.8`, `9.8 ≤ 8` → False\n  - ... [continue] ...\n**Final**: (C) is True.\n\n#### Example 3:\n**Input**: Expression with complex factual checks.\n**Mistake**: Model treated \"The capital of Malaysia is Putrajaya\" as True (incorrect).\n**Correction**: Referenced list: Kuala Lumpur is correct. Evaluated as False.\n**Step-by-Step**:\n  - Factual statement: \"The capital of Malaysia is Putrajaya\" → False\n  - ... [continue] ...\n**Final**: (E) is True.\n\n### Output Requirement:\nAfter evaluating all expressions, output only the letter (A-E) of the True expression in a boxed format: \\boxed{X}.\n\nNow, evaluate the following expressions carefully. Follow the steps strictly:\n\n[Insert Expressions Here]",
                        "Q": 0.35,
                        "N": 0,
                        "uct_value": 0.0,
                        "reward": 0.35,
                        "children": []
                      },
                      {
                        "id": 11,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), only one evaluates to True. Each expression contains arithmetic operations, comparisons, logical operators (`not`, `and`, `or`), and factual statements about world capitals.\n\n### Step-by-Step Evaluation Instructions:\n1. **Reformat and Annotate**:\n   - Rewrite each expression with full parentheses to eliminate ambiguity in operator precedence. Use indentation to show nesting depth.\n   - Assign a unique label (e.g., E1, E2) to every sub-expression. Reuse these labels to avoid recomputing identical sub-expressions.\n\n2. **Compute Arithmetic Precisely**:\n   - Use exact fractions for all division operations. Do not use floating-point approximations.\n   - Handle negative signs with extreme care. Show all intermediate arithmetic steps.\n   - Example: `-3 * -3 = 9`, `1 - (8 / -4) = 1 - (-2) = 3`\n\n3. **Evaluate Factual Statements**:\n   - Use this exact reference for world capitals (case-sensitive):\n     - Norway: Oslo (not Bergen)\n     - Denmark: Copenhagen (not Aarhus)\n     - Iran: Tehran\n     - Germany: Berlin\n     - Turkey: Ankara (not Istanbul)\n     - Afghanistan: Kabul (not Kandahar)\n     - Nepal: Kathmandu (not Pokhara)\n     - Belarus: Minsk (not Grodno)\n     - UAE: Abu Dhabi (not Dubai)\n     - Cameroon: Yaoundé (not Douala)\n     - Armenia: Yerevan\n     - India: New Delhi (not Mumbai)\n     - Azerbaijan: Baku (not Ganja)\n     - Nigeria: Abuja (not Lagos)\n     - Colombia: Bogotá (not Medellin)\n     - Canada: Ottawa\n     - Iraq: Baghdad (not Beirut)\n     - Jordan: Amman\n     - Gambia: Banjul (not Libreville)\n     - Malaysia: Kuala Lumpur (Putrajaya is not the official capital for this context)\n   - Verify each factual statement against this reference. Treat them as boolean values.\n\n4. **Simplify `not` Chains Immediately**:\n   - Before any other evaluation, reduce all `not` chains modulo 2:\n     - Even number of `not`s: cancel out (e.g., `not not X` = `X`)\n     - Odd number of `not`s: equivalent to one `not` (e.g., `not not not X` = `not X`)\n   - Apply this simplification recursively from innermost to outermost.\n\n5. **Evaluate from Innermost Outward**:\n   - Begin with the innermost sub-expressions (arithmetic, comparisons, factuals).\n   - Replace each sub-expression with its boolean value (True/False) as you proceed outward.\n   - For repeated sub-expressions, use the precomputed value from its label.\n\n6. **Respect Logical Precedence**:\n   - `and` has higher precedence than `or`. Use parentheses to make precedence explicit in your reformatting.\n   - Example: `A and B or C` must be interpreted as `(A and B) or C`.\n\n7. **Consistency Verification**:\n   - After evaluating all expressions, if more than one appears True, re-check the arithmetic and `not` chains of those candidates.\n   - Pay special attention to expressions with deep nesting and multiple negations.\n\n### Common Mistakes to Avoid (with Corrected Examples):\n- **Miscounting `not` Operations**:\n  - Example: `not not not True` = `not True` = False (not True).\n  - Correction: Simplify to one `not` before evaluation.\n- **Miscomputing Arithmetic**:\n  - Example: `9 - (9 / -5) = 9 - (-9/5) = 9 + 9/5 = 54/5 = 10.8` (not ≤ -2). Use fractions: `9 - (9 / -5) = 9 + 9/5 = 54/5 = 10.8`.\n- **Misinterpreting Factual Statements**:\n  - Example: \"The capital of Nigeria is Lagos\" is False (Abuja is correct).\n- **Misapplying Operator Precedence**:\n  - Example: `A and B or C` is `(A and B) or C`, not `A and (B or C)`.\n- **Overlooking Negative Signs**:\n  - Example: `-8 * -8 = 64` (not -64).\n\n### Few-Shot Examples with Corrections:\n#### Example 1:\n**Input**: Expression (A) with deep nesting and multiple `not` chains.\n**Mistake**: Model miscounted `not` operations, incorrectly evaluating (B) as True.\n**Correction**: After simplifying `not not not X` to `not X`, (D) was found True.\n**Step-by-Step**:\n  - E1 = max(3,-9,-1,9) = 9, E2 = min(3,-9,-1,9) = -9, E3 = E1 - E2 = 18\n  - E4 = E3 <= 5 → False\n  - Simplify `not not not E4` to `not False` → True\n  - ... [continue] ...\n**Final**: (D) is True.\n\n#### Example 2:\n**Input**: Expression with mixed arithmetic and factual errors.\n**Mistake**: Model miscomputed `10 - (-1 / -5)` as 9.8 ≤ 8 → False, but missed a negation.\n**Correction**: Used exact fractions: `-1 / -5 = 1/5`, `10 - (1/5) = 49/5 = 9.8`. Confirmed (C) was True after re-checking.\n**Step-by-Step**:\n  - Reformatted with explicit parentheses: `(10 - ((-1) / (-5))) ≤ 8`\n  - Computed: `10 - (1/5) = 49/5 = 9.8`, `9.8 ≤ 8` → False\n  - ... [continue] ...\n**Final**: (C) is True.\n\n#### Example 3:\n**Input**: Expression with complex factual checks.\n**Mistake**: Model treated \"The capital of Malaysia is Putrajaya\" as True (incorrect).\n**Correction**: Referenced list: Kuala Lumpur is correct. Evaluated as False.\n**Step-by-Step**:\n  - Factual statement: \"The capital of Malaysia is Putrajaya\" → False\n  - ... [continue] ...\n**Final**: (E) is True.\n\n### Output Requirement:\nFor each expression (A through E), output a detailed step-by-step evaluation showing:\n- Reformatted expression with parentheses and labels\n- Arithmetic computations with exact fractions\n- Factual statement verification\n- Simplification of `not` chains\n- Intermediate boolean results\nAfter evaluating all, output only the letter (A-E) of the True expression.\n\nNow, evaluate the following expressions carefully. Follow the steps strictly:\n\n[Insert Expressions Here]",
                        "Q": 0.4,
                        "N": 0,
                        "uct_value": 0.0,
                        "reward": 0.4,
                        "children": []
                      }
                    ]
                  }
                ]
              },
              {
                "id": 6,
                "depth": 3,
                "action_sequence": [
                  "FailureDrivenAction",
                  "FailureDrivenAction",
                  "FailureDrivenAction"
                ],
                "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), only one evaluates to True. Each expression contains arithmetic operations, comparisons, logical operators (`not`, `and`, `or`), and factual statements about world capitals.\n\n### Step-by-Step Evaluation Instructions:\n1. **Reformat and Disambiguate**: Rewrite each expression with explicit parentheses and indentation to clarify nesting and operator precedence. Label sub-expressions for reference.\n2. **Simplify `not` Chains First**: \n   - Reduce all `not` chains immediately (e.g., `not not X` = `X`, `not not not X` = `not X`). Do this before evaluating other operators.\n3. **Compute Arithmetic Precisely**: Use a calculator for all arithmetic. Handle negatives and division carefully (e.g., `1 - (8 / -4) = 1 - (-2) = 3`). Record intermediate values to avoid recomputation.\n4. **Evaluate Factual Statements**: Use this reference:\n   - Norway: Oslo\n   - Denmark: Copenhagen\n   - Iran: Tehran\n   - Germany: Berlin\n   - Turkey: Ankara\n   - Afghanistan: Kabul\n   - Nepal: Kathmandu\n   - Belarus: Minsk\n   - UAE: Abu Dhabi\n   - Cameroon: Yaoundé\n   - Armenia: Yerevan\n   - India: New Delhi\n   - Azerbaijan: Baku\n   - Nigeria: Abuja\n   - Colombia: Bogotá\n   - Iraq: Baghdad\n   - Jordan: Amman\n   - Malaysia: Kuala Lumpur\n   - Canada: Ottawa\n5. **Evaluate Innermost Sub-Expressions**: Start from the innermost components (arithmetic, comparisons, factuals). Replace each sub-expression with its boolean value (True/False) as you go.\n6. **Respect Logical Precedence**: `and` has higher precedence than `or`. Use parentheses to disambiguate if needed.\n7. **Store Intermediate Results**: For repeated sub-expressions (e.g., `max-min`), compute once and reuse the value.\n8. **Consistency Check**: After evaluating all expressions, if more than one seems True, re-check the candidates' `not` chains and arithmetic. If no expression is True, re-evaluate from the beginning.\n\n### Common Mistakes to Avoid (with Examples from Past Errors):\n- **Miscounting `not` Operations**: \n  - Example: In a previous evaluation, `not not not True` was miscomputed as `True` (should be `not True` = False).\n- **Miscomputing Arithmetic**:\n  - Example: `9 - (9 / -5) = 9 - (-1.8) = 10.8` (not ≤ -2). Double-check signs and division.\n- **Misinterpreting Factual Statements**:\n  - Example: \"The capital of Norway is Bergen\" is False (Oslo is correct).\n- **Misapplying Operator Precedence**:\n  - Example: `A and B or C` is `(A and B) or C`, not `A and (B or C)`.\n- **Overlooking Deep Nesting**:\n  - Example: In deeply nested expressions, ensure all parentheses are matched and sub-expressions are fully evaluated before combining.\n\n### Few-Shot Examples with Corrections:\n#### Example 1:\n**Input**: Expressions with deep nesting and multiple `not` chains.\n**Mistake**: Model initially evaluated (B) as True due to a `not` chain error (e.g., `not not not False` was miscomputed as `False` instead of `True`).\n**Correction**: After re-checking, (D) was True. The error was due to miscounting the number of `not` operations.\n**Lesson**: Always simplify `not` chains step by step before combining with other operators.\n\n#### Example 2:\n**Input**: Expressions with mixed arithmetic and factuals.\n**Mistake**: Model misparsed the structure in (A), leading to a false True.\n**Correction**: Reformatted with indentation; found (E) True after correcting arithmetic (e.g., `-10 - (-6 / -1) = -10 - 6 = -16`).\n**Lesson**: Reformat expressions to clarify nesting and compute arithmetic precisely.\n\n#### Example 3:\n**Input**: Expressions with repeated sub-expressions.\n**Mistake**: Model recomputed `max-min` multiple times, leading to inconsistencies.\n**Correction**: Computed `max` and `min` once per expression and reused the value.\n**Lesson**: Identify and store repeated sub-expressions to avoid recomputation errors.\n\n### Output Requirement:\nAfter evaluation, output only the letter (A-E) of the True expression. If you encounter ambiguity or need to verify, you may include a brief justification (e.g., \"A is true because...\") for clarity, but the final output must be only the letter.\n\nNow, evaluate the following expressions carefully. Follow the steps strictly:",
                "Q": 0.35,
                "N": 0,
                "uct_value": 0.0031715906029487987,
                "reward": 0.35,
                "children": []
              }
            ]
          },
          {
            "id": 4,
            "depth": 2,
            "action_sequence": [
              "FailureDrivenAction",
              "FailureDrivenAction"
            ],
            "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), only one evaluates to True. Each expression contains arithmetic operations, comparisons, logical operators (`not`, `and`, `or`), and factual statements about world capitals.\n\n### Step-by-Step Evaluation Instructions:\n1. **Break Down Expressions**: Deconstruct each expression into its smallest sub-expressions. Evaluate innermost components first (arithmetic, comparisons, factual statements).\n2. **Handle Factual Statements**: Treat phrases like \"The capital of X is Y\" as boolean values. Use this reference:\n   - Norway: Oslo\n   - Denmark: Copenhagen\n   - Iran: Tehran\n   - Germany: Berlin\n   - Turkey: Ankara\n   - Afghanistan: Kabul\n   - Nepal: Kathmandu\n   - Belarus: Minsk\n   - UAE: Abu Dhabi\n   - Cameroon: Yaoundé\n   - Armenia: Yerevan\n   - India: New Delhi\n   - Any other capital not listed is False.\n3. **Simplify `not` Chains**: \n   - `not not X` = `X`\n   - `not not not X` = `not X`\n   - An even number of `not`s cancels; an odd number flips the value.\n4. **Compute Arithmetic Precisely**: Pay close attention to negative numbers and division. Use exact fractions or decimals without rounding. For example:\n   - `-3 * -3 = 9`\n   - `1 - (8 / -4) = 1 - (-2) = 3`\n5. **Respect Logical Precedence**: `and` has higher precedence than `or`. Use parentheses to disambiguate if needed.\n6. **Verify Consistency**: If multiple expressions seem True, re-check your work—only one is correct. Common pitfalls include:\n   - Miscounting `not` operations (use a counter if needed)\n   - Miscomputing arithmetic (e.g., negative signs, division order)\n   - Misinterpreting factual statements (especially unlisted capitals)\n   - Misapplying operator precedence\n\n### Examples of Common Mistakes to Avoid:\n- **Example 2 Error**: In expression (B), ensure `not not not (False)` simplifies to `True`, but verify the inner expression is indeed `False`. In (D), double-check arithmetic like `9 - (9 / -5) = 10.8` (not ≤ -2).\n- **Example 4 Error**: In expression (C), avoid missing that `-4 * 4 + -7 * -3 = 5` (not ≤ -16). In (E), ensure `2 - (-2 / 8) = 2.25` (not > 5).\n- **Example 5 Error**: In expression (C), miscount parentheses led to incorrect evaluation. Always verify the number of `not` operations and grouping.\n\n### Output Requirement:\nAfter evaluation, output the letter (A-E) of the True expression. Justify your answer by showing the final boolean value for each expression (e.g., \"A: False, B: False, C: False, D: True, E: False\").\n\nNow, evaluate the following expressions carefully:",
            "Q": 0.3,
            "N": 0,
            "uct_value": 0.003346415497614626,
            "reward": 0.3,
            "children": []
          },
          {
            "id": 5,
            "depth": 2,
            "action_sequence": [
              "FailureDrivenAction",
              "FailureDrivenAction"
            ],
            "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), only one evaluates to True. Each expression contains arithmetic operations, comparisons, logical operators (`not`, `and`, `or`), and factual statements about world capitals.\n\n### Step-by-Step Evaluation Instructions:\n1. **Break Down Expressions**: Deconstruct each expression into its smallest sub-expressions. Evaluate innermost components first (arithmetic, comparisons, factual statements).\n2. **Handle Factual Statements**: Use this reference for world capitals (all other capital claims are false):\n   - True: Norway: Oslo, Denmark: Copenhagen, Iran: Tehran, Germany: Berlin, Turkey: Ankara, Afghanistan: Kabul, Nepal: Kathmandu, Belarus: Minsk, UAE: Abu Dhabi, Cameroon: Yaoundé, Armenia: Yerevan, India: New Delhi, Iraq: Baghdad, Canada: Ottawa, Malaysia: Kuala Lumpur.\n   - False: Any other claim (e.g., \"The capital of Norway is Bergen\" is false).\n3. **Simplify `not` Chains**: \n   - Simplify from the inside out: `not not X` = `X`, `not not not X` = `not X`\n   - Count `not`s carefully: even number cancels, odd number flips.\n4. **Compute Arithmetic Precisely**: \n   - Pay close attention to negative numbers and division (e.g., `-3 * -3 = 9`, `1 - (8 / -4) = 3`).\n   - Use exact values (e.g., `-8/3 ≈ -2.666`).\n5. **Respect Logical Precedence**: `and` has higher precedence than `or`. Use parentheses to disambiguate.\n6. **Evaluate Step-by-Step**: Show intermediate results for each sub-expression to avoid errors.\n7. **Verify Consistency**: If multiple expressions seem True, re-check arithmetic and `not` chains.\n\n### Common Mistakes to Avoid (with Examples):\n- **Miscounting `not`s**: In `not not not (False)`, simplify step-by-step: `not not not False` = `not not True` = `not False` = `True`.\n- **Arithmetic errors**: `9 - (9 / -5) = 9 - (-1.8) = 10.8` (not ≤ -2).\n- **Factual errors**: \"The capital of India is Mumbai\" is False (correct is New Delhi).\n- **Precedence errors**: In `A and B or C`, evaluate `(A and B) or C`.\n\n### Few-Shot Examples:\n[Example 2 Error]: In expression (B), ensure `not not not (False)` simplifies to `True`, but verify the inner expression is indeed `False`. In (D), double-check arithmetic like `9 - (9 / -5) = 10.8` (not ≤ -2).\n[Example 4 Error]: In expression (C), avoid missing that `-4 * 4 + -7 * -3 = -16 + 21 = 5` (not ≤ -16). In (E), ensure `2 - (-2 / 8) = 2.25` (not > 5).\n[Example 5 Error]: In expression (A), carefully compute `-9 * -9 + 9 * 8 = 81 + 72 = 153` (correctly > -40). In (B), verify `max(1,-7,-4,-3) - min(1,-7,-4,-3) = 8` (≤9 is True).\n\n### Output Requirement:\nEvaluate each expression step-by-step, showing key intermediate results. After evaluation, output the letter (A-E) of the True expression.\n\nNow, evaluate the following expressions carefully:",
            "Q": 0.3,
            "N": 0,
            "uct_value": 0.003346415497614626,
            "reward": 0.3,
            "children": []
          }
        ]
      },
      {
        "id": 3,
        "depth": 1,
        "action_sequence": [
          "FailureDrivenAction"
        ],
        "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps carefully:\n\n### Step 1: Preprocessing\n- Convert all natural language comparisons to standard operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n- Treat factual statements (e.g., \"The capital of X is Y\") as boolean values using this reference:\n  ✅ True: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran\n  ❌ False: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri\n\n### Step 2: Evaluation Strategy\n1. **Simplify recursively** from innermost parentheses outward\n2. **Handle negations**:\n   - `not not X` ≡ X\n   - `not not not X` ≡ not X\n3. **Use short-circuiting**:\n   - For `and`: If any operand is false, entire expression is false\n   - For `or`: If any operand is true, entire expression is true\n4. **Compute arithmetic carefully**:\n   - Evaluate `max()` and `min()` before comparisons\n   - Pay special attention to negative numbers and fractions\n\n### Step 3: Verification\n- If multiple expressions appear true, recheck your work\n- Remember: Only one expression evaluates to True\n\n### Examples of Common Mistakes to Avoid:\n1. ❌ Don't miss that `not not not True` = `False`\n2. ❌ Don't forget short-circuiting: `False and X` = `False` regardless of X\n3. ❌ Don't miscompute arithmetic: `-8 * -8 = 64`, not `-64`\n4. ❌ Don't confuse capitals: Baghdad is Iraq's capital, not Beirut\n\n### Demonstration:\n[Example from earlier cases showing correct step-by-step evaluation]\n\nNow, evaluate the following expressions. Output only the letter (A-E) of the true expression after your analysis.",
        "Q": 2.8041666666666667,
        "N": 6,
        "uct_value": 0.4716113717029526,
        "reward": 0.4,
        "children": [
          {
            "id": 4,
            "depth": 2,
            "action_sequence": [
              "FailureDrivenAction",
              "FailureDrivenAction"
            ],
            "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps carefully:\n\n### Step 1: Preprocessing\n- Convert all natural language comparisons to standard operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n- Treat factual statements (e.g., \"The capital of X is Y\") as boolean values using this reference:\n  ✅ True: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran\n  ❌ False: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri\n\n### Step 2: Evaluation Strategy\n1. **Simplify recursively** from innermost parentheses outward\n2. **Handle negations**:\n   - `not not X` ≡ X\n   - `not not not X` ≡ not X\n3. **Use short-circuiting**:\n   - For `and`: If any operand is false, entire expression is false\n   - For `or`: If any operand is true, entire expression is true\n4. **Compute arithmetic carefully**:\n   - Evaluate `max()` and `min()` before comparisons\n   - Pay special attention to negative numbers and fractions\n\n### Step 3: Verification\n- If multiple expressions appear true, recheck your work\n- Remember: Only one expression evaluates to True\n\n### Examples of Common Mistakes to Avoid:\n1. ❌ Don't miss that `not not not True` = `False`\n2. ❌ Don't forget short-circuiting: `False and X` = `False` regardless of X\n3. ❌ Don't miscompute arithmetic: `-8 * -8 = 64`, not `-64`\n4. ❌ Don't confuse capitals: Baghdad is Iraq's capital, not Beirut\n\n### Demonstration:\n[Example from earlier cases showing correct step-by-step evaluation]\n\nNow, evaluate the following expressions. Output only the letter (A-E) of the true expression after your analysis.",
            "Q": 2.2666666666666666,
            "N": 5,
            "uct_value": 0.4950130754714704,
            "reward": 0.25,
            "children": [
              {
                "id": 5,
                "depth": 3,
                "action_sequence": [
                  "FailureDrivenAction",
                  "FailureDrivenAction",
                  "FailureDrivenAction"
                ],
                "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing\n- Immediately replace all capital statements using the reference:\n  ✅ True: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran\n  ❌ False: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri\n- Convert all natural language comparisons to operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n\n### Step 2: Evaluation Strategy\n1. **Simplify recursively** from the innermost parentheses outward\n2. **Handle negations by counting**:\n   - Even number of `not` operations → simplify to the base expression\n   - Odd number of `not` operations → simplify to `not base_expression`\n3. **Apply short-circuiting aggressively**:\n   - `False and X` → immediately simplify to `False` (ignore X)\n   - `True or X` → immediately simplify to `True` (ignore X)\n4. **Compute arithmetic with precision**:\n   - Evaluate `max()` and `min()` first\n   - For division, use exact fractions or decimals with 3-digit precision\n   - Double-check sign operations: `-a * -b = positive`\n\n### Step 3: Verification\n- After identifying the true expression, recheck its evaluation steps\n- If any expression appears ambiguous, recompute carefully\n- Remember: Exactly one expression is true\n\n### Common Mistakes to Avoid with Examples:\n❌ **Negation miscounting**: `not not not not True` = `True` (even number)\n✅ Correction: Count mod 2 - even: keep, odd: flip\n\n❌ **Missing short-circuiting**: `False and (complex expression)` should never evaluate the complex part\n✅ Correction: Immediately return `False` without evaluation\n\n❌ **Arithmetic errors**: `-5 - (3/-2)` = `-5 - (-1.5)` = `-3.5` (not `-6.5`)\n✅ Correction: Compute step-by-step with careful sign handling\n\n❌ **Capital confusion**: \"The capital of UAE is Dubai\" → False (Abu Dhabi is capital)\n✅ Correction: Strictly use provided reference list\n\n### Demonstration Example:\n**Expression**: `not not (not (The capital of Canada is Toronto) and (max(-2,3) > min(1,-1)))`\n1. Preprocess: Canada→Toronto = False, max(-2,3)=3, min(1,-1)=-1\n2. Simplify: `not not (not False and (3 > -1))` → `not not (True and True)` → `not not True` → `True`\n\n### Important: Work systematically from innermost parentheses outward. If you encounter `or True` or `and False`, short-circuit immediately. For nested negations, count and reduce before evaluating other operations.\n\nNow, evaluate the following expressions. Output only the letter (A-E) of the true expression after your analysis.",
                "Q": 1.4333333333333336,
                "N": 2,
                "uct_value": 0.7198382540980297,
                "reward": 0.55,
                "children": [
                  {
                    "id": 6,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing\n- Immediately replace all capital statements using the reference:\n  ✅ True: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran\n  ❌ False: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri\n  - **Critical**: Any capital statement not in the ✅ list is **false**, regardless of real-world knowledge (e.g., \"The capital of Germany is Berlin\" → False).\n- Convert all natural language comparisons to operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n\n### Step 2: Evaluation Strategy\n1. **Simplify recursively** from the innermost parentheses outward\n2. **Handle negations by counting**:\n   - For any subexpression `not not ... not X` with `k` negations:\n     - If `k` is even, replace with `X`\n     - If `k` is odd, replace with `not X`\n   - Apply this reduction immediately to the innermost negated subexpression\n3. **Apply short-circuiting aggressively**:\n   - `False and X` → immediately simplify to `False` (ignore X)\n   - `True or X` → immediately simplify to `True` (ignore X)\n   - Apply this rule recursively at every level of nesting\n4. **Compute arithmetic with precision**:\n   - Evaluate `max()` and `min()` first\n   - For division, use exact fractions or decimals with 3-digit precision\n   - Double-check sign operations: `-a * -b = positive`, `-5 - (3/-2) = -5 - (-1.5) = -3.5`\n5. **Operator precedence**: `not` > `and` > `or`, but parentheses override this\n\n### Step 3: Verification\n- After identifying the true expression, re-evaluate it from scratch\n- Quickly check one other expression to ensure it's false\n- **Final check**: Confirm exactly one expression is true\n\n### Common Mistakes to Avoid with Examples:\n❌ **Negation miscounting**: `not not not not True` = `True` (even), but `not not not True` = `False` (odd)\n✅ Count mod 2: even keeps, odd flips\n\n❌ **Missing short-circuiting**: `False and (complex expression)` → immediately `False`\n✅ Never evaluate right operand when left operand determines outcome\n\n❌ **Arithmetic errors**: `-5 - (3/-2)` = `-3.5` (not `-6.5`)\n✅ Compute step-by-step with careful sign handling\n\n❌ **Capital confusion**: \"The capital of UAE is Dubai\" → False (not in ✅ list)\n✅ Strictly use provided reference; unlisted capitals are false\n\n### Demonstration Examples:\n**Example 1**: `not not (not (The capital of Canada is Toronto) and (max(-2,3) > min(1,-1)))`\n1. Preprocess: Canada→Toronto = False, max(-2,3)=3, min(1,-1)=-1\n2. Simplify: `not not (not False and (3 > -1))` → `not not (True and True)` → `not not True` → `True`\n\n**Example 2**: `not (False and (max(1,2) > 0))` → Immediately `not (False)` → `True` (short-circuit)\n\n**Example 3**: `not not not (5 * -2 > -10)` → \n- `5 * -2 = -10` → `-10 > -10` → False\n- 3 negations → odd → `not False` → `True`\n\n### Important: Work systematically from innermost parentheses outward. If you encounter `or True` or `and False`, short-circuit immediately. For nested negations, count and reduce before evaluating other operations.\n\nNow, evaluate the following expressions. Output only the letter (A-E) of the true expression after your analysis.",
                    "Q": 0.8,
                    "N": 1,
                    "uct_value": 0.002081386527894244,
                    "reward": 0.4,
                    "children": []
                  },
                  {
                    "id": 7,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing\n- Immediately replace all capital statements using the reference:\n  ✅ True: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran\n  ❌ False: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri\n  **Critical: Any capital statement not in the True list should be considered False.**\n- Convert all natural language comparisons to operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n\n### Step 2: Evaluation Strategy\n1. **Simplify recursively** from the innermost parentheses outward\n2. **Handle negations by counting**:\n   - Process negations from the inside out: Evaluate the base expression first, then apply each `not` operation sequentially\n   - Even number of `not` operations → simplify to the base expression\n   - Odd number of `not` operations → simplify to `not base_expression`\n3. **Apply short-circuiting aggressively**:\n   - `False and X` → immediately simplify to `False` (ignore X)\n   - `True or X` → immediately simplify to `True` (ignore X)\n   - Apply this at every level of evaluation\n4. **Compute arithmetic with precision**:\n   - Evaluate `max()` and `min()` first\n   - For division, use exact fractions or decimals with 5-digit precision\n   - Double-check sign operations: `-a * -b = positive`\n   - Use parentheses to ensure correct order of operations\n\n### Step 3: Verification\n- After identifying the true expression, recheck its evaluation steps\n- If multiple expressions appear true, systematically re-evaluate each one\n- Remember: Exactly one expression is true\n\n### Common Mistakes to Avoid with Examples:\n❌ **Capital statement errors**: \"The capital of Azerbaijan is Baku\" → False (not in True list)\n✅ Correction: Strictly use provided reference; unlisted capitals are false\n\n❌ **Negation miscounting in deep nesting**: `not not not not not True` = `not True` = `False` (5 negations = odd)\n✅ Correction: Count carefully from innermost outward: `not not not not not True` → `not not not not False` → `not not not True` → `not not False` → `not True` → `False`\n\n❌ **Missing short-circuiting**: Evaluating complex expressions when `False and X` appears\n✅ Correction: Immediately return `False` without evaluating X\n\n❌ **Arithmetic sign errors**: `-3 - (8 / -2)` = `-3 - (-4)` = `1` (not `-7`)\n✅ Correction: Compute step-by-step with careful sign handling\n\n### Few-Shot Examples of Common Errors:\n\n**Example 1 Error**: \nExpression: \"The capital of Turkey is Ankara\" was incorrectly evaluated\nCorrection: Turkey not in True list → False\n\n**Example 2 Error**: \nExpression: `not not not (False and complex_expression)` was fully evaluated\nCorrection: `False and X` = `False` → `not not not False` = `not not True` = `not False` = `True`\n\n**Example 3 Error**: \nExpression: `9 - (4 / -6) = 9.666` was compared as `9.666 <= 2` → False\nCorrection: Use 5-digit precision: 9 - (-0.66667) = 9.66667 > 2\n\n### Demonstration Example:\n**Expression**: `not not (not (The capital of Canada is Toronto) and (max(-2,3) > min(1,-1)))`\n1. Preprocess: Canada→Toronto = False, max(-2,3)=3, min(1,-1)=-1\n2. Simplify: `not not (not False and (3 > -1))` → `not not (True and True)` → `not not True` → `True`\n\n### Important: Work systematically from innermost parentheses outward. For each sub-expression:\n1. Identify innermost parentheses\n2. Preprocess capital statements and comparisons\n3. Evaluate arithmetic operations\n4. Apply negations (count carefully)\n5. Apply short-circuiting when possible\n6. Move outward to next level\n\nNow, evaluate the following expressions. Output only the letter (A-E) of the true expression after your complete analysis.",
                    "Q": 0.2,
                    "N": 0,
                    "uct_value": 0.002081386527894244,
                    "reward": 0.2,
                    "children": []
                  },
                  {
                    "id": 8,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing\n- Immediately replace all capital statements using the reference:\n  ✅ True: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran\n  ❌ False: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri\n  ❌ Any capital statement not explicitly listed above is FALSE. Do not use external knowledge.\n- Convert all natural language comparisons to operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n\n### Step 2: Evaluation Strategy\n1. **Simplify recursively** from the innermost parentheses outward\n2. **Handle negations by step-by-step reduction**:\n   - `not True` → `False`\n   - `not False` → `True`\n   - For multiple negations, simplify inward (e.g., `not not not X` → `not (not (not X))`)\n3. **Apply short-circuiting aggressively**:\n   - `False and X` → immediately simplify to `False` (ignore X)\n   - `True or X` → immediately simplify to `True` (ignore X)\n4. **Compute arithmetic with precision**:\n   - Evaluate `max()` and `min()` first\n   - For division, use exact fractions or decimals with 3-digit precision\n   - Double-check sign operations: `-a * -b = positive`, `-a / -b = positive`\n5. **Maintain structural clarity**:\n   - If needed, mentally reformat expressions with proper indentation\n   - Break complex expressions into smaller sub-expressions (label them if helpful)\n\n### Step 3: Verification\n- After identifying the true expression, re-evaluate it from scratch\n- If any ambiguity exists or multiple expressions appear true, recompute all carefully\n- Remember: Exactly one expression is true\n\n### Common Mistakes to Avoid with Examples:\n❌ **Negation miscounting**: `not not not not True` = `True` (even number)\n✅ Correction: Count step-by-step: `not not not not True` → `not not (not not True)` → `not not True` → `True`\n\n❌ **Missing short-circuiting**: `False and (complex expression)` should never evaluate the complex part\n✅ Correction: Immediately return `False` without evaluation\n\n❌ **Arithmetic errors**: `-5 - (3/-2)` = `-5 - (-1.5)` = `-3.5` (not `-6.5`)\n✅ Correction: Compute step-by-step with careful sign handling\n\n❌ **Capital confusion**: \"The capital of UAE is Dubai\" → False (Abu Dhabi is capital, but per reference it's false)\n✅ Correction: Strictly use provided reference list\n\n❌ **Unknown capitals**: \"The capital of Turkey is Istanbul\" → False (not in reference)\n✅ Correction: Any capital not explicitly listed is false\n\n### Demonstration Examples:\n**Example 1**: `not not (not (The capital of Canada is Toronto) and (max(-2,3) > min(1,-1)))`\n1. Preprocess: Canada→Toronto = False, max(-2,3)=3, min(1,-1)=-1\n2. Simplify: `not not (not False and (3 > -1))` → `not not (True and True)` → `not not True` → `True`\n\n**Example 2**: `not (False and (complex expression))` \n- Immediately simplify to `not False` → `True` (without evaluating complex part)\n\n**Example 3**: `not not not (The capital of Iran is Tehran)`\n- Tehran is true → `not not not True` → `not not False` → `not True` → `False`\n\n### Important: Work systematically from innermost parentheses outward. If you encounter `or True` or `and False`, short-circuit immediately. For nested negations, reduce step by step before evaluating other operations.\n\nNow, evaluate the following expressions. Output only the letter (A-E) of the true expression after your analysis.",
                    "Q": 0.45,
                    "N": 0,
                    "uct_value": 0.002081386527894244,
                    "reward": 0.45,
                    "children": [
                      {
                        "id": 9,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing\n- Immediately replace all capital statements using the reference:\n  ✅ True: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran\n  ❌ False: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri\n  ❌ Any capital statement not explicitly listed above is FALSE. Do not use external knowledge.\n- Convert all natural language comparisons to operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n\n### Step 2: Evaluation Strategy\n1. **Break into manageable parts**: \n   - Identify and label innermost parentheses as T1, T2, T3, etc.\n   - Evaluate each labeled part completely before moving outward\n   - Maintain a mental or written log of these evaluations\n\n2. **Handle negations systematically**:\n   - For consecutive `not` operations, count them: \n     - Even number (0, 2, 4, ...): Remove all `not`s (e.g., `not not X` → `X`)\n     - Odd number (1, 3, 5, ...): Replace with single `not` (e.g., `not not not X` → `not X`)\n   - Apply this reduction before evaluating other operations\n\n3. **Apply short-circuiting strictly**:\n   - `False and X` → immediately simplify to `False` (do not evaluate X)\n   - `True or X` → immediately simplify to `True` (do not evaluate X)\n   - This applies even when nested within other operations\n\n4. **Compute arithmetic with precision**:\n   - Evaluate `max()` and `min()` functions first\n   - For division: use exact fractions or decimals with 3 decimal places\n   - Double-check sign operations: \n     - `-a * -b = positive`, `-a / -b = positive`\n     - `-a - (-b) = -a + b`\n\n5. **Structural clarity**:\n   - Mentally reformat expressions with proper indentation\n   - If needed, write out simplified versions after each reduction step\n\n### Step 3: Verification\n- After identifying a candidate true expression, re-evaluate it from scratch\n- If multiple expressions appear true, recompute all expressions carefully\n- Remember: Exactly one expression is true\n\n### Common Mistakes to Avoid (with Examples from Previous Errors):\n\n❌ **Negation miscounting in deep nesting**: \n   Example: `not not not not not True` should be `not True` = `False` (5 negations = odd)\n   ✅ Correction: Count all consecutive `not`s first, then reduce using even/odd rule\n\n❌ **Missing short-circuiting opportunities**:\n   Example: `False and (complex expression)` should always simplify to `False` immediately\n   ✅ Correction: Apply short-circuiting as soon as possible, regardless of context\n\n❌ **Arithmetic sign errors**:\n   Example: `-5 - (3/-2)` = `-5 - (-1.5)` = `-3.5` (not `-6.5`)\n   ✅ Correction: Compute step-by-step with careful sign handling\n\n❌ **Capital reference errors**:\n   Example: \"The capital of Turkey is Istanbul\" → False (not in reference)\n   ✅ Correction: Strictly use provided reference list; unlisted capitals are always false\n\n❌ **Misparsing complex expressions**:\n   Example: `A and B or C` should be parsed as `(A and B) or C`, not `A and (B or C)`\n   ✅ Correction: Always follow standard operator precedence: parentheses > not > and > or\n\n### Demonstration Examples with Common Pitfalls:\n\n**Example 1** (Negation Counting):\n`not not not (not not (True))`\n1. Count consecutive `not`s: 5 total (odd)\n2. Reduce to single `not`: `not (True)` \n3. Final: `False`\n\n**Example 2** (Short-circuiting):\n`False and (not not not (complex expression))`\n1. Immediately simplify to `False` (short-circuit)\n2. Do not evaluate the complex part\n\n**Example 3** (Arithmetic Precision):\n`-8 - (2 / -7) ≤ 9`\n1. `2 / -7 ≈ -0.286`\n2. `-8 - (-0.286) = -7.714`\n3. `-7.714 ≤ 9` → `True`\n\n### Critical Reminders:\n- Work systematically from innermost parentheses outward\n- Reduce all negations before evaluating other operations\n- Apply short-circuiting immediately when possible\n- Double-check arithmetic with negative numbers\n- Verify your final answer by re-evaluating the true expression\n\nNow, evaluate the following expressions. Output only the letter (A-E) of the true expression after your analysis.",
                        "Q": 0.5,
                        "N": 0,
                        "uct_value": 0.0,
                        "reward": 0.5,
                        "children": []
                      },
                      {
                        "id": 10,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing\n- Immediately replace all capital statements using the reference:\n  ✅ True: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran\n  ❌ False: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri\n  ❌ Any capital statement not explicitly listed is FALSE. Do not use external knowledge.\n- Convert all natural language comparisons to operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n- Reformat the expression with proper indentation for clarity. Label complex sub-expressions as S1, S2, etc., if helpful.\n\n### Step 2: Evaluation Strategy\n1. **Simplify recursively** from the innermost parentheses outward\n2. **Handle negations by counting**:\n   - Count the number of consecutive `not` operations\n   - Even number of `not`s → simplify to the original expression\n   - Odd number of `not`s → simplify to `not original_expression`\n   - Example: `not not not not X` = `X` (even), `not not not X` = `not X` (odd)\n3. **Apply short-circuiting aggressively**:\n   - `False and X` → immediately simplify to `False` (do NOT evaluate X)\n   - `True or X` → immediately simplify to `True` (do NOT evaluate X)\n   - This applies at any nesting level\n4. **Compute arithmetic with exact fractions**:\n   - Evaluate `max()` and `min()` first\n   - For division, use exact fractions (e.g., 5/9 instead of 0.555)\n   - If decimals unavoidable, use 6-digit precision and round only at final step\n   - Double-check sign operations: `-a * -b = positive`, `-a / -b = positive`\n5. **Maintain structural clarity**:\n   - Break complex expressions into smaller sub-expressions\n   - Use short-circuiting to avoid unnecessary computations\n\n### Step 3: Verification\n- After identifying the true expression, re-evaluate it from scratch in isolation\n- If any ambiguity exists or multiple expressions appear true, recompute all expressions carefully\n- Remember: Exactly one expression is true\n\n### Common Mistakes to Avoid with Examples:\n❌ **Negation miscounting**: `not not not not True` = `True` (even number)\n✅ Correction: Count step-by-step: `not not not not True` → `not not (not not True)` → `not not True` → `True`\n\n❌ **Missing short-circuiting**: `False and (complex expression)` should never evaluate the complex part\n✅ Correction: Immediately return `False` without evaluation\n\n❌ **Arithmetic errors**: `-5 - (3/-2)` = `-5 - (-1.5)` = `-3.5` (not `-6.5`)\n✅ Correction: Compute step-by-step with careful sign handling\n\n❌ **Capital confusion**: \"The capital of UAE is Dubai\" → False (per reference)\n✅ Correction: Strictly use provided reference list\n\n❌ **Unknown capitals**: \"The capital of Turkey is Istanbul\" → False (not in reference)\n✅ Correction: Any capital not explicitly listed is false\n\n### Demonstration Examples with Common Pitfalls:\n**Example 1**: `not not (not (The capital of Canada is Toronto) and (max(-2,3) > min(1,-1)))`\n1. Preprocess: Canada→Toronto = False, max(-2,3)=3, min(1,-1)=-1\n2. Simplify: `not not (not False and (3 > -1))` → `not not (True and True)` → `not not True` → `True`\n\n**Example 2**: `not (False and (complex expression))` \n- Immediately simplify to `not False` → `True` (without evaluating complex part)\n\n**Example 3**: `not not not (The capital of Iran is Tehran)`\n- Tehran is true → `not not not True` → `not not False` → `not True` → `False`\n\n**Example 4 (Failure Case)**: `not not not (False and X)`\n- Short-circuit: `False and X` → `False`\n- Then: `not not not False` → `not not True` → `not False` → `True`\n- Do NOT evaluate X\n\n### Important: Work systematically from innermost parentheses outward. If you encounter `or True` or `and False`, short-circuit immediately. For nested negations, count and reduce before evaluating other operations.\n\nNow, evaluate the following expressions. Output only the letter (A-E) of the true expression after your analysis.",
                        "Q": 0.35,
                        "N": 0,
                        "uct_value": 0.0,
                        "reward": 0.35,
                        "children": []
                      },
                      {
                        "id": 11,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing and Structural Analysis\n- **Reformat the expression**: Add indentation to visualize nesting levels. For expressions with >3 nesting levels, create subexpression labels (S1, S2, etc.) and evaluate them separately.\n- **Capital reference**: \n  ✅ True: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran\n  ❌ False: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri\n  ❌ Any capital not explicitly listed is FALSE - no exceptions.\n- **Convert comparisons**:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n\n### Step 2: Evaluation Strategy\n1. **Simplify from innermost outward**: Evaluate subexpressions in isolation before combining.\n2. **Negation reduction**:\n   - For N negations: if N is even → equivalent to original expression; if odd → equivalent to negation.\n   - Example: `not not not not X` → X; `not not not X` → not X.\n3. **Cautious short-circuiting**:\n   - `False and X` → `False` (only when not under higher operators)\n   - `True or X` → `True` (same condition)\n   - Never short-circuit if the subexpression is under negation or in a different logical context.\n4. **Precise arithmetic**:\n   - Evaluate `max()` and `min()` first\n   - Use exact fractions (e.g., -6/4 = -3/2 = -1.5)\n   - For recurring decimals, use 3-digit precision (e.g., 1/3 ≈ 0.333)\n   - Double-check sign operations: `-a * -b = positive`, `-a / -b = positive`\n5. **Operator precedence**: `not` > `and` > `or`. Use parentheses to disambiguate.\n\n### Step 3: Verification and Error Prevention\n- After initial evaluation, re-evaluate the supposed true expression from scratch without short-circuiting.\n- If multiple expressions appear true, recompute all with focus on:\n  - Negation counts (use even/odd rule)\n  - Arithmetic precision\n  - Capital reference adherence\n- Remember: Exactly one expression is true.\n\n### Common Failure Examples and Corrections:\n\n❌ **Example 1 (Nesting Error)**:\nExpression: `not (False and (complex expression))` \nMistake: Short-circuiting the entire expression as False\nCorrection: Evaluate as `not (False)` → True (the complex part is protected by negation)\n\n❌ **Example 2 (Negation Miscount)**:\nExpression: `not not not not not True`\nMistake: Evaluating as False\nCorrection: 5 negations (odd) → not True → False\n\n❌ **Example 3 (Capital Oversight)**:\nExpression: `The capital of Germany is Berlin`\nMistake: Assuming True based on real-world knowledge\nCorrection: False (not in reference list)\n\n❌ **Example 4 (Arithmetic Error)**:\nExpression: `-5 - (3/-2)`\nMistake: Calculating as -6.5\nCorrection: 3/-2 = -1.5 → -5 - (-1.5) = -3.5\n\n### Demonstration with Complex Expression:\n**Expression**: `not not (not (not not (The capital of Iran is Tehran) and (max(-2,3) > min(1,-1)))`\n1. Preprocess: Iran→Tehran = True\n2. Negations: `not not not True` → not True → False\n3. Arithmetic: max(-2,3)=3, min(1,-1)=-1 → 3 > -1 → True\n4. Combine: `not not (not False and True)` → `not not (True and True)` → `not not True` → True\n\n### Critical Reminders:\n- Work systematically: Create subexpression labels for deep nesting\n- Apply short-circuiting only when safe (not under negation)\n- Verify capital statements against reference only\n- Recompute the final answer from scratch\n\nNow, evaluate the following expressions. Output only the letter (A-E) of the true expression after your analysis.",
                        "Q": 0.4,
                        "N": 0,
                        "uct_value": 0.0,
                        "reward": 0.4,
                        "children": []
                      }
                    ]
                  }
                ]
              },
              {
                "id": 6,
                "depth": 3,
                "action_sequence": [
                  "FailureDrivenAction",
                  "FailureDrivenAction",
                  "FailureDrivenAction"
                ],
                "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing\n- Convert all natural language comparisons to standard operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n- Treat factual statements (e.g., \"The capital of X is Y\") as boolean values using this expanded reference:\n  ✅ True: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran, Germany→Berlin, Nepal→Kathmandu, Malaysia→Kuala Lumpur\n  ❌ False: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri, Turkey→Istanbul, Azerbaijan→Ganja, Nepal→Pokhara\n- For any capital not listed, use common knowledge (e.g., Berlin is Germany's capital → True).\n\n### Step 2: Evaluation Strategy\n1. **Parse Structure First**: Identify and label all parentheses levels. Work from innermost outward.\n2. **Simplify Negations Recursively**:\n   - Apply negation rules immediately at each level:\n     - `not not X` ≡ X\n     - `not not not X` ≡ not X\n     - For n negations: n mod 2 = 0 → X, n mod 2 = 1 → not X\n3. **Enforce Strict Short-Circuiting**:\n   - For `and`: If left operand is false, return false without evaluating right\n   - For `or`: If left operand is true, return true without evaluating right\n4. **Compute Arithmetic Precisely**:\n   - Evaluate `max()` and `min()` by listing all values explicitly\n   - Calculate fractions exactly (e.g., 1/10 = 0.1, -9/8 = -1.125)\n   - Remember: Negative × negative = positive\n5. **Chunk Complex Expressions**: Break into subexpressions with clear labels. Evaluate each separately before combining.\n\n### Step 3: Verification\n- If multiple expressions appear true, recheck arithmetic and factual statements first\n- Remember: Exactly one is true. If you find multiple, you made an error\n\n### Examples of Common Mistakes to Avoid:\n1. ❌ Miscounting negations in deep nesting: `not not not not True` = `True`\n2. ❌ Forgetting short-circuiting: `False and (complex expression)` should never evaluate the complex part\n3. ❌ Arithmetic errors: `max(-10,-6,-4,2) - min(-10,-6,-4,2)` = 12, not 1\n4. ❌ Capital confusion: Istanbul is not Turkey's capital (Ankara is)\n5. ❌ Parentheses misgrouping: In `A and B or C`, `and` has precedence unless parentheses dictate otherwise\n\n### Demonstration with Common Errors:\n[Example 2 snippet where model incorrectly evaluated (B) instead of (C)]\n- Mistake: Failed to properly count negations in deep nesting and missed short-circuiting opportunity\n- Correction: Should have simplified `not not not (False)` to `True` but then recognized an `and False` clause later\n\n[Example 4 snippet where model incorrectly evaluated (B) instead of (E)]\n- Mistake: Miscomputed arithmetic in `(-8 - (9 / -1) > 10)` and missed that `and (False)` makes entire clause false\n- Correction: `9/-1 = -9`, `-8 - (-9) = 1`, `1 > 10 = False`, so `True and False and False = False`\n\nNow, evaluate the following expressions. Show your reasoning steps briefly, but output only the letter (A-E) of the true expression after your analysis.",
                "Q": 1.1833333333333333,
                "N": 2,
                "uct_value": 0.886504922350488,
                "reward": 0.4,
                "children": [
                  {
                    "id": 7,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing and Setup\n- Convert all natural language comparisons to standard operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n- Treat factual statements (e.g., \"The capital of X is Y\") as boolean values using this expanded reference:\n  ✅ True: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran, Germany→Berlin, Nepal→Kathmandu, Malaysia→Kuala Lumpur, Turkey→Ankara, Iraq→Baghdad, UAE→Abu Dhabi, Azerbaijan→Baku, Gambia→Banjul\n  ❌ False: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri, Turkey→Istanbul, Azerbaijan→Ganja, Nepal→Pokhara, Afghanistan→Kandahar\n- For any capital not listed, use common knowledge and explicitly state your assumption.\n\n### Step 2: Structural Analysis\n1. **Parse and Label Structure**:\n   - Identify and label all parentheses levels with tags (L1, L2, ...) from innermost to outermost\n   - Create a subexpression table with unique IDs (S1, S2, ...) for each nested component\n   - Note: `and` has higher precedence than `or` unless parentheses dictate otherwise\n\n2. **Iterative Negation Handling**:\n   - For each subexpression, count consecutive `not` operations (n)\n   - Apply: n mod 2 = 0 → remove all `not`s; n mod 2 = 1 → keep one `not`\n   - Process from innermost to outermost, updating the table at each step\n\n### Step 3: Evaluation Protocol\n1. **Strict Short-Circuiting Enforcement**:\n   - For `and`: Evaluate left operand first. If false, mark entire expression false without evaluating right\n   - For `or`: Evaluate left operand first. If true, mark entire expression true without evaluating right\n   - Explicitly note when short-circuiting is applied\n\n2. **Precise Arithmetic Computation**:\n   - Evaluate `max()` and `min()` by listing all values explicitly\n   - Calculate fractions exactly (e.g., -5/3 instead of -1.666...)\n   - Show all arithmetic steps: operations, signs, and intermediate results\n\n3. **Factual Statement Verification**:\n   - Cross-reference each capital statement with the provided list\n   - For unlisted capitals, state your assumption clearly\n\n### Step 4: Verification and Cross-Checking\n- After evaluating all expressions, create a summary table with results for A-E\n- If multiple expressions appear true:\n  - First recheck arithmetic computations\n  - Then verify factual statements\n  - Finally recount negations in problematic expressions\n- Remember: Exactly one must be true. If you find multiple, you made an error\n\n### Common Failure Examples to Avoid:\n[Example 2 Failure]\n- Error: Misparsed structure and missed final `and (False)` clause\n- Correction: Always track outermost operations and verify all `and`/`or` conditions\n\n[Example 4 Failure]\n- Error: Miscalculated fraction precision and misapplied negation rules\n- Correction: Use exact fractions and count negations iteratively\n\n### Demonstration with Corrected Examples:\n[Example 2 corrected step-by-step with subexpression table]\n[Example 4 corrected evaluation showing exact fraction computation]\n\n### Execution Instructions:\n1. Create a subexpression table with columns: ID, Expression, Value, Notes\n2. Process expressions in order from innermost to outermost\n3. For each evaluation step, note:\n   - Short-circuiting applications\n   - Negation reductions\n   - Arithmetic computations\n   - Factual verifications\n4. After all evaluations, output only the letter (A-E) of the true expression\n\nNow, evaluate the following expressions using this enhanced protocol.",
                    "Q": 0.6,
                    "N": 1,
                    "uct_value": 0.002081386527894244,
                    "reward": 0.3,
                    "children": []
                  },
                  {
                    "id": 8,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing\n- Convert all natural language comparisons to standard operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n- Treat factual statements (e.g., \"The capital of X is Y\") as boolean values using this expanded reference:\n  ✅ True: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran, Germany→Berlin, Nepal→Kathmandu, Malaysia→Kuala Lumpur\n  ❌ False: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri, Turkey→Istanbul, Azerbaijan→Ganja, Nepal→Pokhara\n- For any capital not listed, assume the statement is false unless it is universally known common knowledge (e.g., Paris→France). When in doubt, assume false.\n\n### Step 2: Evaluation Strategy\n1. **Parse Structure with Labeling**:\n   - Identify and label all parentheses levels (L0: outermost, L1: next level, etc.)\n   - Create subexpression labels (S1, S2, ...) for each distinct component\n   - Work strictly from innermost parentheses outward\n\n2. **Simplify Negations Immediately**:\n   - For any sequence of `not`s, count them (n)\n   - Apply: n mod 2 = 0 → remove all negations, n mod 2 = 1 → keep one negation\n   - Example: `not not not not X` → X, `not not not X` → not X\n\n3. **Enforce Strict Short-Circuiting**:\n   - For `A and B`: If A evaluates to false, return false without evaluating B\n   - For `A or B`: If A evaluates to true, return true without evaluating B\n   - Check short-circuiting opportunities at every level\n\n4. **Compute Arithmetic with Precision**:\n   - Evaluate `max()` and `min()` by listing all values explicitly before computing differences\n   - Calculate fractions exactly (e.g., 1/10 = 0.1, -9/8 = -1.125)\n   - Show all intermediate arithmetic steps\n\n5. **Chunk Complex Expressions**:\n   - Break into smallest logical subexpressions\n   - Evaluate each subexpression separately before combining\n   - Store results clearly for reference\n\n### Step 3: Verification\n- If multiple expressions appear true, immediately re-check:\n  - All negation counts\n  - Short-circuiting applications\n  - Arithmetic calculations\n  - Factual statement evaluations\n- Remember: Exactly one is true. If you find multiple, you made an error\n\n### Examples of Critical Errors to Avoid:\n[Example 1 from failure cases]\n- Error: Miscounted negations in `not not not (False)` → evaluated as True instead of False\n- Correction: 3 negations → odd → should be `not False` = True, but missed higher-level grouping\n\n[Example 2 from failure cases]\n- Error: Failed to short-circuit `False and (complex expression)`\n- Correction: Should have returned false immediately without evaluating the complex part\n\n[Example 5 from failure cases]\n- Error: Misparsed parentheses structure, leading to incorrect grouping\n- Correction: Should have labeled subexpressions and evaluated innermost first\n\n### Demonstration of Correct Approach:\n[Simplified example showing proper step-by-step evaluation with labeling]\nS1: (4 * -6 <= 8) → -24 <= 8 → True\nS2: not (Jordan is Amman) → not True → False\nS3: S1 and S2 → True and False → False\nS4: not not not S3 → 3 negations → not False → True\n... [continue with clear labeling]\n\nNow, evaluate the following expressions. Show your reasoning with clear subexpression labels and intermediate results, but output only the letter (A-E) of the true expression after your analysis.",
                    "Q": 0.45,
                    "N": 0,
                    "uct_value": 0.002081386527894244,
                    "reward": 0.45,
                    "children": [
                      {
                        "id": 9,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing\n- Convert all natural language comparisons to standard operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n- Treat factual statements (e.g., \"The capital of X is Y\") as boolean values using this expanded reference:\n  ✅ True: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran, Germany→Berlin, Nepal→Kathmandu, Malaysia→Kuala Lumpur\n  ❌ False: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri, Turkey→Istanbul, Azerbaijan→Ganja, Nepal→Pokhara\n- For any capital not listed, assume the statement is false unless it is universally known common knowledge. When in doubt, assume false.\n\n### Step 2: Structural Parsing with Depth Tracking\n- **Parentheses Depth Analysis**: Initialize depth = 0. Scan left to right:\n  - For each '(', increment depth by 1\n  - For each ')', decrement depth by 1\n  - Identify all expressions at maximum depth first\n  - Resolve all expressions at depth N before moving to depth N-1\n- **Subexpression Labeling**: Assign labels (S1, S2, S3...) sequentially as you evaluate\n- **Operator Precedence**: Within same depth, evaluate left-to-right unless parentheses override\n\n### Step 3: Evaluation Strategy\n1. **Innermost First Resolution**: Always evaluate the highest depth expressions first\n2. **Negation Simplification**:\n   - Count consecutive 'not' operators only after fully evaluating the inner expression\n   - Apply: n mod 2 = 0 → remove all negations, n mod 2 = 1 → keep one negation\n   - Example: `not not not (X)` → evaluate X first, then apply 3 negations → `not X`\n3. **Strict Short-Circuiting**:\n   - For `A and B`: If A evaluates to false, return false immediately without evaluating B\n   - For `A or B`: If A evaluates to true, return true immediately without evaluating B\n   - Only apply when grouping is certain from parentheses structure\n4. **Precise Arithmetic Computation**:\n   - Evaluate `max()` and `min()` by listing all values explicitly before computing differences\n   - Calculate fractions exactly (e.g., 1/10 = 0.1, -9/8 = -1.125)\n   - Show all intermediate arithmetic steps with exact values\n5. **Incremental Chunking**:\n   - Break expressions into smallest evaluable units at each depth level\n   - Store results in a lookup table for reference\n   - Never evaluate the same subexpression twice\n\n### Step 4: Verification & Error Checking\n- **Parentheses Balance Check**: Ensure opening and closing parentheses counts match\n- **Single Truth Enforcement**: If multiple expressions appear true, re-parse the parentheses structure from scratch\n- **Arithmetic Validation**: Recompute all calculations with exact fractions\n- **Factual Re-check**: Verify capital cities against the provided list\n\n### Critical Failure Examples to Avoid:\n[Example 5 - Parentheses Misparsing]\n- Error: In Expression (A), misidentified the scope of OR operators due to incorrect depth tracking\n- Correction: Should have resolved `((A or B) or C)` at depth 4 before evaluating depth 3 expressions\n- Solution: Use systematic depth counting and resolve highest depth first\n\n[Example 2 - Premature Short-Circuiting]\n- Error: Applied short-circuiting before fully resolving parentheses grouping\n- Correction: Should have evaluated both sides of `and` when parentheses made grouping ambiguous\n- Solution: Only short-circuit when parentheses structure is unambiguous\n\n[Example 4 - Negation Miscounting]\n- Error: Counted negations across different parentheses levels incorrectly\n- Correction: Should have evaluated inner expression first, then applied negations\n- Solution: Always complete inner evaluation before counting negations\n\n### Demonstration of Correct Approach:\n[Expression snippet showing proper depth tracking]\nDepth 4: S1 = (8 - (-9/2)) → 8 - (-4.5) = 12.5\nDepth 4: S2 = (12.5 > -8) → True\nDepth 3: S3 = (not not S2) → True (2 negations)\nDepth 3: S4 = (max(-7,-9,-2,-3) - min(-7,-9,-2,-3)) → (-2) - (-9) = 7\nDepth 3: S5 = (7 <= 4) → False\n... [continue with clear depth-based evaluation]\n\nNow, evaluate the following expressions. Show your reasoning with clear depth levels and subexpression labels, but output only the letter (A-E) of the true expression after your complete analysis.",
                        "Q": 0.4,
                        "N": 0,
                        "uct_value": 0.0,
                        "reward": 0.4,
                        "children": []
                      },
                      {
                        "id": 10,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing\n- Convert all natural language comparisons to standard operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n- Treat factual statements (e.g., \"The capital of X is Y\") as boolean values using this expanded reference:\n  ✅ True: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran, Germany→Berlin, Nepal→Kathmandu, Malaysia→Kuala Lumpur\n  ❌ False: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri, Turkey→Istanbul, Azerbaijan→Ganja, Nepal→Pokhara\n- For any capital not listed, assume the statement is false. Do not use external knowledge.\n\n### Step 2: Evaluation Strategy\n1. **Parse with Depth Tracking**:\n   - Identify all parentheses levels (L0: outermost, L1: next level, etc.)\n   - Create a depth map and work strictly from innermost parentheses outward\n   - Label each distinct subexpression at the same level as S1, S2, etc.\n\n2. **Simplify Negations Methodically**:\n   - For any sequence of `not`s, first evaluate the innermost expression completely\n   - Then apply negations one by one from the inside out\n   - Count total negations (n): n mod 2 = 0 → remove all, n mod 2 = 1 → keep one negation\n\n3. **Enforce Strict Short-Circuiting**:\n   - For `A and B`: If A evaluates to false, return false immediately without evaluating B\n   - For `A or B`: If A evaluates to true, return true immediately without evaluating B\n   - Check short-circuiting opportunities at every level before proceeding\n\n4. **Compute Arithmetic with Precision**:\n   - Evaluate `max()` and `min()` by listing all values explicitly before computing differences\n   - Calculate fractions exactly (e.g., 1/10 = 0.1, -9/8 = -1.125)\n   - Show all intermediate arithmetic steps with exact values\n\n5. **Chunk Complex Expressions**:\n   - Break into smallest logical subexpressions at each parentheses level\n   - Evaluate each subexpression separately before combining\n   - Store results clearly with level labels (e.g., L2_S3 = False)\n\n### Step 3: Verification\n- After evaluating all expressions, list the boolean results for A through E\n- If multiple expressions appear true, immediately re-evaluate all expressions from scratch\n- Focus verification on:\n  - Negation counts in deeply nested expressions\n  - Short-circuiting applications\n  - Arithmetic calculations (especially fractions and negative numbers)\n  - Factual statement evaluations\n- Remember: Exactly one is true. If you find multiple, you made an error\n\n### Critical Examples of Errors to Avoid:\n[Example 3 Failure]\n- Error: Miscounted negations in `not not not (False)` → evaluated as True instead of False\n- Correction: 3 negations → odd → should be `not False` = True, but missed higher-level grouping with `and False`\n\n[Example 4 Failure]\n- Error: Failed to short-circuit `False and (complex expression)` in expression (B)\n- Correction: Should have returned false immediately without evaluating the complex part\n\n[Example 5 Failure]\n- Error: Misparsed parentheses structure in expression (A), leading to incorrect grouping\n- Correction: Should have labeled subexpressions and evaluated innermost first with proper depth tracking\n\n### Demonstration of Correct Approach:\n[Simplified example showing proper step-by-step evaluation with depth labeling]\nL3_S1: (4 * -6 <= 8) → -24 <= 8 → True\nL2_S1: not (Jordan is Amman) → not True → False\nL1_S1: L3_S1 and L2_S1 → True and False → False\nL0_S1: not not not L1_S1 → 3 negations → not False → True\n... [continue with clear level labeling]\n\nNow, evaluate the following expressions. Show your reasoning with clear level labels and intermediate results, but output only the letter (A-E) of the true expression after your complete analysis and verification.",
                        "Q": 0.4,
                        "N": 0,
                        "uct_value": 0.0,
                        "reward": 0.4,
                        "children": []
                      },
                      {
                        "id": 11,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing\n- Convert all natural language comparisons to standard operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n- Treat factual statements (e.g., \"The capital of X is Y\") as boolean values using this expanded reference:\n  ✅ True: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran, Germany→Berlin, Nepal→Kathmandu, Malaysia→Kuala Lumpur, Turkey→Ankara, Colombia→Bogotá, Cameroon→Yaoundé, UAE→Abu Dhabi, India→New Delhi, Iraq→Baghdad, Azerbaijan→Baku\n  ❌ False: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri, Turkey→Istanbul, Azerbaijan→Ganja, Nepal→Pokhara, Iran→Isfahan\n- For any capital not listed, assume false unless it is universally known common knowledge. When in doubt, assume false.\n\n### Step 2: Evaluation Strategy\n1. **Explicit Structure Parsing**:\n   - Label all parentheses levels numerically (L0: outermost, L1: inside L0, etc.)\n   - Create subexpression labels (S1, S2, ...) for each distinct component\n   - Work strictly from highest level number (innermost) to L0\n   - Use indentation to visualize nesting relationships\n\n2. **Immediate Negation Simplification**:\n   - For any sequence of `not`s, count them (n)\n   - Apply: n mod 2 = 0 → remove all negations, n mod 2 = 1 → keep one negation\n   - Simplify negations before evaluating the inner expression\n   - Example: `not not not not (X)` → X, `not not not (X)` → not X\n\n3. **Strict Short-Circuiting Enforcement**:\n   - For `A and B`: If A evaluates to false, return false immediately without evaluating B\n   - For `A or B`: If A evaluates to true, return true immediately without evaluating B\n   - Apply this rule at every level of evaluation\n\n4. **Precise Arithmetic Computation**:\n   - Evaluate `max()` and `min()` by listing all values explicitly before computing differences\n   - Calculate fractions exactly (e.g., 1/10 = 0.1, -9/8 = -1.125)\n   - Show all intermediate arithmetic steps with exact values\n   - Maintain fractional form until decimal comparison is necessary\n\n5. **Systematic Chunking**:\n   - Break expressions into smallest logical subexpressions\n   - Evaluate each subexpression separately before combining\n   - Store results with clear labels for reference\n\n### Step 3: Verification Protocol\n- If multiple expressions appear true, re-check in this priority order:\n  1. Negation counts for all subexpressions\n  2. Short-circuiting applications\n  3. Arithmetic calculations (especially fractions and max/min)\n  4. Factual statement evaluations against reference\n- Remember: Exactly one is true. If you find multiple, you made an error\n\n### Critical Examples from Failure Cases:\n[Example 1 - Negation Miscount]\n- Error: Evaluated `not not not (False)` as True but missed higher-level grouping\n- Correction: Simplify to `not False` = True, but ensure proper grouping context\n\n[Example 2 - Short-Circuiting Failure]\n- Error: Evaluated both sides of `False and (complex expression)`\n- Correction: Should have returned false immediately without evaluating complex part\n\n[Example 5 - Parentheses Misparsing]\n- Error: Misparsed parentheses structure, leading to incorrect grouping\n- Correction: Label subexpressions and evaluate innermost first with proper level tracking\n\n### Demonstration of Correct Approach:\n[Simplified example showing proper step-by-step evaluation with labeling and indentation]\nL0: not (S1 and S2)\n  L1: S1: not not (5 <= 1) → not not False → False\n  L1: S2: max(2,5,-1) - min(2,5,-1) = 5 - (-1) = 6 <= 3 → False\nL0: not (False and False) → not (False) → True\n\nNow, evaluate the following expressions. Show your reasoning with clear subexpression labels, level indicators, and intermediate results, but output only the letter (A-E) of the true expression after your analysis.",
                        "Q": 0.5,
                        "N": 0,
                        "uct_value": 0.0,
                        "reward": 0.5,
                        "children": []
                      }
                    ]
                  },
                  {
                    "id": 9,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing\n- Convert all natural language comparisons to standard operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n- Treat factual statements (e.g., \"The capital of X is Y\") as boolean values using this expanded reference:\n  ✅ True: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran, Germany→Berlin, Nepal→Kathmandu, Malaysia→Kuala Lumpur, Cameroon→Yaounde, Iraq→Baghdad, UAE→Abu Dhabi, Gambia→Banjul\n  ❌ False: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri, Turkey→Istanbul, Azerbaijan→Ganja, Nepal→Pokhara, Denmark→Aarhus\n- For any capital not listed, use reliable common knowledge.\n\n### Step 2: Evaluation Strategy\n1. **Parse Structure First**: Identify and label all parentheses levels. Work from innermost outward.\n2. **Simplify Negations Systematically**:\n   - Count all consecutive `not` operations from the innermost outward\n   - Apply: even number of `not`s → identity, odd number → negation\n   - Use scratchpad: e.g., `not not not not X` = X (4 mod 2 = 0)\n3. **Enforce Strict Left-to-Right Short-Circuiting**:\n   - For `and`: If left operand is false, return false immediately without evaluating right\n   - For `or`: If left operand is true, return true immediately without evaluating right\n   - Never evaluate right operand if short-circuiting applies\n4. **Compute Arithmetic Precisely**:\n   - Evaluate `max()` and `min()` by listing all values explicitly\n   - Calculate fractions exactly (e.g., 1/10 = 0.1, -9/8 = -1.125)\n   - Remember: Negative × negative = positive\n5. **Chunk Complex Expressions**: Break into subexpressions with labels (S1, S2, ...). Evaluate each separately before combining.\n\n### Step 3: Verification\n- If multiple expressions appear true, recheck arithmetic and factual statements first\n- Pay special attention to short-circuiting opportunities and negation counts\n- Remember: Exactly one is true. If you find multiple, you made an error\n\n### Critical Examples of Common Failures to Avoid:\n[Example 1 - Failure Case]\nExpression (A) contained: `(not (not (-8 - (8 / -3) <= 1) and ...)`\n- Error: Failed to short-circuit after `not (True)` → `False` in left `and` operand\n- Correction: Should have returned `False` immediately without evaluating right operand\n\n[Example 4 - Failure Case]\nExpressions (B) and (D) both appeared true due to:\n- Miscounted negations in deep nesting\n- Overlooked short-circuiting in complex `and`/`or` chains\n- Solution: Always recheck when multiple expressions seem true\n\n### Demonstration of Correct Approach:\n[Example Snippet]\nEvaluate: `not (False and (complex expression))`\n- Step 1: Evaluate left operand: `False`\n- Step 2: Short-circuit: `False and X` = `False` (right never evaluated)\n- Step 3: Apply negation: `not False` = `True`\n\n[Example Snippet]\nEvaluate: `not not not not (max(1,2,3) - min(1,2,3) <= 2)`\n- Step 1: Compute: max=3, min=1, difference=2, 2<=2 → `True`\n- Step 2: Count negations: 4 `not`s → 4 mod 2 = 0 → identity → `True`\n\nNow, evaluate the following expressions. Show your reasoning steps briefly, but output only the letter (A-E) of the true expression after your analysis. If multiple seem true, recheck your work until only one remains.",
                    "Q": 0.4,
                    "N": 0,
                    "uct_value": 0.002081386527894244,
                    "reward": 0.4,
                    "children": []
                  }
                ]
              },
              {
                "id": 7,
                "depth": 3,
                "action_sequence": [
                  "FailureDrivenAction",
                  "FailureDrivenAction",
                  "FailureDrivenAction"
                ],
                "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing\n- Convert all natural language comparisons to standard operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n- Treat factual statements (e.g., \"The capital of X is Y\") as boolean values using this reference:\n  ✅ True: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran, Turkey→Ankara, Malaysia→Kuala Lumpur, Nepal→Kathmandu\n  ❌ False: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri\n  - For other capitals not listed, assume they are false unless they are commonly known (e.g., Japan→Tokyo is true).\n\n### Step 2: Evaluation Strategy\n1. **Decompose expressions**: Break each expression into smaller sub-expressions. Label them (e.g., Sub1, Sub2) and evaluate each separately before combining.\n2. **Simplify recursively**: Always start from the innermost parentheses and move outward.\n3. **Handle negations precisely**:\n   - Count the number of `not` operations: even number cancels out (e.g., `not not X` ≡ X), odd number reduces to one `not` (e.g., `not not not X` ≡ not X).\n4. **Use strict short-circuiting**:\n   - For `and`: If any operand is false, entire expression is false (stop evaluating further operands).\n   - For `or`: If any operand is true, entire expression is true (stop evaluating further operands).\n5. **Compute arithmetic carefully**:\n   - Evaluate `max()` and `min()` before comparisons.\n   - Pay special attention to negative numbers and fractions (e.g., `-8 * -8 = 64`, not `-64`).\n6. **Operator precedence**: `and` has higher precedence than `or`. So `A and B or C` is `(A and B) or C`, unless parentheses indicate otherwise.\n\n### Step 3: Verification\n- If multiple expressions appear true, recheck each one from scratch. Pay special attention to negation counts and short-circuiting points.\n- Remember: Only one expression evaluates to True.\n\n### Examples of Common Mistakes to Avoid:\n1. ❌ Don't miscount negations: `not not not True` = `False`, not `True`\n2. ❌ Don't forget short-circuiting: `False and X` = `False` regardless of X\n3. ❌ Don't miscompute arithmetic: `-8 * -8 = 64`, not `-64`\n4. ❌ Don't confuse capitals: Baghdad is Iraq's capital, not Beirut\n5. ❌ Don't ignore parentheses: they define evaluation order\n6. ❌ Don't assume all `and`/`or` have the same precedence; `and` comes first\n\n### Demonstration of Correct Evaluation:\nConsider a simple example: `not (True and (False or True))`\n1. Innermost: `False or True` → True\n2. Next: `True and True` → True\n3. Outer: `not True` → False\nFinal result: False\n\n### Few-Shot Examples of Common Errors:\n[Example from earlier case where model failed]\nExpression: `not not not (True) and (False or True)`\n- Wrong: Evaluating as `not not not (True and (False or True))` → Incorrect grouping\n- Right: `not not not True` = `not True` = `False`, then `False and (False or True)` = `False and True` = `False`\n\n[Another example with arithmetic]\nExpression: `-5 * -6 + -7 * 4 <= 9 * -2`\n- Wrong: `-5 * -6 = -30`, `-7 * 4 = -28`, sum = `-58`, `9 * -2 = -18`, `-58 <= -18` → True\n- Right: `-5 * -6 = 30`, `-7 * 4 = -28`, sum = `2`, `9 * -2 = -18`, `2 <= -18` → False\n\nNow, evaluate the following expressions. Output only the letter (A-E) of the true expression after your analysis.",
                "Q": 0.6499999999999999,
                "N": 1,
                "uct_value": 0.6531715890171546,
                "reward": 0.3,
                "children": [
                  {
                    "id": 8,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing\n- Convert all natural language comparisons to standard operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n- Treat factual statements (e.g., \"The capital of X is Y\") as boolean values using this reference:\n  ✅ True: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran, Turkey→Ankara, Malaysia→Kuala Lumpur, Nepal→Kathmandu, Japan→Tokyo, France→Paris, Germany→Berlin, Brazil→Brasilia\n  ❌ False: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri, Belarus→Grodno\n  - For other capitals not listed, assume they are false unless they are commonly known world capitals.\n\n### Step 2: Expression Parsing Strategy\n1. **Identify outermost structure**: Begin by identifying the main logical operators at the outermost level, respecting parentheses.\n2. **Break into sub-expressions**: Decompose each expression into smaller sub-expressions. Label them (e.g., Sub1, Sub2) and evaluate each separately before combining.\n3. **Parentheses priority**: Always evaluate expressions inside parentheses first, working from innermost to outermost.\n4. **Operator precedence**: `and` has higher precedence than `or`. So `A and B or C` is `(A and B) or C`, unless parentheses indicate otherwise.\n\n### Step 3: Evaluation Protocol\n1. **Handle negations precisely**:\n   - Count the number of `not` operations: even number cancels out (e.g., `not not X` ≡ X), odd number reduces to one `not` (e.g., `not not not X` ≡ not X).\n   - For nested negations, evaluate the innermost expression first, then apply negations outward step by step.\n2. **Use strict short-circuiting**:\n   - For `and`: If any operand is false, entire expression is false (stop evaluating further operands).\n   - For `or`: If any operand is true, entire expression is true (stop evaluating further operands).\n   - **Critical**: Only apply short-circuiting after completely evaluating the current operand. Do not assume short-circuiting until the operand value is definitively known.\n3. **Compute arithmetic carefully**:\n   - Evaluate `max()` and `min()` before comparisons.\n   - Pay special attention to negative numbers and fractions (e.g., `-8 * -8 = 64`, `10 / -2 = -5`).\n   - Remember arithmetic operator precedence: multiplication/division before addition/subtraction.\n\n### Step 4: Verification\n- If multiple expressions appear true, recheck each one from scratch with special attention to:\n  - Correct parsing of parentheses and operator grouping\n  - Accurate negation counts\n  - Arithmetic calculations\n  - Short-circuiting application\n- Remember: Only one expression evaluates to True.\n\n### Examples of Common Mistakes to Avoid:\n1. ❌ Don't miscount negations: `not not not True` = `False`, not `True`\n2. ❌ Don't forget short-circuiting: `False and X` = `False` regardless of X, but only after X is evaluated if needed\n3. ❌ Don't miscompute arithmetic: `-5 * -6 = 30`, not `-30`\n4. ❌ Don't confuse capitals: Baghdad is Iraq's capital, not Beirut\n5. ❌ Don't ignore parentheses: they define evaluation order\n6. ❌ Don't assume all `and`/`or` have the same precedence; `and` comes first\n\n### Few-Shot Examples of Critical Errors:\n[Example where model failed due to parsing error]\nExpression (A) from previous case: `not not (not (not not (expr1) or not not not (expr2)) or (expr3 and expr4)) or not not not (expr5)`\n- Wrong: Evaluating as `(not not (left)) or (right)` and short-circuiting when left seems true\n- Right: Parse as `not not [ (not (not not (expr1)) or not not not (expr2)) or (expr3 and expr4) ] or not not not (expr5)`\n- Then evaluate inner completely before applying outer operators\n\n[Example with arithmetic precedence]\nExpression: `-5 * -6 + -7 * 4 <= 9 * -2`\n- Wrong: `(-5 * -6) + (-7 * 4) = 30 + (-28) = 2`, then `9 * -2 = -18`, `2 <= -18` → False\n- Right: Same calculation → False (this is correct, but shows proper order)\n\n[Example with deep negation nesting]\nExpression: `not not not not not True`\n- Evaluate: `not not not not not True` = `not not not not False` = `not not not True` = `not not False` = `not True` = `False`\n\n### Demonstration of Correct Evaluation:\nConsider: `not (True and (False or True))`\n1. Innermost: `False or True` → True\n2. Next: `True and True` → True\n3. Outer: `not True` → False\nFinal result: False\n\nNow, evaluate the following expressions. Output only the letter (A-E) of the true expression after your complete analysis.",
                    "Q": 0.35,
                    "N": 0,
                    "uct_value": 0.0,
                    "reward": 0.35,
                    "children": [
                      {
                        "id": 9,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing\n- Convert all natural language comparisons to standard operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n- Treat factual statements (e.g., \"The capital of X is Y\") as boolean values using this reference:\n  ✅ True: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran, Turkey→Ankara, Malaysia→Kuala Lumpur, Nepal→Kathmandu, Japan→Tokyo, France→Paris, Germany→Berlin, Brazil→Brasilia, Azerbaijan→Baku\n  ❌ False: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri, Belarus→Grodno\n  - For other capitals not listed, assume they are false unless they are commonly known world capitals (e.g., Russia→Moscow: true).\n\n### Step 2: Expression Parsing Strategy\n1. **Structural Decomposition**:\n   - Identify the outermost structure first, respecting parentheses.\n   - Break the expression into smaller sub-expressions and assign labels (e.g., Sub1, Sub2).\n   - Create a clear hierarchy: evaluate innermost parentheses first, working outward.\n   - Use explicit parentheses in your reasoning to avoid ambiguity.\n\n2. **Negation Handling Protocol**:\n   - Count consecutive `not` operations precisely: even number cancels out (e.g., `not not X` ≡ X), odd number reduces to one `not` (e.g., `not not not X` ≡ not X).\n   - For deeply nested negations, evaluate the innermost expression first, then apply negations step by step.\n\n3. **Short-Circuiting Rules**:\n   - For `and`: Fully evaluate the left operand first. If false, stop (result is false). If true, evaluate right operand.\n   - For `or`: Fully evaluate the left operand first. If true, stop (result is true). If false, evaluate right operand.\n   - **Critical**: Only apply short-circuiting after completely evaluating the current operand.\n\n4. **Arithmetic Evaluation**:\n   - Compute `max()` and `min()` functions first.\n   - Follow operator precedence: multiplication/division before addition/subtraction.\n   - Show intermediate calculations for complex expressions (e.g., `-9/2 = -4.5`, then `8 - (-4.5) = 12.5`).\n\n5. **Operator Precedence**: \n   - `and` has higher precedence than `or`. Always interpret `A and B or C` as `(A and B) or C` unless parentheses indicate otherwise.\n\n### Step 3: Verification\n- If multiple expressions appear true, re-evaluate each from scratch with special attention to:\n  - Correct parsing of parentheses and operator grouping\n  - Accurate negation counts\n  - Arithmetic calculations\n  - Short-circuiting application\n- Remember: Only one expression evaluates to True.\n\n### Few-Shot Examples of Critical Errors to Avoid:\n[Example 1: Negation Miscount]\nExpression: `not not not not not True`\n- Wrong: Assuming odd number of negations → `not True` = False\n- Right: Count precisely: 5 negations (odd) → equivalent to one `not`: `not True` = False\n\n[Example 2: Arithmetic Error]\nExpression: `-5 * -6 + -7 * 4 <= 9 * -2`\n- Wrong: `(-5 * -6) + (-7 * 4) = 30 + (-28) = 2`, then `9 * -2 = -18`, `2 <= -18` → False (correct but shows proper order)\n- Common Mistake: `-5 * -6 = -30` (incorrect sign handling)\n\n[Example 3: Capital Fact Error]\nExpression: `The capital of Turkey is Istanbul.`\n- Wrong: Assuming true (common mistake)\n- Right: Ankara is the capital → False\n\n[Example 4: Parentheses Misparsing]\nExpression: `not (True and (False or True))`\n- Wrong: Evaluating as `not True and (False or True)` → `False and True` = False\n- Right: Innermost: `False or True` = True, then `True and True` = True, then `not True` = False\n\n[Example 5: Short-Circuiting Misapplication]\nExpression: `False and (complex expression)`\n- Wrong: Skipping evaluation of `complex expression` prematurely\n- Right: Fully evaluate `complex expression` first, then apply short-circuiting\n\n### Step 4: Output Format\n- For each expression, output a detailed step-by-step evaluation showing all sub-expression results.\n- Finally, output only the letter (A-E) of the true expression.\n\nNow, evaluate the following expressions. Output your detailed analysis first, then the final answer.",
                        "Q": 0.3,
                        "N": 0,
                        "uct_value": 0.0,
                        "reward": 0.3,
                        "children": []
                      },
                      {
                        "id": 10,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing\n- Convert all natural language comparisons to standard operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n- Treat factual statements (e.g., \"The capital of X is Y\") as boolean values using this reference:\n  ✅ True: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran, Turkey→Ankara, Malaysia→Kuala Lumpur, Nepal→Kathmandu, Japan→Tokyo, France→Paris, Germany→Berlin, Brazil→Brasilia, Azerbaijan→Baku\n  ❌ False: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri, Belarus→Grodno, Nigeria→Lagos\n  - For other capitals not listed, assume they are false unless they are commonly known world capitals.\n\n### Step 2: Expression Parsing Strategy\n1. **Start from innermost**: Always begin with the innermost parentheses and work outward systematically.\n2. **Label sub-expressions**: Decompose complex expressions into labeled sub-expressions (Sub1, Sub2, etc.) and evaluate each completely before combining.\n3. **Parentheses priority**: Respect all parentheses groupings strictly. Evaluate nested expressions from inside to outside.\n4. **Operator precedence**: `and` has higher precedence than `or`. So `A and B or C` is `(A and B) or C`, unless parentheses indicate otherwise.\n\n### Step 3: Evaluation Protocol\n1. **Handle negations step-by-step**:\n   - Apply each `not` operator individually from the inside out\n   - Never use even/odd shortcuts - show each negation step explicitly\n   - Example: `not not not True` → Evaluate: `not True = False`, `not False = True`, `not True = False`\n2. **Use strict short-circuiting**:\n   - For `and`: Fully evaluate the left operand first. If false, stop and return false.\n   - For `or`: Fully evaluate the left operand first. If true, stop and return true.\n   - **Critical**: Only apply short-circuiting after the current operand is completely evaluated, including all nested expressions.\n3. **Compute arithmetic carefully**:\n   - Show all arithmetic steps explicitly\n   - Evaluate `max()` and `min()` before comparisons\n   - Follow operator precedence: multiplication/division before addition/subtraction\n   - Pay special attention to negative numbers and fractions\n\n### Step 4: Verification\n- If multiple expressions appear true, re-evaluate each one from scratch\n- List all sub-expression values before combining them\n- Double-check: negation counts, arithmetic calculations, and capital truth values\n\n### Critical Examples of Past Mistakes to Avoid:\n[Example 1 - Deep Negation Error]\nExpression: `not not not not not True`\n- Wrong: Assuming odd number of nots = not True → False\n- Right: Step-by-step: `not True = False`, `not False = True`, `not True = False`, `not False = True`, `not True = False`\n\n[Example 2 - Arithmetic Precedence Error]\nExpression: `-5 * -6 + -7 * 4 <= 9 * -2`\n- Wrong: `(-5 * -6) + (-7 * 4) = 30 + (-28) = 2`, `9 * -2 = -18`, `2 <= -18` → False (incorrect for this case)\n- Right: Same calculation → False (but shows proper order)\n\n[Example 3 - Capital Handling Error]\nExpression: `The capital of Azerbaijan is Baku`\n- Wrong: Assuming false because not in original list\n- Right: True (Baku is correct capital)\n\n[Example 4 - Short-circuiting Misapplication]\nExpression: `False and (complex nested expression)`\n- Wrong: Not evaluating the nested expression at all\n- Right: Fully evaluate the nested expression first, then apply short-circuiting\n\n### Demonstration of Correct Evaluation:\nConsider: `not (True and (False or True))`\n1. Innermost: `False or True` → True\n2. Next: `True and True` → True  \n3. Outer: `not True` → False\nFinal result: False\n\nNow, evaluate the following expressions. For each expression:\n1. Identify and label all sub-expressions\n2. Evaluate from innermost outward\n3. Show all arithmetic steps\n4. Apply negations one step at a time\n5. Output only the letter (A-E) of the true expression after complete analysis.",
                        "Q": 0.35,
                        "N": 0,
                        "uct_value": 0.0,
                        "reward": 0.35,
                        "children": []
                      },
                      {
                        "id": 11,
                        "depth": 5,
                        "action_sequence": [
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction",
                          "FailureDrivenAction"
                        ],
                        "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing and Tokenization\n- Convert all natural language comparisons to standard operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n- Add spaces around parentheses and operators for clarity. Example: rewrite `(not(True))` as `( not ( True ) )`.\n- Treat factual statements (e.g., \"The capital of X is Y\") as boolean values using this extended reference:\n  ✅ True: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran, Turkey→Ankara, Malaysia→Kuala Lumpur, Nepal→Kathmandu, Japan→Tokyo, France→Paris, Germany→Berlin, Brazil→Brasilia, Azerbaijan→Baku, UAE→Abu Dhabi, Iraq→Baghdad\n  ❌ False: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri, Belarus→Grodno, Turkey→Istanbul, Iran→Isfahan\n  - For any capital not listed, assume it is false.\n\n### Step 2: Expression Parsing Strategy\n1. **Depth-based parsing**: Use a depth counter for parentheses. For each `(`, increase depth by 1; for each `)`, decrease by 1. Always evaluate expressions at the highest depth first.\n2. **Sub-expression labeling**: Break each expression into smaller sub-expressions (e.g., Sub1, Sub2). Evaluate each completely before combining.\n3. **Operator precedence**: `and` has higher precedence than `or`. So `A and B or C` is `(A and B) or C`, unless parentheses indicate otherwise.\n\n### Step 3: Evaluation Protocol\n1. **Negation handling**:\n   - Evaluate the innermost expression first, then apply one `not` at a time outward.\n   - Never simplify multiple `not`s in one step. Example: `not not not True` → first: `not True` = False, then `not False` = True, then `not True` = False.\n2. **Strict short-circuiting**:\n   - For `and`: If any operand is false, the entire expression is false, but only after fully evaluating that operand.\n   - For `or`: If any operand is true, the entire expression is true, but only after fully evaluating that operand.\n3. **Arithmetic computation**:\n   - Evaluate `max()` and `min()` functions first.\n   - Then multiplication/division, then addition/subtraction.\n   - Pay special attention to negative numbers and fractions (e.g., `-8 * -8 = 64`, `10 / -2 = -5`).\n\n### Step 4: Verification\n- If multiple expressions appear true, re-evaluate each from scratch:\n  - First resolve all arithmetic and capital facts.\n  - Then apply negations step-by-step.\n  - Finally evaluate logical operators with correct precedence.\n- Remember: Only one expression evaluates to True.\n\n### Few-Shot Examples of Critical Errors to Avoid:\n[Example 1: Negation miscount in deep nesting]\nExpression: `not not not not not True`\n- Wrong: Evaluating as `not (not not not not True)` and miscounting\n- Right: Step-by-step: `not True` = False, `not False` = True, `not True` = False, `not False` = True, `not True` = False\n\n[Example 2: Premature short-circuiting]\nExpression: `False and (not (True) or (complex expression))`\n- Wrong: Assuming `False and X` = False without evaluating X\n- Right: Fully evaluate `(not (True) or (complex expression))` first, then apply `and`\n\n[Example 3: Arithmetic precedence error]\nExpression: `max(-1, 4, -4) - min(-1, 4, -4) * 2 > 5`\n- Wrong: Computing `max-min` first, then multiplying by 2\n- Right: Compute `min(...) * 2` first, then `max(...) - result`, then compare\n\n[Example 4: Capital fact ambiguity]\nExpression: `(The capital of UAE is Dubai) and (True)`\n- Wrong: Assuming Dubai is capital of UAE\n- Right: Abu Dhabi is capital → False → `False and True` = False\n\n[Example 5: Parentheses misparsing]\nExpression: `not (True and (False or True)) or (False)`\n- Wrong: Evaluating as `(not True) and (False or True) or False`\n- Right: `not (True and True) or False` = `not True or False` = `False or False` = False\n\n### Demonstration of Correct Evaluation:\nConsider: `not (not not (True) and (False or not False))`\n1. Tokenize: `not ( not not ( True ) and ( False or not False ) )`\n2. Depth 3: `True` → True\n3. Depth 2: `not not True` → `not False` → True\n4. Depth 2: `not False` → True, `False or True` → True\n5. Depth 1: `True and True` → True\n6. Depth 0: `not True` → False\nFinal result: False\n\nNow, evaluate the following expressions. Output only the letter (A-E) of the true expression after your complete analysis.",
                        "Q": 0.35,
                        "N": 0,
                        "uct_value": 0.0,
                        "reward": 0.35,
                        "children": []
                      }
                    ]
                  },
                  {
                    "id": 9,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing\n- Convert all natural language comparisons to standard operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n- Treat factual statements (e.g., \"The capital of X is Y\") as boolean values using this reference:\n  ✅ True: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran, Turkey→Ankara, Malaysia→Kuala Lumpur, Nepal→Kathmandu\n  ❌ False: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri\n  - For any other capital not listed, assume it is false. Do not use external knowledge.\n\n### Step 2: Evaluation Strategy\n1. **Decompose expressions**: Break each expression into smaller sub-expressions. Label them (e.g., Sub1, Sub2) and evaluate each separately before combining. Always start from the innermost parentheses and move outward.\n2. **Simplify recursively**: Evaluate the innermost parentheses first. Use a parentheses counter if needed.\n3. **Handle negations precisely**:\n   - Count the number of `not` operations from innermost to outermost. For example:\n     - `not not X` ≡ X\n     - `not not not X` ≡ not X\n   - Always simplify step by step: e.g., `not not not True` → evaluate innermost `not True` = False, then `not not False` = not True = False.\n4. **Use strict short-circuiting**:\n   - For `and`: If any operand is false, the entire expression is false (immediately stop evaluating further operands).\n   - For `or`: If any operand is true, the entire expression is true (immediately stop evaluating further operands).\n   - This applies at every level of nesting.\n5. **Compute arithmetic carefully**:\n   - Follow PEMDAS order: Parentheses, Exponents, Multiplication/Division (left to right), Addition/Subtraction (left to right).\n   - Pay special attention to negative numbers and fractions (e.g., `-8 * -8 = 64`).\n   - Evaluate `max()` and `min()` before comparisons.\n6. **Operator precedence**: `and` has higher precedence than `or`. So `A and B or C` is `(A and B) or C`, unless parentheses indicate otherwise.\n\n### Step 3: Verification\n- If multiple expressions appear true, recheck each one from scratch. Pay special attention to negation counts and short-circuiting points.\n- Remember: Only one expression evaluates to True.\n\n### Examples of Common Mistakes to Avoid:\n1. ❌ Don't miscount negations: Evaluate innermost first.\n2. ❌ Don't forget short-circuiting: Do not evaluate after a short-circuit.\n3. ❌ Don't miscompute arithmetic: Use PEMDAS.\n4. ❌ Don't confuse capitals: Use only the provided list.\n5. ❌ Don't ignore parentheses: They define evaluation order.\n6. ❌ Don't assume all `and`/`or` have the same precedence; `and` comes first.\n\n### Few-Shot Examples of Critical Errors:\n[Example from failure case]\nExpression: `not not (not (not not (7 * -3 + 4 * 3 > -7 * 4) or not not not (The capital of India is New Delhi)) or (not (True) and (4 * 9 + -8 * 7 <= 1 * -5)))`\n- Wrong: Miscounting negations or misgrouping parentheses\n- Right: Evaluate innermost: `7*-3+4*3 = -21+12 = -9`, `-7*4 = -28`, `-9 > -28` → True. Then `not not True` → True. Then `not not not (India is New Delhi)` → not not not True → not True → False. Then `True or False` → True. Then `not (True)` → False. Then `False and ...` short-circuits to False. Then `False or False` → False.\n\n[Another example with short-circuiting]\nExpression: `False and (5 * 10 > 0) or True`\n- Wrong: Evaluating `5*10>0` → True, then `False and True` → False, then `False or True` → True\n- Right: Short-circuit: `False and ...` → False immediately, then `False or True` → True\n\nNow, evaluate the following expressions. Output only the letter (A-E) of the true expression after your analysis.",
                    "Q": 0.3,
                    "N": 0,
                    "uct_value": 0.0,
                    "reward": 0.3,
                    "children": []
                  },
                  {
                    "id": 10,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing\n- Convert all natural language comparisons to standard operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n- Treat factual statements (e.g., \"The capital of X is Y\") as boolean values using this comprehensive reference:\n  ✅ True: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran, Turkey→Ankara, Malaysia→Kuala Lumpur, Nepal→Kathmandu, Germany→Berlin, India→New Delhi, Japan→Tokyo, France→Paris, China→Beijing, Russia→Moscow, UK→London\n  ❌ False: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri, Turkey→Istanbul, Malaysia→Putrajaya, UAE→AbuDhabi (Note: Abu Dhabi is capital, but statement \"UAE→Dubai\" is false)\n  - For any capital not explicitly listed above, assume the statement is false.\n\n### Step 2: Evaluation Strategy\n1. **Decompose and label**: Break each expression into smaller sub-expressions. Label them systematically (e.g., A1, A2, B1, B2) and evaluate each separately before combining.\n2. **Simplify recursively**: Always start from the innermost parentheses and move outward. Never skip layers.\n3. **Handle negations precisely**:\n   - Count `not` operations modulo 2: even number cancels out (e.g., `not not X` ≡ X), odd number reduces to one `not` (e.g., `not not not X` ≡ not X).\n   - Apply this rule step-by-step from the innermost expression outward.\n4. **Use strict short-circuiting**:\n   - For `and`: If any operand is false, entire expression is false (immediately stop evaluating further operands).\n   - For `or`: If any operand is true, entire expression is true (immediately stop evaluating further operands).\n5. **Compute arithmetic carefully**:\n   - Evaluate `max()` and `min()` functions first before comparisons.\n   - Compute each arithmetic operation separately and write down the numerical result.\n   - Pay special attention to signs: negative × negative = positive, negative × positive = negative.\n6. **Operator precedence**: `and` has higher precedence than `or`. So `A and B or C` is `(A and B) or C`, unless parentheses indicate otherwise.\n\n### Step 3: Verification\n- If multiple expressions appear true, re-evaluate each one from scratch using fresh labels.\n- If all expressions appear false, carefully recheck arithmetic, negation counts, and capital city references.\n- Remember: Exactly one expression evaluates to True.\n\n### Common Mistakes to Avoid with Examples:\n1. ❌ **Negation miscounting**: \n   - `not not not not True` = `True` (4 negations = even)\n   - `not not not True` = `False` (3 negations = odd)\n\n2. ❌ **Short-circuiting oversight**:\n   - `False and (5/0 == 1)` = `False` (never evaluate division)\n   - `True or (5/0 == 1)` = `True` (never evaluate division)\n\n3. ❌ **Arithmetic errors**:\n   - `-5 * -6 = 30` (not -30)\n   - `max(-10, 5, -3) = 5`, `min(-10, 5, -3) = -10`, difference = 15\n\n4. ❌ **Capital confusion**:\n   - \"The capital of UAE is Dubai\" → False (Abu Dhabi is capital)\n   - \"The capital of Turkey is Istanbul\" → False (Ankara is capital)\n\n5. ❌ **Precedence misunderstanding**:\n   - `True or False and False` = `True or (False and False)` = `True or False` = `True`\n   - Not `(True or False) and False` = `True and False` = `False`\n\n### Demonstration of Complex Evaluation:\n**Expression**: `not (not not (True and (False or not True)) or (max(2,-5) > min(1,3))`\n1. Innermost: `False or not True` → `False or False` → `False` (short-circuit: no)\n2. Next: `True and False` → `False` (short-circuit: yes)\n3. Negations: `not not False` → `not True` → `False`\n4. Outer: `not False` → `True`\n5. Right side: `max(2,-5)=2`, `min(1,3)=1`, `2>1` → `True`\n6. Final: `True or True` → `True`\n\n### Few-Shot Examples of Previous Failures:\n**Example 1** (From earlier failure):\nExpression: `not not not (not not (-9 * 1 <= -2) or not not not (The capital of Turkey is Istanbul.))`\n- Wrong: Miscounted negations, misgrouped operations\n- Right: \n  - `-9 <= -2` → True\n  - `Turkey is Istanbul` → False\n  - `not not not False` → True (3 negs)\n  - `not not True` → True (2 negs)\n  - `not not not True` → False (3 negs)\n  - Final: `False` (correct)\n\n**Example 2** (Arithmetic error):\nExpression: `-5 * -6 + -7 * 4 <= 9 * -2`\n- Wrong: `-30 + -28 = -58 <= -18` → True\n- Right: `30 + (-28) = 2 <= -18` → False\n\nNow, evaluate the following expressions. Output only the letter (A-E) of the true expression after your complete analysis.",
                    "Q": 0.35,
                    "N": 0,
                    "uct_value": 0.0,
                    "reward": 0.35,
                    "children": []
                  }
                ]
              }
            ]
          },
          {
            "id": 5,
            "depth": 2,
            "action_sequence": [
              "FailureDrivenAction",
              "FailureDrivenAction"
            ],
            "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps carefully:\n\n### Step 1: Preprocessing\n- Convert all natural language comparisons to standard operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n- Treat factual statements (e.g., \"The capital of X is Y\") as boolean values using this reference:\n  ✅ True: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran\n  ❌ False: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri\n- For other capitals not listed, use common knowledge (e.g., Turkey→Ankara, Malaysia→Kuala Lumpur).\n\n### Step 2: Evaluation Strategy\n1. **Simplify recursively** from innermost parentheses outward\n2. **Handle negations precisely**:\n   - `not not X` ≡ X\n   - `not not not X` ≡ not X\n   - For multiple negations: even number of `not`s cancel out; odd number reduce to single `not`\n3. **Use strict short-circuiting**:\n   - For `and`: If any operand is false, entire expression is false (stop evaluating further)\n   - For `or`: If any operand is true, entire expression is true (stop evaluating further)\n4. **Compute arithmetic carefully**:\n   - Evaluate `max()` and `min()` before comparisons\n   - Pay special attention to negative numbers and fractions (use exact values)\n   - Remember: `-a * -b = a*b`, `-a / -b = a/b`\n5. **Reduce nesting complexity** by assigning sub-expressions to temporary variables\n6. **Verify parentheses grouping** - when in doubt, evaluate innermost parentheses first\n\n### Step 3: Verification\n- If multiple expressions appear true, recheck your work with extra care\n- Remember: Only one expression evaluates to True\n\n### Common Mistakes to Avoid (with Examples):\n1. ❌ Don't miscount negations: `not not not True` = `False` (not `True`)\n2. ❌ Don't forget short-circuiting: `False and X` = `False` regardless of X\n3. ❌ Don't miscompute arithmetic: `-8 * -8 = 64`, not `-64`\n4. ❌ Don't confuse capitals: Baghdad is Iraq's capital, not Beirut\n5. ❌ Don't ignore fractional values: `1/3 = 0.333...`, not `0`\n6. ❌ Don't misgroup expressions: Always verify parentheses hierarchy\n\n### Demonstration Examples:\n[Example 1 from previous failure cases showing correct step-by-step evaluation]\n[Example 2 from previous failure cases showing correct step-by-step evaluation]\n\n### Output Format:\nShow your complete step-by-step reasoning for each expression, simplifying each sub-expression clearly. After evaluating all expressions, verify that only one is true. Finally, output only the letter (A-E) of the true expression.\n\nNow, evaluate the following expressions. Output your reasoning step by step, then the final answer.",
            "Q": 0.4,
            "N": 0,
            "uct_value": 0.003346415497614626,
            "reward": 0.4,
            "children": [
              {
                "id": 6,
                "depth": 3,
                "action_sequence": [
                  "FailureDrivenAction",
                  "FailureDrivenAction",
                  "FailureDrivenAction"
                ],
                "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing\n- Convert all natural language comparisons to standard operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n- Treat factual statements (e.g., \"The capital of X is Y\") as boolean values using this expanded reference:\n  ✅ True: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran, Nepal→Kathmandu, Azerbaijan→Baku, Germany→Berlin, Colombia→Bogota, Iraq→Baghdad, Malaysia→Kuala Lumpur, Cameroon→Yaounde\n  ❌ False: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri, Germany→Munich\n- For other capitals not listed, use common knowledge (e.g., Turkey→Ankara).\n\n### Step 2: Structured Evaluation Protocol\n1. **Depth-First Simplification**:\n   - For expressions with >3 nesting levels, assign sub-expressions to temporary variables (T1, T2, ...)\n   - Always evaluate innermost parentheses first, working outward\n   - Explicitly label parentheses levels (Level 1: innermost, Level 2: next, etc.)\n\n2. **Negation Reduction Protocol**:\n   - Reduce negations step-by-step with explicit counting:\n     - `not not X` ≡ X\n     - `not not not X` ≡ not X\n     - For multiple negations: count mod 2 (even: cancel, odd: single not)\n   - Show each reduction step: e.g., `not not not True` → `not not False` → `not True` → `False`\n\n3. **Strict Short-Circuiting Enforcement**:\n   - For `and`: If left operand is false, immediately evaluate to false and mark \"SHORT-CIRCUIT: false and X = false\"\n   - For `or`: If left operand is true, immediately evaluate to true and mark \"SHORT-CIRCUIT: true or X = true\"\n   - Do not evaluate unnecessary sub-expressions\n\n4. **Arithmetic Validation**:\n   - Compute `max()` and `min()` first, then arithmetic operations\n   - Double-check negative operations: `-a * -b = a*b`, `-a / -b = a/b`\n   - Preserve exact fractions (e.g., `1/3 = 0.333...`)\n   - Recompute complex arithmetic twice\n\n5. **Parentheses Hierarchy Verification**:\n   - Number all parentheses levels explicitly\n   - Verify operator precedence: parentheses > negation > comparisons > and/or\n\n### Step 3: Verification & Sanity Check\n- After evaluating all expressions, create a truth table summary:\n  | Expression | Result |\n  |------------|--------|\n  | A          | [T/F]  |\n  | B          | [T/F]  |\n  | C          | [T/F]  |\n  | D          | [T/F]  |\n  | E          | [T/F]  |\n- If multiple expressions appear true:\n  - Re-evaluate each true expression from scratch\n  - Check for: negation miscounts, arithmetic errors, short-circuiting misses\n- If all appear false, re-check your work\n- Final output only when exactly one is true\n\n### Common Failure Cases to Avoid (with Examples):\n1. ❌ Negation miscount: \n   - Incorrect: `not not not True` = `True` \n   - Correct: `not not not True` → `not not False` → `not True` → `False`\n\n2. ❌ Short-circuiting oversight:\n   - Incorrect: Evaluating `False and (complex expression)` fully\n   - Correct: \"SHORT-CIRCUIT: false and X = false\" → skip evaluation\n\n3. ❌ Arithmetic error:\n   - Incorrect: `-8 * -8 = -64`\n   - Correct: `-8 * -8 = 64`\n\n4. ❌ Capital confusion:\n   - Incorrect: \"The capital of Germany is Munich\" = True\n   - Correct: \"The capital of Germany is Berlin\" → False\n\n5. ❌ Parentheses misgrouping:\n   - Incorrect: `not (A and B or C)` parsed as `(not A) and (B or C)`\n   - Correct: Evaluate innermost parentheses first\n\n### Demonstration Examples from Previous Failures:\n[Example 1 from provided failure cases with corrected step-by-step evaluation]\n[Example 2 from provided failure cases with corrected step-by-step evaluation]\n\n### Output Format:\n1. For each expression (A-E):\n   - Show complete step-by-step reasoning\n   - Use temporary variables for nested sub-expressions\n   - Explicitly show negation reductions\n   - Note short-circuiting when applicable\n2. Present truth table summary\n3. Verify exactly one true expression\n4. Output only the letter (A-E) of the true expression\n\nNow, evaluate the following expressions. Output your reasoning step by step, then the final answer.",
                "Q": 0.35,
                "N": 0,
                "uct_value": 0.0,
                "reward": 0.35,
                "children": []
              },
              {
                "id": 7,
                "depth": 3,
                "action_sequence": [
                  "FailureDrivenAction",
                  "FailureDrivenAction",
                  "FailureDrivenAction"
                ],
                "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing\n- Convert all natural language comparisons to standard operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n- Treat factual statements (e.g., \"The capital of X is Y\") as boolean values using this comprehensive reference:\n  ✅ True Capitals: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran, Germany→Berlin, Nepal→Kathmandu, Azerbaijan→Baku, UAE→Abu Dhabi, Turkey→Ankara, Malaysia→Kuala Lumpur, Colombia→Bogota, India→New Delhi, Cameroon→Yaoundé\n  ❌ False Capitals: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri, Germany→Munich, Nepal→Pokhara, Azerbaijan→Ganja, Turkey→Istanbul\n\n### Step 2: Explicit Grouping\n- Add explicit parentheses to ensure correct evaluation order:\n  - `and` has higher precedence than `or`\n  - Example: `A and B or C` becomes `(A and B) or C`\n  - When in doubt, group from left to right\n\n### Step 3: Evaluation Strategy\n1. **Simplify recursively** from innermost parentheses outward\n2. **Use temporary variables** for complex sub-expressions (e.g., T1 = innermost expression)\n3. **Handle negations systematically**:\n   - Reduce pairs of `not` immediately: `not not X` ≡ X\n   - For multiple negations: count mod 2 (even: eliminate; odd: single `not`)\n4. **Apply strict short-circuiting**:\n   - For `and`: If left operand is false, return false immediately\n   - For `or`: If left operand is true, return true immediately\n5. **Compute arithmetic precisely**:\n   - Evaluate `max()` and `min()` first\n   - Use exact fractions (e.g., `-2/-6 = 1/3`)\n   - Remember: `-a * -b = a*b`, `-a / -b = a/b`\n6. **Verify capital facts** against the reference list\n\n### Step 4: Validation\n- After evaluating all expressions, if multiple appear true or none appear true:\n  - Recheck negation counts\n  - Verify parentheses grouping\n  - Confirm arithmetic calculations\n  - Validate capital facts\n- Remember: Exactly one expression must be True\n\n### Common Mistakes to Avoid (with Examples from Previous Failures):\n1. ❌ Miscounting negations: `not not not True` = `False` (not `True`)\n   - Example: In Expression A, `not not not True` was incorrectly evaluated as `True`\n2. ❌ Forgetting short-circuiting: `False and X` should not evaluate X\n   - Example: In Expression B, unnecessary evaluation led to errors\n3. ❌ Misgrouping expressions: Ambiguous parentheses caused incorrect evaluation\n   - Example: In Expression D, missing parentheses changed the logic\n4. ❌ Using approximate arithmetic: `1/3` should not be approximated to `0.333`\n   - Example: In Expression A, exact fractions were needed for correct comparison\n5. ❌ Confusing capitals: \"The capital of Nepal is Kathmandu\" not Pokhara\n   - Example: In Expression E, capital knowledge was crucial\n\n### Demonstration Examples from Previous Failures:\n[Example 2]: Show correct evaluation of Expression D with emphasis on negation handling and parentheses\n[Example 4]: Demonstrate proper short-circuiting in Expression B and capital validation\n[Example 5]: Illustrate exact fraction usage and temporary variable assignment\n\n### Output Format:\n1. For each expression (A-E):\n   - Assign temporary variables to complex sub-expressions\n   - Show step-by-step simplification with negation reduction\n   - Apply short-circuiting where possible\n   - Compute arithmetic exactly\n2. After all evaluations, verify only one is true\n3. Output only the letter (A-E) of the true expression\n\nNow, evaluate the following expressions. Show your reasoning using temporary variables, then output the final answer.",
                "Q": 0.45,
                "N": 0,
                "uct_value": 0.0,
                "reward": 0.45,
                "children": [
                  {
                    "id": 8,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing\n- Convert all natural language comparisons to standard operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n- Replace all capital statements with `True` or `False` using this comprehensive reference:\n  ✅ True Capitals: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran, Germany→Berlin, Nepal→Kathmandu, Azerbaijan→Baku, UAE→Abu Dhabi, Turkey→Ankara, Malaysia→Kuala Lumpur, Colombia→Bogota, India→New Delhi, Cameroon→Yaoundé\n  ❌ False Capitals: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri, Germany→Munich, Nepal→Pokhara, Azerbaijan→Ganja, Turkey→Istanbul\n\n### Step 2: Explicit Grouping and Structure Analysis\n- Rewrite each expression with explicit parentheses to enforce precedence:\n  - `not` has highest precedence, then `and`, then `or`\n  - Example: `not A and B or C` becomes `((not A) and B) or C`\n- For expressions with >3 nesting levels, create a structural diagram showing parentheses hierarchy\n- Identify all sub-expressions that can be short-circuited\n\n### Step 3: Iterative Evaluation Strategy\n1. **Evaluate from innermost outward**: Start with the most deeply nested sub-expressions first\n2. **Use systematic temporary variables**: Name them hierarchically (e.g., A1, A2 for Expression A; B1, B2 for B)\n3. **Handle negations methodically**:\n   - Scan left to right, collapsing `not not` pairs immediately\n   - For multiple negations: count consecutive `not` operators mod 2 (even: eliminate all; odd: keep one)\n4. **Apply strict short-circuiting**:\n   - For `and`: If left operand is false, return false immediately without evaluating right\n   - For `or`: If left operand is true, return true immediately without evaluating right\n5. **Compute arithmetic exactly**:\n   - Use exact fractions (e.g., `-1/10` not `-0.1`)\n   - Evaluate `max()` and `min()` first, then differences\n   - Remember: `-a * -b = a*b`, `-a / -b = a/b`\n\n### Step 4: Validation and Cross-Checking\n- After evaluating all expressions:\n  - If multiple appear true: Re-evaluate with emphasis on negation counts and short-circuiting\n  - If none appear true: Recheck arithmetic and capital facts\n  - Remember: Exactly one must be True\n\n### Common Mistakes to Avoid (with Examples from Previous Failures):\n1. ❌ **Miscounting deep negations**: `not not not not X` = `X` (not `not X`)\n   - Example: In Expression B [Example 2], `not not not True` was incorrectly evaluated as `True` instead of `False`\n2. ❌ **Missing short-circuit opportunities**: `False and X` should never evaluate X\n   - Example: In Expression D [Example 4], unnecessary evaluation led to errors\n3. ❌ **Decimal approximation**: Use exact fractions, not decimals\n   - Example: In Expression A [Example 2], `-7/2` should remain as fraction for exact comparison\n4. ❌ **Capital fact errors**: Verify against reference list thoroughly\n   - Example: In Expression E [Example 5], \"Iraq→Beirut\" is false (should be Baghdad)\n5. ❌ **Parentheses misgrouping**: Add explicit parentheses for ambiguous expressions\n   - Example: In Expression C [Example 2], missing parentheses changed logic\n\n### Demonstration Examples from Previous Failures:\n[Example 2]: Show correct evaluation of Expression B with emphasis on negation handling and short-circuiting\n[Example 4]: Demonstrate proper capital validation and arithmetic precision in Expression C\n[Example 5]: Illustrate exact fraction usage and temporary variable assignment in Expression E\n\n### Output Format Requirements:\n1. For each expression (A-E):\n   - Show the rewritten version with explicit parentheses\n   - Create a structural diagram showing nesting levels\n   - Assign temporary variables to sub-expressions\n   - Show step-by-step simplification with negation reduction\n   - Apply short-circuiting where possible\n   - Compute arithmetic exactly\n2. After all evaluations, verify only one is true\n3. Output only the letter (A-E) of the true expression\n\nNow, evaluate the following expressions. Show your complete reasoning using the required format, then output the final answer.",
                    "Q": 0.25,
                    "N": 0,
                    "uct_value": 0.0,
                    "reward": 0.25,
                    "children": []
                  },
                  {
                    "id": 9,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing\n- Convert all natural language comparisons to standard operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n- Treat factual statements (e.g., \"The capital of X is Y\") as boolean values using this comprehensive reference:\n  ✅ True Capitals: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran, Germany→Berlin, Nepal→Kathmandu, Azerbaijan→Baku, UAE→Abu Dhabi, Turkey→Ankara, Malaysia→Kuala Lumpur, Colombia→Bogota, India→New Delhi, Cameroon→Yaoundé, Iraq→Baghdad\n  ❌ False Capitals: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri, Germany→Munich, Nepal→Pokhara, Azerbaijan→Ganja, Turkey→Istanbul\n- For any capital not listed, assume False unless it is universally known (e.g., France→Paris).\n\n### Step 2: Explicit Grouping and Temporary Variables\n- Add explicit parentheses to ensure correct evaluation order:\n  - `and` has higher precedence than `or`\n  - Example: `A and B or C` becomes `(A and B) or C`\n  - When in doubt, group from left to right\n- For every sub-expression enclosed in parentheses, assign a temporary variable (T1, T2, etc.)\n- Document each temporary variable clearly with its value\n\n### Step 3: Evaluation Strategy\n1. **Simplify recursively** from innermost parentheses outward\n2. **Handle negations systematically**:\n   - Reduce pairs of `not` immediately: `not not X` ≡ X\n   - For multiple negations: count mod 2 (even: eliminate; odd: single `not`)\n   - Always reduce negations from the innermost expression outward\n3. **Apply strict short-circuiting**:\n   - For `and`: If left operand is false, return false immediately (do not evaluate right)\n   - For `or`: If left operand is true, return true immediately (do not evaluate right)\n4. **Compute arithmetic precisely**:\n   - Evaluate `max()` and `min()` first\n   - Use exact fractions (e.g., `-2/-6 = 1/3`)\n   - Never use decimal approximations\n   - Remember: `-a * -b = a*b`, `-a / -b = a/b`\n5. **Verify capital facts** against the reference list immediately when encountered\n\n### Step 4: Validation\n- After evaluating all expressions, if multiple appear true or none appear true:\n  - Recheck negation counts for each expression\n  - Verify parentheses grouping and temporary variable assignments\n  - Confirm arithmetic calculations using exact fractions\n  - Validate capital facts against the reference\n- Remember: Exactly one expression must be True\n\n### Common Mistakes to Avoid (with Examples from Previous Failures):\n1. ❌ Miscounting negations: `not not not True` = `False` (not `True`)\n   - Example: In Expression A, `not not not True` was incorrectly evaluated as `True`\n2. ❌ Forgetting short-circuiting: `False and X` should not evaluate X\n   - Example: In Expression B, unnecessary evaluation led to errors\n3. ❌ Misgrouping expressions: Ambiguous parentheses caused incorrect evaluation\n   - Example: In Expression D, missing parentheses changed the logic\n4. ❌ Using approximate arithmetic: `1/3` should not be approximated to `0.333`\n   - Example: In Expression A, exact fractions were needed for correct comparison\n5. ❌ Confusing capitals: \"The capital of Nepal is Kathmandu\" not Pokhara\n   - Example: In Expression E, capital knowledge was crucial\n6. ❌ Not using temporary variables: Complex sub-expressions were not properly isolated\n   - Example: In Expression C, lack of temporary variables caused grouping errors\n\n### Demonstration Examples from Previous Failures:\n[Example 3]: Show correct evaluation of Expression D with emphasis on:\n  - Systematic negation reduction from innermost outward\n  - Proper use of temporary variables for all sub-expressions\n  - Strict short-circuiting application\n  - Exact fraction arithmetic\n\n[Example 5]: Demonstrate proper evaluation of Expression C with emphasis on:\n  - Capital fact validation against reference list\n  - Step-by-step negation counting\n  - Parentheses grouping verification\n  - Temporary variable assignment for complex sub-expressions\n\n### Output Format Requirements:\n1. For each expression (A-E):\n   - Assign temporary variables to all complex sub-expressions\n   - Show step-by-step simplification with negation reduction\n   - Apply short-circuiting where possible (explicitly note when skipping evaluation)\n   - Compute arithmetic exactly using fractions\n   - Validate capital facts immediately when encountered\n   - Output the final boolean value for each expression\n2. After all evaluations, verify only one is true\n3. If multiple appear true, recheck with emphasis on negation counts and grouping\n4. Output only the letter (A-E) of the true expression\n\nNow, evaluate the following expressions. Show your reasoning using temporary variables and step-by-step simplification, then output the final answer.",
                    "Q": 0.25,
                    "N": 0,
                    "uct_value": 0.0,
                    "reward": 0.25,
                    "children": []
                  },
                  {
                    "id": 10,
                    "depth": 4,
                    "action_sequence": [
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction",
                      "FailureDrivenAction"
                    ],
                    "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing\n- Convert all natural language comparisons to standard operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n- Treat factual statements (e.g., \"The capital of X is Y\") as boolean values using this comprehensive reference:\n  ✅ True Capitals: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran, Germany→Berlin, Nepal→Kathmandu, Azerbaijan→Baku, UAE→Abu Dhabi, Turkey→Ankara, Malaysia→Kuala Lumpur, Colombia→Bogota, India→New Delhi, Cameroon→Yaoundé\n  ❌ False Capitals: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri, Germany→Munich, Nepal→Pokhara, Azerbaijan→Ganja, Turkey→Istanbul\n\n### Step 2: Explicit Grouping\n- Add explicit parentheses to ensure correct evaluation order:\n  - `and` has higher precedence than `or`\n  - Example: `A and B or C` becomes `(A and B) or C`\n  - When in doubt, group from left to right\n\n### Step 3: Evaluation Strategy\n1. **Simplify recursively** from innermost parentheses outward\n2. **Use temporary variables** (T1, T2, ...) for complex sub-expressions:\n   - Assign variables to all non-trivial sub-expressions\n   - Reference these variables in subsequent steps\n3. **Handle negations systematically**:\n   - Reduce pairs of `not` immediately: `not not X` ≡ X\n   - For multiple negations: count mod 2 (even: eliminate; odd: single `not`)\n   - Show each reduction step explicitly\n4. **Apply strict short-circuiting**:\n   - For `and`: If left operand is false, return false immediately (do not evaluate right)\n   - For `or`: If left operand is true, return true immediately (do not evaluate right)\n5. **Compute arithmetic precisely**:\n   - Evaluate `max()` and `min()` first\n   - Use exact fractions (e.g., `-2/-6 = 1/3`)\n   - Remember: `-a * -b = a*b`, `-a / -b = a/b`\n6. **Verify capital facts** against the reference list\n\n### Step 4: Validation\n- After evaluating all expressions, if multiple appear true or none appear true:\n  - Recheck negation counts\n  - Verify parentheses grouping\n  - Confirm arithmetic calculations\n  - Validate capital facts\n- Remember: Exactly one expression must be True\n\n### Common Mistakes to Avoid (with Examples from Previous Failures):\n1. ❌ Miscounting negations: `not not not True` = `False` (not `True`)\n   - Example: In Expression A, `not not not True` was incorrectly evaluated as `True`\n2. ❌ Forgetting short-circuiting: `False and X` should not evaluate X\n   - Example: In Expression B, unnecessary evaluation led to errors\n3. ❌ Misgrouping expressions: Ambiguous parentheses caused incorrect evaluation\n   - Example: In Expression D, missing parentheses changed the logic\n4. ❌ Using approximate arithmetic: `1/3` should not be approximated to `0.333`\n   - Example: In Expression A, exact fractions were needed for correct comparison\n5. ❌ Confusing capitals: \"The capital of Nepal is Kathmandu\" not Pokhara\n   - Example: In Expression E, capital knowledge was crucial\n\n### Demonstration Examples from Previous Failures:\n[Example 1]: Expression A evaluation showing correct negation handling:\n  - T1 = 4 * -6 = -24\n  - T2 = -24 > -5 → False\n  - T3 = not not T2 = not not False = False\n  - T4 = max(7,9,-10,-6) = 9, min = -10 → 9 - (-10) = 19\n  - T5 = 19 > 6 → True\n  - T6 = not not not T5 = not not not True = False\n  - T7 = T3 or T6 = False or False = False\n  - Continue step-by-step...\n\n[Example 2]: Expression D evaluation showing proper grouping and capital validation:\n  - T1 = max(-1,-6,9,-7) = 9, min = -7 → 9 - (-7) = 16\n  - T2 = 16 > 4 → True\n  - T3 = \"The capital of UAE is Abu Dhabi\" → True\n  - T4 = not not not T3 = False\n  - T5 = (correctly grouped sub-expression) → False\n  - Final result: False\n\n### Output Format:\n1. For each expression (A-E):\n   - Show step-by-step simplification with temporary variables\n   - Apply short-circuiting where possible\n   - Compute arithmetic exactly\n   - Reduce negations systematically\n2. After all evaluations, verify only one is true\n3. Output only the letter (A-E) of the true expression\n\nNow, evaluate the following expressions. Show your reasoning using temporary variables, then output the final answer.",
                    "Q": 0.35,
                    "N": 0,
                    "uct_value": 0.0,
                    "reward": 0.35,
                    "children": []
                  }
                ]
              },
              {
                "id": 8,
                "depth": 3,
                "action_sequence": [
                  "FailureDrivenAction",
                  "FailureDrivenAction",
                  "FailureDrivenAction"
                ],
                "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing and Flattening\n- Convert natural language comparisons to operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n- Treat factual statements using this expanded reference:\n  ✅ True Capitals: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran, Azerbaijan→Baku, UAE→Abu Dhabi, Cameroon→Yaounde, Turkey→Ankara, Malaysia→Kuala Lumpur, Germany→Berlin\n  ❌ False Capitals: Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri, Azerbaijan→Ganja, Nepal→Pokhara, Denmark→Aarhus, Turkey→Istanbul, Belarus→Grodno\n- For any capital not listed, use common knowledge but verify carefully.\n\n**Flatten complex expressions by assigning sub-expressions to temporary variables (T1, T2, ...) to reduce nesting depth.**\n\n### Step 2: Evaluation Strategy\n1. **Reduce negation chains immediately**:\n   - Count consecutive `not`s: even number cancels out, odd number reduces to single `not`\n   - Apply this before evaluating inner expressions\n\n2. **Simplify recursively** from innermost parentheses outward\n\n3. **Apply strict short-circuiting**:\n   - For `and`: If any operand is false, return false immediately (stop evaluation)\n   - For `or`: If any operand is true, return true immediately (stop evaluation)\n\n4. **Compute arithmetic with precision**:\n   - Evaluate `max()` and `min()` first\n   - Handle fractions exactly (e.g., 1/3 = 0.333...)\n   - Follow order: multiplication/division before addition/subtraction\n   - Show intermediate calculations for verification\n   - Remember: `-a * -b = a*b`, `-a / -b = a/b`\n\n5. **Verify parentheses grouping** by counting opening/closing pairs\n   - When in doubt, evaluate innermost parentheses first\n\n### Step 3: Verification\n- If multiple expressions appear true:\n  - Re-check the shortest expressions first\n  - Double-check all capital facts and arithmetic calculations\n  - Re-evaluate with extra attention to short-circuiting opportunities\n- Remember: Exactly one expression must be true\n\n### Common Mistakes to Avoid (with Examples from Previous Failures):\n1. ❌ Miscounting negations: `not not not True` = `False` (not `True`)\n2. ❌ Forgetting short-circuiting: `False and X` = `False` (don't evaluate X)\n3. ❌ Miscomputing arithmetic: `-8 * -8 = 64` (not `-64`)\n4. ❌ Confusing capitals: Baghdad is Iraq's capital, not Beirut\n5. ❌ Ignoring fractional values: `1/3 = 0.333...` (not `0`)\n6. ❌ Misgrouping expressions: Always verify parentheses hierarchy\n7. ❌ Failing to flatten deep nesting: Use temporary variables for complex sub-expressions\n\n### Demonstration Examples from Previous Failures:\n[Example 1 from provided failure cases with corrected step-by-step evaluation]\n[Example 2 from provided failure cases with corrected step-by-step evaluation]\n\n### Output Format:\n1. For each expression (A-E):\n   - Show flattened structure with temporary variables\n   - Step-by-step evaluation with intermediate results\n   - Final boolean value\n2. Verify only one expression is true\n3. Output only the letter (A-E) of the true expression\n\nNow, evaluate the following expressions. Output your reasoning step by step, then the final answer.",
                "Q": 0.2,
                "N": 0,
                "uct_value": 0.0,
                "reward": 0.2,
                "children": []
              }
            ]
          },
          {
            "id": 6,
            "depth": 2,
            "action_sequence": [
              "FailureDrivenAction",
              "FailureDrivenAction"
            ],
            "prompt": "You are an expert assistant that evaluates complex boolean expressions. Given five expressions (A through E), exactly one evaluates to True. Follow these steps meticulously:\n\n### Step 1: Preprocessing\n- Convert natural language comparisons to standard operators:\n  - \"is less than or equal to\" → `<=`\n  - \"is greater than or equal to\" → `>=`\n  - \"is less than\" → `<`\n  - \"is greater than\" → `>`\n- Treat factual statements using this reference:\n  ✅ True: Norway→Oslo, Canada→Ottawa, Afghanistan→Kabul, Denmark→Copenhagen, Armenia→Yerevan, Jordan→Amman, Belarus→Minsk, Nigeria→Abuja, Iran→Tehran, Gambia→Banjul, Malaysia→Putrajaya, Colombia→Bogota, Azerbaijan→Baku, Nepal→Kathmandu, Turkey→Ankara, Cameroon→Yaoundé, UAE→Abu Dhabi, India→New Delhi, Iraq→Baghdad\n  ❌ False: Any other claim not listed (e.g., Norway→Bergen, Colombia→Medellin, Iraq→Beirut, UAE→Dubai, Cameroon→Douala, Gambia→Libreville, Canada→Toronto, India→Mumbai, Armenia→Gyumri).\n\n### Step 2: Structured Evaluation\n1. **Parse Nesting**: Rewrite the expression with explicit parentheses numbering (e.g., \"(1) (2) (3)\") to track levels.\n2. **Simplify Innermost First**: Always evaluate from the deepest parentheses outward.\n3. **Negation Rules**:\n   - `not not X` ≡ X\n   - `not not not X` ≡ not X\n   - Apply step-by-step; do not skip layers.\n4. **Short-Circuiting**:\n   - For `and`: If left operand is false, return false immediately.\n   - For `or`: If left operand is true, return true immediately.\n5. **Arithmetic Precision**:\n   - Compute `max`/`min` first (e.g., \"max(-6,-5,-4,9)=9, min=-6, diff=15\").\n   - Show all calculations (e.g., \"-10 / -7 ≈ 1.4286\").\n   - Handle negatives and fractions carefully.\n\n### Step 3: Verification\n- If multiple expressions seem true, re-evaluate each from scratch.\n- Confirm only one is true.\n\n### Common Mistakes to Avoid (with Examples):\n1. ❌ **Negation Miscount**:  \n   Example: `not not not True` = `not True` = `False` (not `True`).  \n   In Example 2, miscounting `not` chains led to errors.\n\n2. ❌ **Arithmetic Errors**:  \n   Example: `-8 * -8 = 64` (not `-64`).  \n   In Example 4, miscomputing differences caused false positives.\n\n3. ❌ **Capital Confusion**:  \n   Example: \"The capital of Cameroon is Douala\" is false (true capital is Yaoundé).  \n   In Example 5, this affected Expression A.\n\n4. ❌ **Short-Circuiting Overlooked**:  \n   Example: `False and (…)` must short-circuit to `False` without evaluating right side.  \n   In Example 2, this was sometimes missed in nested expressions.\n\n5. ❌ **Nesting Misparsing**:  \n   Example: In Expression A (Example 2), misgrouping parentheses led to incorrect evaluation.  \n   Always rewrite with clear numbering.\n\n### Demonstration (From Example 2):\n**Input**: Expression A snippet:  \n`(not (not (not not (not not (not not not (False and True)) and not not (8.57 <= -1)) and ...`  \n**Step-by-Step**:  \n1. Innermost: `False and True` → `False` (short-circuit).  \n2. `not not not False` → `not not True` → `not False` → `True`.  \n3. `and not not (8.57 <= -1)` → `and not not False` → `and False` → `False`.  \n4. Continue outward...\n\n### Output Format:\nAfter analysis, output only the letter (A-E) of the true expression and a brief reason (e.g., \"B: after full simplification, it evaluates to True\").\n\nNow, evaluate the following expressions:",
            "Q": 0.35,
            "N": 0,
            "uct_value": 0.003346415497614626,
            "reward": 0.35,
            "children": []
          }
        ]
      }
    ]
  }
}